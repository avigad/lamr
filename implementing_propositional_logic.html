

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>5. Implementing Propositional Logic &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="6. Decision Procedures for Propositional Logic" href="decision_procedures_for_propositional_logic.html" />
    <link rel="prev" title="4. Propositional Logic" href="propositional_logic.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Logic and Mechanized Reasoning
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. Implementing Propositional Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#syntax">5.1. Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="#semantics">5.2. Semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#normal-forms">5.3. Normal Forms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">5.4. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="deduction_for_propositional_logic.html">8. Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">9. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">11. Implementing First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_first_order_logic.html">12. Decision Procedures for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">13. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="deduction_for_first_order_logic.html">14. Deduction for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">15. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">16. First-Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="beyond_first_order_logic.html">17. Beyond First-Order Logic</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">5. </span>Implementing Propositional Logic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/implementing_propositional_logic.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="implementing-propositional-logic">
<span id="chapter-implementing-propositional-logic"></span><h1><span class="section-number">5. </span>Implementing Propositional Logic<a class="headerlink" href="#implementing-propositional-logic" title="Permalink to this headline">¶</a></h1>
<div class="section" id="syntax">
<span id="section-implementing-propositional-syntax"></span><h2><span class="section-number">5.1. </span>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h2>
<p>We have seen that the set of propositional formulas can be defined
inductively, and
we have seen that Lean makes it easy to specify inductively defined types.
It’s a match made in heaven!
Here is the definition of the type of propositional formulas that we will
use in this course:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">inductive</span> <span class="n">PropForm</span>
  <span class="bp">|</span> <span class="n">tr</span>     <span class="o">:</span> <span class="n">PropForm</span>
  <span class="bp">|</span> <span class="n">fls</span>    <span class="o">:</span> <span class="n">PropForm</span>
  <span class="bp">|</span> <span class="n">var</span>    <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">PropForm</span>
  <span class="bp">|</span> <span class="n">conj</span>   <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">PropForm</span>
  <span class="bp">|</span> <span class="n">disj</span>   <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">PropForm</span>
  <span class="bp">|</span> <span class="n">impl</span>   <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">PropForm</span>
  <span class="bp">|</span> <span class="n">neg</span>    <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">PropForm</span>
  <span class="bp">|</span> <span class="n">biImpl</span> <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">PropForm</span>
  <span class="n">deriving</span> <span class="n">Repr</span><span class="o">,</span> <span class="n">DecidableEq</span>

<span class="kd">end</span> <span class="n">hidden</span>

<span class="k">#print</span> <span class="n">PropForm</span>

<span class="kn">open</span> <span class="n">PropForm</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">impl</span> <span class="o">(</span><span class="n">conj</span> <span class="o">(</span><span class="n">var</span> <span class="s2">&quot;p&quot;</span><span class="o">)</span> <span class="o">(</span><span class="n">var</span> <span class="s2">&quot;q&quot;</span><span class="o">))</span> <span class="o">(</span><span class="n">var</span> <span class="s2">&quot;r&quot;</span><span class="o">))</span>
</pre></div>
</div>
<p>You can find this example in the file <cite>implementing_propositional_logic/examples.lean</cite> in the <cite>User</cite> folder of the course repository.</p>
<p>The command <cite>import LAMR.Util.Propositional</cite> at the top of the file
imports the part of the library with functions that we provide for you
to deal with propositional logic.
We will often put a copy of a definition from the library in an
examples file so you can experiment with it.
Here we have put it in a namespace called <cite>hidden</cite> so that
our copy’s full name is <cite>hidden.PropForm</cite>,
which won’t conflict with the one in the library.
Outside the <cite>hidden</cite> namespace, the command <cite>#print PropForm</cite>
refers to the real one, that is, the one in the library.
The command <cite>open PropForm</cite> means that we can write, for example,
<cite>tr</cite> for the first constructor instead of <cite>PropForm.tr</cite>.
Try writing some propositional formulas of your own.
There should be squiggly blue lines under the the <cite>#print</cite>
and <cite>#check</cite> commands in VSCode,
indicating that there is Lean output associated with these.
You can see it by hovering over the commands,
or by moving the caret to the command and checking the
<cite>Lean infoview</cite> window.</p>
<p>The phrase <cite>deriving Repr, DecidableEq</cite> tells Lean to automatically
define functions to be used to test equality of two expressions
of type <cite>PropForm</cite> and to display the result of an <cite>#eval</cite>.
We’ll generally leave these out of the display from now on.
You an always use <cite>#check</cite> and <cite>#print</cite> to learn more about
a definition in the library. If you hold down <cite>ctrl</cite> and click on an identifier,
the VSCode Lean extension will take you to the definition in the library.
Simply holding down <cite>ctrl</cite> and hovering over it will show you the
definition in a pop-up window.
Try taking a look at the definition of <cite>PropForm</cite> in the library.</p>
<p>Writing propositional formulas using constructors can be a
pain in the neck.
In the library, we have used Lean’s mechanisms for defining new syntax
to implement nicer syntax.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">prop</span><span class="bp">!</span><span class="o">{</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="o">(</span><span class="n">r</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span> <span class="bp">→</span> <span class="n">q</span><span class="o">}</span>
<span class="k">#check</span> <span class="n">prop</span><span class="bp">!</span><span class="o">{</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">p</span><span class="o">}</span>

<span class="kd">def</span> <span class="n">propExample</span> <span class="o">:=</span> <span class="n">prop</span><span class="bp">!</span><span class="o">{</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">∧</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">s1</span> <span class="bp">→</span> <span class="n">s2</span> <span class="o">}</span>

<span class="k">#print</span> <span class="n">propExample</span>
<span class="k">#eval</span> <span class="n">propExample</span>

<span class="k">#eval</span> <span class="n">toString</span> <span class="n">propExample</span>
</pre></div>
</div>
<p>You can get the symbols by typing <cite>\and</cite>, <cite>\to</cite>, <cite>\or</cite>, <cite>\not</cite>, and <cite>\iff</cite>
in VS Code. And, in general, when you see a symbol in VSCode,
hovering over it with the mouse shows you how to type it.
Once again, try typing some examples of your own.
The library defines the function <cite>PropForm.toString</cite> that produces
a more readable version of a propositional formula,
one that, when inserted within the <cite>prop!{…}</cite> brackets,
should produce the same result.</p>
<p>Because <cite>PropForm</cite> is inductively defined, we can easily define
functions using structural recursion.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span> <span class="n">PropForm</span>

<span class="kd">def</span> <span class="n">complexity</span> <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">tr</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">fls</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">neg</span> <span class="n">A</span> <span class="bp">=&gt;</span> <span class="n">complexity</span> <span class="n">A</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">complexity</span> <span class="n">A</span> <span class="bp">+</span> <span class="n">complexity</span> <span class="n">B</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">complexity</span> <span class="n">A</span> <span class="bp">+</span> <span class="n">complexity</span> <span class="n">B</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">impl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">complexity</span> <span class="n">A</span> <span class="bp">+</span> <span class="n">complexity</span> <span class="n">B</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">biImpl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">complexity</span> <span class="n">A</span> <span class="bp">+</span> <span class="n">complexity</span> <span class="n">B</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">depth</span> <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">tr</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">fls</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">neg</span> <span class="n">A</span> <span class="bp">=&gt;</span> <span class="n">depth</span> <span class="n">A</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">Nat.max</span> <span class="o">(</span><span class="n">depth</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">depth</span> <span class="n">B</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">Nat.max</span> <span class="o">(</span><span class="n">depth</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">depth</span> <span class="n">B</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">impl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">Nat.max</span> <span class="o">(</span><span class="n">depth</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">depth</span> <span class="n">B</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="n">biImpl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">Nat.max</span> <span class="o">(</span><span class="n">depth</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">depth</span> <span class="n">B</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">vars</span> <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">String</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">s</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">tr</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">fls</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">neg</span> <span class="n">A</span> <span class="bp">=&gt;</span> <span class="n">vars</span> <span class="n">A</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">vars</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">union</span> <span class="o">(</span><span class="n">vars</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">vars</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">union</span> <span class="o">(</span><span class="n">vars</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">impl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">vars</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">union</span> <span class="o">(</span><span class="n">vars</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">biImpl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">vars</span> <span class="n">A</span><span class="o">)</span><span class="bp">.</span><span class="n">union</span> <span class="o">(</span><span class="n">vars</span> <span class="n">B</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">complexity</span> <span class="n">propExample</span>
<span class="k">#eval</span> <span class="n">depth</span> <span class="n">propExample</span>
<span class="k">#eval</span> <span class="n">vars</span> <span class="n">propExample</span>

<span class="kd">end</span> <span class="n">PropForm</span>

<span class="k">#eval</span> <span class="n">PropForm.complexity</span> <span class="n">propExample</span>
<span class="k">#eval</span> <span class="n">propExample.complexity</span>
</pre></div>
</div>
<p>The function <cite>List.union</cite> returns concatenation of the two lists with
duplicates removed, assuming that the original two lists had no duplicate elements.</p>
</div>
<div class="section" id="semantics">
<span id="implementing-propositional-semantics"></span><h2><span class="section-number">5.2. </span>Semantics<a class="headerlink" href="#semantics" title="Permalink to this headline">¶</a></h2>
<p>The course library defines the type <cite>PropAssignment</cite> to be <cite>List (String × Bool)</cite>.
If <cite>v</cite> has type <cite>PropAssignment</cite>, you should think of the expression <cite>v.eval s</cite> as
assigning a truth value to the variable named <cite>s</cite>.
The following function then evaluates the truth value of any propositional
formula under assignment <cite>v</cite>:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">PropForm.eval</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">PropAssignment</span><span class="o">)</span> <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">Bool</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">v.eval</span> <span class="n">s</span>
  <span class="bp">|</span> <span class="n">tr</span> <span class="bp">=&gt;</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">fls</span> <span class="bp">=&gt;</span> <span class="n">false</span>
  <span class="bp">|</span> <span class="n">neg</span> <span class="n">A</span> <span class="bp">=&gt;</span> <span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">impl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">biImpl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">B</span><span class="o">))</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">B</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">))</span>

<span class="c1">-- try it out</span>
<span class="k">#eval</span> <span class="k">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">PropAssignment.mk</span> <span class="o">[(</span><span class="s2">&quot;p&quot;</span><span class="o">,</span> <span class="n">true</span><span class="o">),</span> <span class="o">(</span><span class="s2">&quot;q&quot;</span><span class="o">,</span> <span class="n">true</span><span class="o">),</span> <span class="o">(</span><span class="s2">&quot;r&quot;</span><span class="o">,</span> <span class="n">true</span><span class="o">)]</span>
      <span class="n">propExample.eval</span> <span class="n">v</span>
</pre></div>
</div>
<p>The example at the end defines <cite>v</cite> to be the assignment that
assigns the value <cite>true</cite> to the strings <cite>“p”</cite>, <cite>“q”</cite>, and <cite>“r”</cite>
and false to all the others.
This is a reasonably convenient way to describe truth assignments manually,
so the library provides a function <cite>PropAssignment.mk</cite> and notation <cite>propassign!{…}</cite> to support that.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">propassign</span><span class="bp">!</span><span class="o">{</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">r</span><span class="o">}</span>

<span class="k">#eval</span> <span class="n">propExample.eval</span> <span class="n">propassign</span><span class="bp">!</span><span class="o">{</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">r</span><span class="o">}</span>
</pre></div>
</div>
<p>You should think about how the next function manages to compute a list
of all the sublists of a given list.
It is analogous to the power set operation in set theory.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">allSublists</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="o">[[]]</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">as</span><span class="o">)</span> <span class="bp">=&gt;</span>
      <span class="k">let</span> <span class="n">recval</span> <span class="o">:=</span> <span class="n">allSublists</span> <span class="n">as</span>
      <span class="n">recval.map</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="bp">.</span><span class="o">)</span> <span class="bp">++</span> <span class="n">recval</span>

<span class="k">#eval</span> <span class="n">allSublists</span> <span class="n">propExample.vars</span>
</pre></div>
</div>
<p>With that in hand, here is a function that computes the truth table of a
propositional formula.
The value of <cite>truthTable A</cite> is a list of pairs:
the first element of the pair is the list of <cite>true</cite>/<cite>false</cite> values assigned
to the elements of <cite>vars A</cite>, and the second element
is the truth value of <cite>A</cite> under that assignment.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">truthTable</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">PropForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">List</span> <span class="n">Bool</span> <span class="bp">×</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="n">vars</span> <span class="o">:=</span> <span class="n">A.vars</span>
  <span class="k">let</span> <span class="n">assignments</span> <span class="o">:=</span> <span class="o">(</span><span class="n">allSublists</span> <span class="n">vars</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">PropAssignment.mk</span> <span class="o">(</span><span class="n">l.map</span> <span class="o">(</span><span class="bp">.</span><span class="o">,</span> <span class="n">true</span><span class="o">)))</span>
  <span class="k">let</span> <span class="n">evalLine</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">v</span> <span class="o">:</span> <span class="n">PropAssignment</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">vars.map</span> <span class="n">v.eval</span><span class="o">,</span> <span class="n">A.eval</span> <span class="n">v</span><span class="o">)</span>
  <span class="n">assignments.map</span> <span class="n">evalLine</span>

<span class="k">#eval</span> <span class="n">truthTable</span> <span class="n">propExample</span>
</pre></div>
</div>
<p>We can now use the list operation <cite>List.all</cite> to test whether a formula is valid,
and we can use <cite>List.some</cite> to test whether it is satisfiable.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">PropForm.isValid</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">PropForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="n">List.all</span> <span class="o">(</span><span class="n">truthTable</span> <span class="n">A</span><span class="o">)</span> <span class="n">Prod.snd</span>
<span class="kd">def</span> <span class="n">PropForm.isSat</span><span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">PropForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="n">List.any</span> <span class="o">(</span><span class="n">truthTable</span> <span class="n">A</span><span class="o">)</span> <span class="n">Prod.snd</span>

<span class="k">#eval</span> <span class="n">propExample.isValid</span>
<span class="k">#eval</span> <span class="n">propExample.isSat</span>
</pre></div>
</div>
</div>
<div class="section" id="normal-forms">
<span id="section-implementing-propositional-normal-forms"></span><h2><span class="section-number">5.3. </span>Normal Forms<a class="headerlink" href="#normal-forms" title="Permalink to this headline">¶</a></h2>
<p>The library defines an inductive type of negation-normal form formulas:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">Lit</span>
  <span class="bp">|</span> <span class="n">tr</span>  <span class="o">:</span> <span class="n">Lit</span>
  <span class="bp">|</span> <span class="n">fls</span> <span class="o">:</span> <span class="n">Lit</span>
  <span class="bp">|</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">Lit</span>
  <span class="bp">|</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">Lit</span>

<span class="kd">inductive</span> <span class="n">NnfForm</span> <span class="o">:=</span>
  <span class="bp">|</span> <span class="n">lit</span>  <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Lit</span><span class="o">)</span>       <span class="o">:</span> <span class="n">NnfForm</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">NnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">NnfForm</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">NnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">NnfForm</span>
</pre></div>
</div>
<p>It is then straightforward to define the negation operation for formulas in
negation normal form, and a translation from propositional formulas
to formulas in negation normal form.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">Lit.negate</span> <span class="o">:</span> <span class="n">Lit</span> <span class="bp">→</span> <span class="n">Lit</span>
  <span class="bp">|</span> <span class="n">tr</span>   <span class="bp">=&gt;</span> <span class="n">fls</span>
  <span class="bp">|</span> <span class="n">fls</span>  <span class="bp">=&gt;</span> <span class="n">tr</span>
  <span class="bp">|</span> <span class="n">pos</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">neg</span> <span class="n">s</span>
  <span class="bp">|</span> <span class="n">neg</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">pos</span> <span class="n">s</span>

<span class="kd">def</span> <span class="n">NnfForm.neg</span> <span class="o">:</span> <span class="n">NnfForm</span> <span class="bp">→</span> <span class="n">NnfForm</span>
  <span class="bp">|</span> <span class="n">lit</span> <span class="n">l</span>    <span class="bp">=&gt;</span> <span class="n">lit</span> <span class="n">l.negate</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">=&gt;</span> <span class="n">disj</span> <span class="o">(</span><span class="n">neg</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">neg</span> <span class="n">q</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">=&gt;</span> <span class="n">conj</span> <span class="o">(</span><span class="n">neg</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">neg</span> <span class="n">q</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">PropForm</span>

<span class="kd">def</span> <span class="n">toNnfForm</span> <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">NnfForm</span>
  <span class="bp">|</span> <span class="n">tr</span>         <span class="bp">=&gt;</span> <span class="n">NnfForm.lit</span> <span class="n">Lit.tr</span>
  <span class="bp">|</span> <span class="n">fls</span>        <span class="bp">=&gt;</span> <span class="n">NnfForm.lit</span> <span class="n">Lit.fls</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="n">n</span>      <span class="bp">=&gt;</span> <span class="n">NnfForm.lit</span> <span class="o">(</span><span class="n">Lit.pos</span> <span class="n">n</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">neg</span> <span class="n">p</span>      <span class="bp">=&gt;</span> <span class="n">p.toNnfForm.neg</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">p</span> <span class="n">q</span>   <span class="bp">=&gt;</span> <span class="n">NnfForm.conj</span> <span class="n">p.toNnfForm</span> <span class="n">q.toNnfForm</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">p</span> <span class="n">q</span>   <span class="bp">=&gt;</span> <span class="n">NnfForm.disj</span> <span class="n">p.toNnfForm</span> <span class="n">q.toNnfForm</span>
  <span class="bp">|</span> <span class="n">impl</span> <span class="n">p</span> <span class="n">q</span>   <span class="bp">=&gt;</span> <span class="n">NnfForm.disj</span> <span class="n">p.toNnfForm.neg</span> <span class="n">q.toNnfForm</span>
  <span class="bp">|</span> <span class="n">biImpl</span> <span class="n">p</span> <span class="n">q</span> <span class="bp">=&gt;</span> <span class="n">NnfForm.conj</span> <span class="o">(</span><span class="n">NnfForm.disj</span> <span class="n">p.toNnfForm.neg</span> <span class="n">q.toNnfForm</span><span class="o">)</span>
                               <span class="o">(</span><span class="n">NnfForm.disj</span> <span class="n">q.toNnfForm.neg</span> <span class="n">p.toNnfForm</span><span class="o">)</span>

<span class="kd">end</span> <span class="n">PropForm</span>
</pre></div>
</div>
<p>Putting the first in the namespace <cite>NnfForm</cite> has the effect that given <cite>A : NnfForm</cite>,
we can write <cite>A.neg</cite> instead of <cite>NnfForm.neg A</cite>.
Similarly, putting the second definition in the namespace <cite>PropForm</cite> means we can write
<cite>A.toNnfForm</cite> to put a propositional formula in negation normal form.</p>
<p>We can try them out on the example defined above:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">propExample.toNnfForm</span>
<span class="k">#eval</span> <span class="n">toString</span> <span class="n">propExample.toNnfForm</span>
</pre></div>
</div>
<p>To handle conjunctive normal form, the library defines a type <cite>Lit</cite> of literals.
A <cite>Clause</cite> is then a list of literals, and a <cite>CnfForm</cite> is a list of clauses.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">Clause</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">Lit</span>

<span class="kd">def</span> <span class="n">CnfForm</span> <span class="o">:=</span> <span class="n">List</span> <span class="n">Clause</span>
</pre></div>
</div>
<p>As usual, you can use <cite>#check</cite> and <cite>#print</cite> to find information about them, and ctrl-click
to see the definitions in the library.
Since, as usual, defining things using constructors can be annoying,
the library defines syntax for writing expressions of these types.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">exLit0</span> <span class="o">:=</span> <span class="n">lit</span><span class="bp">!</span><span class="o">{</span> <span class="n">p</span> <span class="o">}</span>
<span class="kd">def</span> <span class="n">exLit1</span> <span class="o">:=</span> <span class="n">lit</span><span class="bp">!</span><span class="o">{</span> <span class="bp">-</span><span class="n">q</span> <span class="o">}</span>

<span class="k">#print</span> <span class="n">exLit0</span>
<span class="k">#print</span> <span class="n">exLit1</span>

<span class="kd">def</span> <span class="n">exClause0</span> <span class="o">:=</span> <span class="n">clause</span><span class="bp">!</span><span class="o">{</span> <span class="n">p</span> <span class="o">}</span>
<span class="kd">def</span> <span class="n">exClause1</span> <span class="o">:=</span> <span class="n">clause</span><span class="bp">!</span><span class="o">{</span> <span class="n">p</span> <span class="bp">-</span><span class="n">q</span> <span class="n">r</span> <span class="o">}</span>
<span class="kd">def</span> <span class="n">exClause2</span> <span class="o">:=</span> <span class="n">clause</span><span class="bp">!</span><span class="o">{</span> <span class="n">r</span> <span class="bp">-</span><span class="n">s</span> <span class="o">}</span>

<span class="k">#print</span> <span class="n">exClause0</span>
<span class="k">#print</span> <span class="n">exClause1</span>
<span class="k">#print</span> <span class="n">exClause2</span>

<span class="kd">def</span> <span class="n">exCnf0</span> <span class="o">:=</span> <span class="n">cnf</span><span class="bp">!</span><span class="o">{</span>
  <span class="n">p</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">p</span> <span class="n">q</span> <span class="bp">-</span><span class="n">r</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">p</span> <span class="n">q</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">exCnf1</span> <span class="o">:=</span> <span class="n">cnf</span><span class="bp">!</span><span class="o">{</span>
  <span class="n">p</span> <span class="bp">-</span><span class="n">q</span><span class="o">,</span>
  <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">p</span> <span class="bp">-</span><span class="n">r</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">p</span> <span class="n">r</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">exCnf2</span> <span class="o">:=</span> <span class="n">cnf</span><span class="bp">!</span><span class="o">{</span>
  <span class="n">p</span> <span class="n">q</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">p</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">q</span>
<span class="o">}</span>

<span class="k">#print</span> <span class="n">exCnf0</span>
<span class="k">#print</span> <span class="n">exCnf1</span>
<span class="k">#print</span> <span class="n">exCnf2</span>

<span class="k">#eval</span> <span class="n">toString</span> <span class="n">exClause1</span>
<span class="k">#eval</span> <span class="n">toString</span> <span class="n">exCnf2</span>
</pre></div>
</div>
<p>Let us now consider what is needed to put an arbitrary propositional formula in
conjunctive normal form. In <a class="reference internal" href="propositional_logic.html#section-normal-forms"><span class="std std-numref">Section 4.5</span></a>, we saw that the key
is to show that the disjunction of two CNF formulas is again CNF.
Lean’s library has a function <cite>List.insert</cite>, which adds an element to a list;
if the element already appears in the list, it does nothing.
It has a function <cite>List.union</cite> that will form the union of two lists;
if the original two lists have no duplicates, the union won’t either.
Finally, we have a function <cite>List.Union</cite> which takes the union of a list of lists.
Since clauses are lists, we can use them on clauses:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">List.insert</span> <span class="n">lit</span><span class="bp">!</span><span class="o">{</span> <span class="n">r</span> <span class="o">}</span> <span class="n">exClause0</span>

<span class="k">#eval</span> <span class="n">exClause0.union</span> <span class="n">exClause1</span>

<span class="k">#eval</span> <span class="n">List.Union</span> <span class="o">[</span><span class="n">exClause0</span><span class="o">,</span> <span class="n">exClause1</span><span class="o">,</span> <span class="n">exClause2</span><span class="o">]</span>
</pre></div>
</div>
<p>We can now take the disjunction of a single clause and a CNF formula by taking
the union of the clause with each element of the CNF formula.
We can implement that with the function <cite>List.map</cite>:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">exCnf1.map</span> <span class="n">exClause0.union</span>
</pre></div>
</div>
<p>This applied the function “take the union with <cite>exClause0</cite>” to each element of <cite>exCnf1</cite>,
and returns the resulting list.
We can now define the disjunction of two CNF formulas by taking all the
clauses in the first,
taking the disjunction of each clause with the second CNF,
and then taking the union of all of those, corresponding to the conjunctions
of the CNFs. Here is the library definition, and an example:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">CnfForm.disj</span> <span class="o">(</span><span class="n">cnf1</span> <span class="n">cnf2</span> <span class="o">:</span> <span class="n">CnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">CnfForm</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">cnf1.map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">cls</span> <span class="bp">=&gt;</span> <span class="n">cnf2.map</span> <span class="n">cls.union</span><span class="o">))</span><span class="bp">.</span><span class="n">Union</span>

<span class="k">#eval</span> <span class="n">cnf</span><span class="bp">!</span><span class="o">{</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">u</span> <span class="bp">-</span><span class="n">v</span><span class="o">}</span><span class="bp">.</span><span class="n">disj</span> <span class="n">cnf</span><span class="bp">!</span><span class="o">{</span><span class="n">r1</span> <span class="n">r2</span><span class="o">,</span> <span class="n">s1</span> <span class="n">s2</span><span class="o">,</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span><span class="o">}</span>
<span class="k">#eval</span> <span class="n">toString</span> <span class="bp">$</span> <span class="n">cnf</span><span class="bp">!</span><span class="o">{</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">u</span> <span class="bp">-</span><span class="n">v</span><span class="o">}</span><span class="bp">.</span><span class="n">disj</span> <span class="n">cnf</span><span class="bp">!</span><span class="o">{</span><span class="n">r1</span> <span class="n">r2</span><span class="o">,</span> <span class="n">s1</span> <span class="n">s2</span><span class="o">,</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">t3</span><span class="o">}</span>
</pre></div>
</div>
<p>Functional programmers like this sort of definition; it’s short, clever,
and inscrutable.
You should think about defining the disjunction of two CNF formulas by hand,
using recursions over clauses and CNF formulas.
Your solution will most likely reconstruct the effect of the instance <cite>map</cite> and
<cite>Union</cite> in the library definition,
and that will help you understand why they make sense.</p>
<p>In any case, with this in hand, it is easy to define the translation from
negation normal form formulas and arbitrary propositional formulas to
CNF.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">NnfForm.toCnfForm</span> <span class="o">:</span> <span class="n">NnfForm</span> <span class="bp">→</span> <span class="n">CnfForm</span>
  <span class="bp">|</span> <span class="n">NnfForm.lit</span> <span class="o">(</span><span class="n">Lit.pos</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">[</span> <span class="o">[</span><span class="n">Lit.pos</span> <span class="n">s</span><span class="o">]</span> <span class="o">]</span>
  <span class="bp">|</span> <span class="n">NnfForm.lit</span> <span class="o">(</span><span class="n">Lit.neg</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">[</span> <span class="o">[</span><span class="n">Lit.neg</span> <span class="n">s</span><span class="o">]</span> <span class="o">]</span>
  <span class="bp">|</span> <span class="n">NnfForm.lit</span> <span class="n">Lit.tr</span>      <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">NnfForm.lit</span> <span class="n">Lit.fls</span>     <span class="bp">=&gt;</span> <span class="o">[</span> <span class="o">[]</span> <span class="o">]</span>
  <span class="bp">|</span> <span class="n">NnfForm.conj</span> <span class="n">A</span> <span class="n">B</span>        <span class="bp">=&gt;</span> <span class="n">A.toCnfForm.conj</span> <span class="n">B.toCnfForm</span>
  <span class="bp">|</span> <span class="n">NnfForm.disj</span> <span class="n">A</span> <span class="n">B</span>        <span class="bp">=&gt;</span> <span class="n">A.toCnfForm.disj</span> <span class="n">B.toCnfForm</span>

<span class="kd">def</span> <span class="n">PropForm.toCnfForm</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">PropForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">CnfForm</span> <span class="o">:=</span> <span class="n">A.toNnfForm.toCnfForm</span>
</pre></div>
</div>
<p>We can try them out:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">propExample.toCnfForm</span>

<span class="k">#eval</span> <span class="n">prop</span><span class="bp">!</span><span class="o">{(</span><span class="n">p1</span> <span class="bp">∧</span> <span class="n">p2</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">q1</span> <span class="bp">∧</span> <span class="n">q2</span><span class="o">)}</span><span class="bp">.</span><span class="n">toCnfForm.toString</span>

<span class="k">#eval</span> <span class="n">prop</span><span class="bp">!</span><span class="o">{(</span><span class="n">p1</span> <span class="bp">∧</span> <span class="n">p2</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">q1</span> <span class="bp">∧</span> <span class="n">q2</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">r1</span> <span class="bp">∧</span> <span class="n">r2</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">s1</span> <span class="bp">∧</span> <span class="n">s2</span><span class="o">)}</span><span class="bp">.</span><span class="n">toCnfForm.toString</span>
</pre></div>
</div>
</div>
<div class="section" id="exercises">
<h2><span class="section-number">5.4. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>Write a Lean function that, given any element of <cite>PropForm</cite>, outputs a
list of all the subformulas.</p></li>
<li><p>Write a Lean function that, given a list of propositional formulas and another
propositional formula, determines whether the second is a logical consequence
of the first.</p></li>
<li><p>Write a Lean function that, given a clause, tests whether any literal <cite>Lit.pos p</cite>
appears together with its negation <cite>Lit.neg p</cite>.
Write another Lean function that, given a formula in conjunctive normal form,
deletes all these clauses.</p></li>
</ol>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="decision_procedures_for_propositional_logic.html" class="btn btn-neutral float-right" title="6. Decision Procedures for Propositional Logic" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="propositional_logic.html" class="btn btn-neutral float-left" title="4. Propositional Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>