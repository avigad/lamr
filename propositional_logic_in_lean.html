<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>9. Propositional Logic in Lean &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10. First-Order Logic" href="first_order_logic.html" />
    <link rel="prev" title="8. Deduction for Propositional Logic" href="deduction_for_propositional_logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Logic and Mechanized Reasoning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="deduction_for_propositional_logic.html">8. Deduction for Propositional Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. Propositional Logic in Lean</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#implication">9.1. Implication</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conjunction">9.2. Conjunction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#disjunction">9.3. Disjunction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#negation">9.4. Negation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#miscellany">9.5. Miscellany</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">9.6. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">11. Implementing First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_first_order_logic.html">12. Decision Procedures for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">13. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="deduction_for_first_order_logic.html">14. Deduction for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">15. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">16. First-Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="beyond_first_order_logic.html">17. Beyond First-Order Logic</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><span class="section-number">9. </span>Propositional Logic in Lean</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/propositional_logic_in_lean.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="propositional-logic-in-lean">
<span id="chapter-propositional-logic-in-lean"></span><h1><span class="section-number">9. </span>Propositional Logic in Lean<a class="headerlink" href="#propositional-logic-in-lean" title="Permalink to this heading"></a></h1>
<p>In <a class="reference internal" href="using_lean_as_a_programming_language.html#chapter-lean-as-a-programming-language"><span class="std std-numref">Chapter 3</span></a>,
we considered the use of Lean as a programming
language, and in <a class="reference internal" href="implementing_propositional_logic.html#chapter-implementing-propositional-logic"><span class="std std-numref">Chapter 5</span></a>
we saw that you can use Lean to define data types for things like propositional formulas
and truth assignments, and thereby implement algorithms that act on these objects.</p>
<p>In this chapter, we will show how to represent propositional formulas directly in
Lean’s underlying foundation. In this sense, we are using Lean’s foundation as an <em>object
language</em> rather than a <em>metalanguage</em> for logic.
To clarify the distinction, imagine implementing one programming language, such as Lisp, in
another programming language, like C++.
In this scenario, we can characterize Lisp as being the object language, that is, the
one that is being implemented, and C++ as the metalanguage, the one that is carrying out
the implementation.
What we did in <a class="reference internal" href="implementing_propositional_logic.html#chapter-implementing-propositional-logic"><span class="std std-numref">Chapter 5</span></a> is similar:
we are used one logical system, Lean, to
implement another one, propositional logic.
One goal of this chapter is to clarify the sense in which Lean itself is a logical system,
which is to say, its language can be used to state mathematical theorems and prove them.
Propositional logic is only a starting point.
In chapters to come we will see that Lean’s logical foundation is powerful and expressive
enough to carry out almost any mathematical argument.</p>
<p>This means that Lean’s logical foundation serves as both a programming language and
a mathematical language. Combining the two brings a number of benefits:</p>
<ul class="simple">
<li><p>It allows us to specify the behavior of computer programs in the same language that we write them.</p></li>
<li><p>It allows us to prove, rigorously, that our computer programs are correct, which is to say,
that they meet their specifications.</p></li>
<li><p>It allows us to enforce preconditions on our programs. For example, we can write functions
whose input is required to be a positive integer, a requirement that is enforced
statically, at compile time. Compiler optimizations can make use of this knowledge.</p></li>
<li><p>It allows us to compute with objects in our mathematical libraries.</p></li>
<li><p>It gives us ways of using computation in mathematical proofs.</p></li>
</ul>
<p>Although we will not discuss it in this course, Lean also serves as its own <em>metaprogramming
language</em>, which means that we can use Lean to develop automation that can help us construct
programs and proofs.
In that way, Lean becomes a self-extending system, meaning that we can
improve its support for programming and theorem proving using the system itself.</p>
<section id="implication">
<span id="section-implication"></span><h2><span class="section-number">9.1. </span>Implication<a class="headerlink" href="#implication" title="Permalink to this heading"></a></h2>
<p>In Lean, we can declare variables that range over propositions, and then
use them to build more complicated propositions.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variable</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">True</span>
<span class="k">#check</span> <span class="n">False</span>
<span class="k">#check</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span>
<span class="k">#check</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span>
<span class="k">#check</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span>
<span class="k">#check</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">q</span>
<span class="k">#check</span> <span class="bp">¬</span> <span class="n">p</span>
</pre></div>
</div>
<p>Hovering over the symbols will give you options for typing them. Using <code class="docutils literal notranslate"><span class="pre">\\and</span></code>, <code class="docutils literal notranslate"><span class="pre">\\or</span></code>, <code class="docutils literal notranslate"><span class="pre">\\to</span></code>,
<code class="docutils literal notranslate"><span class="pre">\\iff</span></code>, and <code class="docutils literal notranslate"><span class="pre">\\not</span></code> will work.</p>
<p>In Lean, if <code class="docutils literal notranslate"><span class="pre">p</span></code> has type <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, then a term <code class="docutils literal notranslate"><span class="pre">t</span></code> of type <code class="docutils literal notranslate"><span class="pre">p</span></code> is a proof of <code class="docutils literal notranslate"><span class="pre">p</span></code>.
Lean’s proof language is essentially the same as its programming language, which means that
we can write proofs the same way we write programs.
Instead of using the identifier <code class="docutils literal notranslate"><span class="pre">def</span></code>, it is conventional to use the word <code class="docutils literal notranslate"><span class="pre">theorem</span></code>
to name the proof of a proposition.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">hp</span> <span class="n">hq</span> <span class="bp">=&gt;</span> <span class="n">And.intro</span> <span class="n">hp</span> <span class="n">hq</span>

<span class="kd">theorem</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="o">⟨</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="n">hq</span><span class="o">,</span> <span class="n">hp</span><span class="o">⟩</span>
</pre></div>
</div>
<p>The expression after the <code class="docutils literal notranslate"><span class="pre">:=</span></code> is sometimes called a <em>proof term</em>.</p>
<p>You can read more about writing proof terms in
<a class="reference external" href="https://leanprover.github.io/theorem_proving_in_lean4/">Theorem Proving in Lean 4</a>.
In this chapter, we will describe an alternative method of writing proofs, using <em>tactics</em>.
A tactic proof is essentially a piece of metacode, a list of instructions that tells
Lean how to construct the proof term. In Lean, we enter tactic mode with the keyword <code class="docutils literal notranslate"><span class="pre">by</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">apply</span> <span class="n">h</span>
</pre></div>
</div>
<p>Here the keyword <code class="docutils literal notranslate"><span class="pre">example</span></code> simply introduces an unnamed theorem (or definition).
The <code class="docutils literal notranslate"><span class="pre">intro</span></code> tactic introduces the hypothesis and names it <code class="docutils literal notranslate"><span class="pre">h</span></code>.
If you put the cursor on that line and check the <code class="docutils literal notranslate"><span class="pre">Lean</span> <span class="pre">infoview</span></code> in the editor,
you will see the current state of the proof, that looks like this:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">p</span>
<span class="bp">⊢</span> <span class="n">p</span>
</pre></div>
</div>
<p>Think of this as a <em>sequent</em>, as described in the last chapter:
it expresses that the current goal is to prove <code class="docutils literal notranslate"><span class="pre">p</span></code>,
using the assumption <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span></code>.
In contrast to the sequent calculus we considered for natural deduction,
here the hypothesis that <code class="docutils literal notranslate"><span class="pre">p</span></code> holds is labeled with the identifier <code class="docutils literal notranslate"><span class="pre">h</span></code>.
You can use any identifier as a label.
Also, in contrast with the sequent calculus for natural deduction,
the variables <code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">r</span></code>, and <code class="docutils literal notranslate"><span class="pre">s</span></code> are included, together with their type.
Later on we will see that other kinds of data, like natural numbers,
can be included as variables in the context.
Notice also that in Lean, hypotheses like <code class="docutils literal notranslate"><span class="pre">α</span> <span class="pre">:</span> <span class="pre">Type</span></code>, <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:</span> <span class="pre">Nat</span></code>, and
<code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span></code> are all possible, so the context can include variables ranging over data types,
propositions, elements of the data types, and proofs (or assumptions) that the propositions hold.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">intro</span></code> tactic implements the implication introduction rule of the natural deduction calculus.
The <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic in the proof applies the hypothesis <code class="docutils literal notranslate"><span class="pre">h</span></code> to solve the goal.
In this case, since <code class="docutils literal notranslate"><span class="pre">h</span></code> solves the goal exactly, we could write <code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">h</span></code> instead.
We could also write <code class="docutils literal notranslate"><span class="pre">assumption</span></code>, which tells Lean to look for any assumption in the
context that solves the goal.
This corresponds to the assumption rule in the natural deduction calculus.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic can also be used to apply an implication.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">apply</span> <span class="n">h1</span>
  <span class="n">exact</span> <span class="n">h2</span>
</pre></div>
</div>
<p>In this example, applying <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">q</span></code> to the goal reduces the task of
proving <code class="docutils literal notranslate"><span class="pre">q</span></code> to the task of proving <code class="docutils literal notranslate"><span class="pre">p</span></code>.
Lean also provides a means of reasoning forward from hypotheses,
using the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">h2</span>
  <span class="n">exact</span> <span class="n">h3</span>
</pre></div>
</div>
<p>Here the first line of the proof states an intermediate goal of proving
<code class="docutils literal notranslate"><span class="pre">q</span></code>, which is achieved by applying <code class="docutils literal notranslate"><span class="pre">h1</span></code> to <code class="docutils literal notranslate"><span class="pre">h2</span></code>.
The result is named <code class="docutils literal notranslate"><span class="pre">h3</span></code>, which we can then use in the next line.
We can leave out the information that <code class="docutils literal notranslate"><span class="pre">h3</span></code> is a proof of <code class="docutils literal notranslate"><span class="pre">q</span></code>,
because Lean can figure that out:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">h2</span>
  <span class="n">exact</span> <span class="n">h3</span>
</pre></div>
</div>
<p>Defining <code class="docutils literal notranslate"><span class="pre">h3</span></code> to be <code class="docutils literal notranslate"><span class="pre">h1</span> <span class="pre">h2</span></code> and then applying it is just the same
as using <code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">h1</span> <span class="pre">h2</span></code> directly to solve the goal, and that, in turn,
amounts to constructing the proof <code class="docutils literal notranslate"><span class="pre">h1</span> <span class="pre">h2</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">exact</span> <span class="n">h1</span> <span class="n">h2</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">h2</span>
</pre></div>
</div>
</section>
<section id="conjunction">
<h2><span class="section-number">9.2. </span>Conjunction<a class="headerlink" href="#conjunction" title="Permalink to this heading"></a></h2>
<p>There is a theorem in the library called <code class="docutils literal notranslate"><span class="pre">And.intro</span></code> that encodes the and-introduction
rule in the natural deduction calculus, telling us that we can prove <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span></code> by proving
each of <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> in turn.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">and_example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hp</span>
  <span class="n">intro</span> <span class="n">hq</span>
  <span class="n">apply</span> <span class="n">And.intro</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">hp</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">hq</span>

<span class="k">#print</span> <span class="n">and_example</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">hp</span> <span class="n">hq</span> <span class="bp">=&gt;</span> <span class="n">And.intro</span> <span class="n">hp</span> <span class="n">hq</span>
</pre></div>
</div>
<p>After applying <code class="docutils literal notranslate"><span class="pre">And.intro</span></code>, the goal is split into two goals, one which requires
us to prove <code class="docutils literal notranslate"><span class="pre">p</span></code>, and the other which requires us to prove <code class="docutils literal notranslate"><span class="pre">q</span></code>.
Each of these is accomplished with the <code class="docutils literal notranslate"><span class="pre">exact</span></code> tactic.
As you step through the proof, you can see the state change.
The periods in each case serve to <em>focus</em> on the next goal, so that only that goal
is visible in that part of the proof.
Strictly speaking, they are not necessary; try deleting them to confirm that the proof
still goes through.
Still, they provide a nice way of making the structure of the proof manifest,
and this, in turn, results in more robust proof scripts.
The <code class="docutils literal notranslate"><span class="pre">#print</span></code> statement shows that the tactics have the effect of constructing a proof term.
The subsequent example provides the proof term explicitly.
In fact, the term makes it clear that introducing <code class="docutils literal notranslate"><span class="pre">hp</span></code> and <code class="docutils literal notranslate"><span class="pre">hq</span></code> and then applying
<code class="docutils literal notranslate"><span class="pre">And.intro</span></code> is an unnecessary detour. The theorem we have proved is exactly <code class="docutils literal notranslate"><span class="pre">And.intro</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">And.intro</span>
</pre></div>
</div>
<p>At this point, there are two tricks that are worth mentioning.
First, at any point in a proof, you can solve the current goal with the <code class="docutils literal notranslate"><span class="pre">admit</span></code> tactic.
You can prove any theorem at all using <code class="docutils literal notranslate"><span class="pre">admit</span></code>.
It’s cheating, and the squiggly line the editor puts underneath the word tells you as much.
But it is often a useful device when writing proofs, because it means you can temporarily
close a goal to work on others, and then come back to it.</p>
<p>The other trick is to use the <code class="docutils literal notranslate"><span class="pre">done</span></code> tactic. The <code class="docutils literal notranslate"><span class="pre">done</span></code> tactic doesn’t do anything;
it just declares that the proof is over.
If the proof isn’t over, Lean gives you an error message, and the error message tells you
exactly the remaining goals.
So this gives you a way to mark the end of a proof in progress, so that you can easily
monitor what is left to be done.</p>
<p>The natural way to <em>use</em> a conjunction <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">∧</span> <span class="pre">q</span></code> in a hypothesis is to split it
to the hypotheses <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">q</span></code>.
This rule is commonly used in sequent calculi.
There are various ways to do it.
One is to use a destructuring <code class="docutils literal notranslate"><span class="pre">have</span></code>:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="k">have</span> <span class="o">⟨</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span>
  <span class="n">apply</span> <span class="n">And.intro</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">hq</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">hp</span>
</pre></div>
</div>
<p>Here the angle brackets are Lean’s <em>anonymous constructor</em> notation.
You can type them with <code class="docutils literal notranslate"><span class="pre">\\&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">\\&gt;</span></code>.
In this case, the <code class="docutils literal notranslate"><span class="pre">have</span></code> command tells Lean to match against
whatever constructor matches the proposition,
in this case, <code class="docutils literal notranslate"><span class="pre">And.intro</span></code>.
Another option is to use the <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic, which matches the cases against the constructor:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">intro</span> <span class="n">hp</span> <span class="n">hq</span> <span class="bp">=&gt;</span>
    <span class="n">exact</span> <span class="n">And.intro</span> <span class="n">hq</span> <span class="n">hp</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">cases</span> <span class="n">h</span>
  <span class="n">case</span> <span class="n">intro</span> <span class="n">hp</span> <span class="n">hq</span> <span class="bp">=&gt;</span>
    <span class="n">exact</span> <span class="n">And.intro</span> <span class="n">hq</span> <span class="n">hp</span>
</pre></div>
</div>
<p>These are two slightly different formulations of the same proof.
Notice that in the second variation we drop the keyword <code class="docutils literal notranslate"><span class="pre">with</span></code>
and use the <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic instead of the vertical bar.</p>
<p>Here are some examples of using the pattern-matching <code class="docutils literal notranslate"><span class="pre">have</span></code> with
the ordinary one.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">h2</span>
  <span class="n">exact</span> <span class="n">h3</span>
</pre></div>
</div>
<p>In the first example, the second <code class="docutils literal notranslate"><span class="pre">have</span></code> claims an auxiliary statement, <code class="docutils literal notranslate"><span class="pre">r</span></code>,
and proves it with the term <code class="docutils literal notranslate"><span class="pre">h2</span> <span class="pre">hq</span></code>.
The third example shows that we can also prove the intermediate claim in tactic mode,
using the keyword <code class="docutils literal notranslate"><span class="pre">by</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">have</span></code> statement is similar to a <code class="docutils literal notranslate"><span class="pre">let</span></code> statement that we have already seen when
we used Lean as a programming language.
In fact, using a <code class="docutils literal notranslate"><span class="pre">let</span></code> also works:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">r</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">let</span> <span class="o">⟨</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h1</span>
  <span class="k">let</span> <span class="n">hr</span> <span class="o">:</span> <span class="n">r</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">apply</span> <span class="n">h2</span>
    <span class="n">exact</span> <span class="n">hq</span>
  <span class="n">exact</span> <span class="n">And.intro</span> <span class="n">hp</span> <span class="n">hr</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">r</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">let</span> <span class="o">⟨</span><span class="n">hp</span><span class="o">,</span> <span class="n">hq</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h1</span>
  <span class="n">exact</span> <span class="n">And.intro</span> <span class="n">hp</span> <span class="o">(</span><span class="n">h2</span> <span class="n">hq</span><span class="o">)</span>
</pre></div>
</div>
<p>With both <code class="docutils literal notranslate"><span class="pre">have</span></code> and <code class="docutils literal notranslate"><span class="pre">let</span></code>, we can take the proofs to
abbreviate the result of substituting the proof of <code class="docutils literal notranslate"><span class="pre">r</span></code> where we used <code class="docutils literal notranslate"><span class="pre">hr</span></code>,
as in the last example above.
There is a subtle difference between <code class="docutils literal notranslate"><span class="pre">have</span></code> and <code class="docutils literal notranslate"><span class="pre">let</span></code>: while the
data in the <code class="docutils literal notranslate"><span class="pre">let</span></code> statement is available in the body of the statement after the <code class="docutils literal notranslate"><span class="pre">let</span></code>,
a <code class="docutils literal notranslate"><span class="pre">have</span></code> only records the existence of an expression of the corresponding type.
When we use a <code class="docutils literal notranslate"><span class="pre">have</span></code>, typically we only care that the corresponding fact has been proved,
and the specifics of the proof are irrelevant. For that reason,
<code class="docutils literal notranslate"><span class="pre">have</span></code> is more appropriate for proofs.</p>
</section>
<section id="disjunction">
<h2><span class="section-number">9.3. </span>Disjunction<a class="headerlink" href="#disjunction" title="Permalink to this heading"></a></h2>
<p>The theorem <code class="docutils literal notranslate"><span class="pre">Or.inr</span></code> in the library corresponds to the
right introduction rule, which proves <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">q</span></code> from <code class="docutils literal notranslate"><span class="pre">p</span></code>.
The left introduction rule is given by <code class="docutils literal notranslate"><span class="pre">Or.inl</span></code>.
We can carry out a proof by cases
using either the theorem <code class="docutils literal notranslate"><span class="pre">Or.elim</span></code> or the <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">apply</span> <span class="n">Or.elim</span> <span class="n">h</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="n">hp</span>
    <span class="n">apply</span> <span class="n">Or.inr</span>
    <span class="n">exact</span> <span class="n">hp</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="n">hq</span>
    <span class="n">apply</span> <span class="n">Or.inl</span>
    <span class="n">exact</span> <span class="n">hq</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">inl</span> <span class="n">hp</span> <span class="bp">=&gt;</span>
    <span class="n">exact</span> <span class="n">Or.inr</span> <span class="n">hp</span>
  <span class="bp">|</span> <span class="n">inr</span> <span class="n">hq</span> <span class="bp">=&gt;</span>
    <span class="n">exact</span> <span class="n">Or.inl</span> <span class="n">hq</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">cases</span> <span class="n">h</span>
  <span class="n">case</span> <span class="n">inl</span> <span class="n">hp</span> <span class="bp">=&gt;</span>
    <span class="n">exact</span> <span class="n">Or.inr</span> <span class="n">hp</span>
  <span class="n">case</span> <span class="n">inr</span> <span class="n">hq</span> <span class="bp">=&gt;</span>
    <span class="n">exact</span> <span class="n">Or.inl</span> <span class="n">hq</span>
</pre></div>
</div>
<p>Notice that in contrast to casing on a conjunction, which results in one new goal and
two new hypotheses,
casing on a disjunction results in two new goals, each with one new hypothesis.</p>
</section>
<section id="negation">
<h2><span class="section-number">9.4. </span>Negation<a class="headerlink" href="#negation" title="Permalink to this heading"></a></h2>
<p>In Lean, <code class="docutils literal notranslate"><span class="pre">¬</span> <span class="pre">p</span></code> is defined to be <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">→</span> <span class="pre">False</span></code>. For most purposes, the two
expressions are interchangeable. This means that you can prove <code class="docutils literal notranslate"><span class="pre">¬</span> <span class="pre">p</span></code>
by assuming <code class="docutils literal notranslate"><span class="pre">p</span></code> and deriving <code class="docutils literal notranslate"><span class="pre">False</span></code>, and if you have <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">hnp</span> <span class="pre">:</span> <span class="pre">¬</span> <span class="pre">p</span></code>,
then the result <code class="docutils literal notranslate"><span class="pre">hnp</span> <span class="pre">hp</span></code> of applying the first to the second is a proof of <code class="docutils literal notranslate"><span class="pre">False</span></code>.
The following illustrates these ideas in action.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">q</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hnq</span> <span class="n">hp</span>
  <span class="n">apply</span> <span class="n">hnq</span>
  <span class="n">apply</span> <span class="n">h</span>
  <span class="n">apply</span> <span class="n">hp</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">hnp</span> <span class="pre">hp</span></code> is equivalent to writing <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">hnp</span></code> followed by <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">hp</span></code>.
Lean provides other means of dealing with negations.
For example, the <code class="docutils literal notranslate"><span class="pre">contradiction</span></code> tactic finishes off a goal whenever the context
contains a statement and its negation.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">contradiction</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">apply</span> <span class="n">Or.elim</span> <span class="n">h1</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="n">hp</span>
    <span class="n">contradiction</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="n">hq</span>
    <span class="n">exact</span> <span class="n">hq</span>
</pre></div>
</div>
<p>In a similar way, the theorem <code class="docutils literal notranslate"><span class="pre">absurd</span></code> shows that anything follows from a statement and
its negation. The first and second examples below are really the same:
writing <code class="docutils literal notranslate"><span class="pre">by</span> <span class="pre">exact</span> <span class="pre">t</span></code> simply constructs the proof <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">exact</span> <span class="n">absurd</span> <span class="n">h1</span> <span class="n">h2</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="n">absurd</span> <span class="n">h1</span> <span class="n">h2</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">apply</span> <span class="n">Or.elim</span> <span class="n">h1</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="n">hp</span>
    <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="n">h2</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="n">hq</span>
    <span class="n">exact</span> <span class="n">hq</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">contradiction</span></code> tactic also works if the context contains <code class="docutils literal notranslate"><span class="pre">False</span></code>.
Alternatively, casing on <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">False</span></code> finishes off a proof.
Intuitively, there are no cases!</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">False</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">contradiction</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">False</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">cases</span> <span class="n">h</span>
</pre></div>
</div>
<p>The principles we have used before all fall within what is known as
<em>intuitionistic</em> logic. Many mathematical arguments require <em>classical</em> logic,
which is embodied in the <em>law of the excluded middle</em>.
In Lean, if <code class="docutils literal notranslate"><span class="pre">p</span></code> is a proposition, <code class="docutils literal notranslate"><span class="pre">em</span> <span class="pre">p</span></code> is the principal <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">∨</span> <span class="pre">¬</span> <span class="pre">p</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">apply</span> <span class="n">Or.elim</span> <span class="o">(</span><span class="n">Classical.em</span> <span class="n">p</span><span class="o">)</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="n">hp</span>
    <span class="n">apply</span> <span class="n">Or.inr</span>
    <span class="n">apply</span> <span class="n">h1</span>
    <span class="n">exact</span> <span class="n">hp</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="n">hnp</span>
    <span class="n">apply</span> <span class="n">Or.inl</span>
    <span class="n">exact</span> <span class="n">hnp</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">¬</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hnnp</span>
  <span class="n">apply</span> <span class="n">Or.elim</span> <span class="o">(</span><span class="n">Classical.em</span> <span class="n">p</span><span class="o">)</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="n">hp</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">hp</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="n">hnp</span>
    <span class="n">contradiction</span>
</pre></div>
</div>
<p>The following illustrate two other formulations of classical logic,
allowing proof by cases and proof by contradiction.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">¬</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hnnp</span>
  <span class="n">apply</span> <span class="n">Classical.byCases</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span>
    <span class="n">exact</span> <span class="n">hp</span>
  <span class="bp">.</span> <span class="n">intro</span> <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span>
    <span class="n">exact</span> <span class="n">absurd</span> <span class="n">hnp</span> <span class="n">hnnp</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">¬</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hnnp</span>
  <span class="n">apply</span> <span class="n">Classical.byContradiction</span>
  <span class="n">intro</span> <span class="o">(</span><span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span>
  <span class="n">exact</span> <span class="n">hnnp</span> <span class="n">hnp</span>
</pre></div>
</div>
</section>
<section id="miscellany">
<h2><span class="section-number">9.5. </span>Miscellany<a class="headerlink" href="#miscellany" title="Permalink to this heading"></a></h2>
<p>The rules for bi-implication are illustrated by the next two examples.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="o">⟨</span><span class="n">h3</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h1</span>
  <span class="n">apply</span> <span class="n">h3</span>
  <span class="n">exact</span> <span class="n">h2</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">↔</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="o">⟨</span><span class="n">h2</span><span class="o">,</span> <span class="n">h3</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h1</span>
  <span class="n">apply</span> <span class="n">Iff.intro</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">h3</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">h2</span>
</pre></div>
</div>
<p>It is worth keeping in mind that tactics serve to construct proof terms,
and that you can often be more concise by writing the proof terms yourself,
as in the following examples.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">p</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">Or.elim</span> <span class="n">h</span> <span class="o">(</span><span class="k">fun</span> <span class="n">hp</span> <span class="bp">=&gt;</span> <span class="n">Or.inr</span> <span class="n">hp</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">hq</span> <span class="bp">=&gt;</span> <span class="n">Or.inl</span> <span class="n">hq</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">q</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">p</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">hnq</span> <span class="n">hp</span> <span class="bp">=&gt;</span> <span class="n">hnq</span> <span class="o">(</span><span class="n">h1</span> <span class="n">hp</span><span class="o">)</span>
</pre></div>
</div>
<p>You should think about these examples and how they work.
One strategy for learning how to write proof terms is to name
the theorems that you prove with tactics, and then use the <code class="docutils literal notranslate"><span class="pre">#print</span></code>
command to print them out.</p>
</section>
<section id="exercises">
<h2><span class="section-number">9.6. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading"></a></h2>
<p>Complete the following proofs in Lean.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">Init</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">))</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">))</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">))</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="c1">-- this one requires classical logic!</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">))</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>

<span class="c1">-- this one too</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">admit</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="deduction_for_propositional_logic.html" class="btn btn-neutral float-left" title="8. Deduction for Propositional Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="first_order_logic.html" class="btn btn-neutral float-right" title="10. First-Order Logic" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>