<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6. Decision Procedures for Propositional Logic &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=0731ccc3" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=2709fde1"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script>window.MathJax = {"loader": {"load": ["[tex]/bussproofs"]}, "tex": {"packages": {"[+]": ["bussproofs"]}, "macros": {"fn": ["\\mathit{#1}", 1], "fa": ["\\forall #1. \\,", 1], "ex": ["\\exists #1. \\,", 1], "bN": "{\\mathbb{N}}", "bZ": "{\\mathbb{Z}}", "bR": "{\\mathbb{R}}", "limplies": "\\to", "liff": "\\leftrightarrow", "proves": "\\vdash", "append": "\\mathbin{+\\mkern-10mu+}", "tval": ["[\\![#1]\\!]", 1], "fCenter": "\\proves", "mdl": ["\\mathfrak{#1}", 1]}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. Using SAT Solvers" href="using_sat_solvers.html" />
    <link rel="prev" title="5. Implementing Propositional Logic" href="implementing_propositional_logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Logic and Mechanized Reasoning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. Decision Procedures for Propositional Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-tseitin-transformation">6.1. The Tseitin transformation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unit-propagation-and-the-pure-literal-rule">6.2. Unit propagation and the pure literal rule</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dpll">6.3. DPLL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#autarkies-and-2-sat">6.4. Autarkies and 2-SAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cdcl">6.5. CDCL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">6.6. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_propositional_logic.html">8. Proof Systems for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_proof_assistant.html">9. Using Lean as a Proof Assistant</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">11. Implementing First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_first_order_logic.html">12. Decision Procedures for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">13. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_first_order_logic.html">14. Proof Systems for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">15. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="beyond_first_order_logic.html">16. Beyond First-Order Logic</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">6. </span>Decision Procedures for Propositional Logic</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/decision_procedures_for_propositional_logic.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="decision-procedures-for-propositional-logic">
<span id="chapter-decision-procedures-for-propositional-logic"></span><h1><span class="section-number">6. </span>Decision Procedures for Propositional Logic<a class="headerlink" href="#decision-procedures-for-propositional-logic" title="Link to this heading"></a></h1>
<p>We have seen that it is possible to determine whether or not a propositional formula is valid
by writing out its entire truth table.
This seems pretty inefficient; if a formula <span class="math notranslate nohighlight">\(A\)</span> has <span class="math notranslate nohighlight">\(n\)</span> variables,
the truth table has <span class="math notranslate nohighlight">\(2^n\)</span> lines, and hence checking it requires at least that many lines.
It is still an open question, however, whether one can do substantially better.
If <span class="math notranslate nohighlight">\(P \ne NP\)</span>, there is no polynomial algorithm to determine satisfiability (and hence
validity).</p>
<p>Nonetheless, there are procedures that seem to work better in practice.
In fact, we can generally do <em>much</em> better in practice.
In the next chapter, we will discuss <em>SAT solvers</em>, which are pieces of software that are
are remarkably good at determining whether a propositional formula has a satisfying assignment.</p>
<p>Before 1990, most solvers allowed arbitrary propositional formulas as input.
Most contemporary SAT solvers, however, are designed to determine the satisfiability of formulas in
conjunctive normal form.
<a class="reference internal" href="propositional_logic.html#section-normal-forms"><span class="std std-numref">Section 4.5</span></a> shows that, in principle, this does not sacrifice generality,
because any propositional formula <span class="math notranslate nohighlight">\(A\)</span> can be transformed to
an equivalent CNF formula <span class="math notranslate nohighlight">\(B\)</span>.
The problem is that, in general, however, the smallest such <span class="math notranslate nohighlight">\(B\)</span> may be
exponentially longer than <span class="math notranslate nohighlight">\(A\)</span>,
which makes the transformation impractical.
(See the exercises at the end of <a class="reference internal" href="propositional_logic.html#chapter-propositional-logic"><span class="std std-numref">Chapter 4</span></a>.)
In the next section, we will show you an efficient method for associating
a list of clauses to <span class="math notranslate nohighlight">\(A\)</span> with the property that <span class="math notranslate nohighlight">\(A\)</span>
is satisfiable if and only if the list of clauses is.
With this transformation, solvers can be used to test the
satisfiability of any propositional formula.</p>
<p>It’s easy to get confused. Remember that most formulas are neither
valid nor unsatisfiable.
In other words, most formulas are true for some
assignments and false for others. So testing for validity and
testing for satisfiability are two different things, and
it is important to keep the distinction clear.
But there is an important relationship between the two notions:
a formula <span class="math notranslate nohighlight">\(A\)</span> is valid if and only if <span class="math notranslate nohighlight">\(\lnot A\)</span>
is unsatisfiable.
This provides a recipe for determining the validity of <span class="math notranslate nohighlight">\(A\)</span>,
namely, use a SAT solver to determine whether <span class="math notranslate nohighlight">\(\lnot A\)</span>
is satisfiable, and then change a “yes” answer to a “no” and vice-versa.</p>
<section id="the-tseitin-transformation">
<span id="section-the-tseitin-transformation"></span><h2><span class="section-number">6.1. </span>The Tseitin transformation<a class="headerlink" href="#the-tseitin-transformation" title="Link to this heading"></a></h2>
<p>We have seen that if <span class="math notranslate nohighlight">\(A\)</span> is a propositional formula, the smallest CNF equivalent
may be exponentially longer.
The Tseitin transformation provides an elegant workaround:
instead of looking for an <em>equivalent</em> formula <span class="math notranslate nohighlight">\(B\)</span>, we look for one
that is <em>equisatisfiable</em>, which is to say, one that is satisfiable if and only if <span class="math notranslate nohighlight">\(A\)</span> is.
For example, instead of distributing <span class="math notranslate nohighlight">\(p\)</span> across the conjunction in
<span class="math notranslate nohighlight">\(p \lor (q \land r)\)</span>,
we can introduce a new definition <span class="math notranslate nohighlight">\(d\)</span> for <span class="math notranslate nohighlight">\(q \land r\)</span>.
We can express the equivalence <span class="math notranslate nohighlight">\(d \liff (q \land r)\)</span> in conjunctive normal form as</p>
<div class="math notranslate nohighlight">
\[(\lnot d \lor q) \land (\lnot d \lor r) \land (\lnot q \lor \lnot r \lor d).\]</div>
<p>Assuming that equivalence holds, the original formula <span class="math notranslate nohighlight">\(p \lor (q \land r)\)</span> is
equivalent to <span class="math notranslate nohighlight">\(p \lor d\)</span>, which we can add to the conjunction above,
to yield a CNF formula.</p>
<p>The resulting CNF formula implies <span class="math notranslate nohighlight">\(p \lor (q \land r)\)</span>, but not the other way
around: <span class="math notranslate nohighlight">\(p \lor (q \land r)\)</span> does not imply <span class="math notranslate nohighlight">\(d \liff (q \land r)\)</span>.
But the resulting formulas is equisatisfiable with the original one:
given any truth assignment to the original one,
we can give <span class="math notranslate nohighlight">\(d\)</span> the truth value of <span class="math notranslate nohighlight">\(q \land r\)</span>, and, conversely,
for any truth assignment satisfying the resulting CNF formula, <span class="math notranslate nohighlight">\(d\)</span> <em>has</em> to have that value.
So determining whether or not the resulting CNF formula is satisfiable is tantamount to determining
whether the original one is.
This may seem to be a roundabout translation, but the point is that the number
of definitions is bounded by the length of the original formula
and the size of the CNF representation of each definition is bounded by a constant.
So the length of the resulting formula is linear in the length of the original one.</p>
<p>The following code, found in the <code class="docutils literal notranslate"><span class="pre">LAMR</span></code> library in the <code class="docutils literal notranslate"><span class="pre">NnfForm</span></code> namespace,
runs through a formula in
negation normal form and produces a list of definitions <code class="docutils literal notranslate"><span class="pre">def_0</span></code>, <code class="docutils literal notranslate"><span class="pre">def_1</span></code>, <code class="docutils literal notranslate"><span class="pre">def_2</span></code>, and so on,
each of which represents a conjunction or disjunction of
two variables.
We assume that none these <code class="docutils literal notranslate"><span class="pre">def</span></code> variables are found in the original formula.
(A more sophisticated implementation would check the original formula and start the
numbering high enough to avoid a clash.)</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">defLit</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Lit.pos</span> <span class="n">s</span><span class="bp">!</span><span class="s2">&quot;def_{n}&quot;</span>

<span class="kd">def</span> <span class="n">mkDefs</span> <span class="o">:</span> <span class="n">NnfForm</span> <span class="bp">→</span> <span class="n">Array</span> <span class="n">NnfForm</span> <span class="bp">→</span> <span class="n">Lit</span> <span class="bp">×</span> <span class="n">Array</span> <span class="n">NnfForm</span>
  <span class="bp">|</span> <span class="n">lit</span> <span class="n">l</span><span class="o">,</span> <span class="n">defs</span>    <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">defs</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">defs</span> <span class="bp">=&gt;</span>
      <span class="k">let</span> <span class="o">⟨</span><span class="n">fA</span><span class="o">,</span> <span class="n">defs1</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mkDefs</span> <span class="n">A</span> <span class="n">defs</span>
      <span class="k">let</span> <span class="o">⟨</span><span class="n">fB</span><span class="o">,</span> <span class="n">defs2</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mkDefs</span> <span class="n">B</span> <span class="n">defs1</span>
      <span class="n">add_def</span> <span class="n">conj</span> <span class="o">(</span><span class="n">lit</span> <span class="n">fA</span><span class="o">)</span> <span class="o">(</span><span class="n">lit</span> <span class="n">fB</span><span class="o">)</span> <span class="n">defs2</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">defs</span> <span class="bp">=&gt;</span>
      <span class="k">let</span> <span class="o">⟨</span><span class="n">fA</span><span class="o">,</span> <span class="n">defs1</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mkDefs</span> <span class="n">A</span> <span class="n">defs</span>
      <span class="k">let</span> <span class="o">⟨</span><span class="n">fB</span><span class="o">,</span> <span class="n">defs2</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">mkDefs</span> <span class="n">B</span> <span class="n">defs1</span>
      <span class="n">add_def</span> <span class="n">disj</span> <span class="o">(</span><span class="n">lit</span> <span class="n">fA</span><span class="o">)</span> <span class="o">(</span><span class="n">lit</span> <span class="n">fB</span><span class="o">)</span> <span class="n">defs2</span>
<span class="n">where</span>
  <span class="n">add_def</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">NnfForm</span> <span class="bp">→</span> <span class="n">NnfForm</span> <span class="bp">→</span> <span class="n">NnfForm</span><span class="o">)</span> <span class="o">(</span><span class="n">fA</span> <span class="n">fB</span> <span class="o">:</span> <span class="n">NnfForm</span><span class="o">)</span> <span class="o">(</span><span class="n">defs</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">NnfForm</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">defs.findIdx</span><span class="bp">?</span> <span class="o">((</span><span class="bp">.</span> <span class="bp">==</span> <span class="n">op</span> <span class="n">fA</span> <span class="n">fB</span><span class="o">))</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">defLit</span> <span class="n">n</span><span class="o">,</span> <span class="n">defs</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">none</span>   <span class="bp">=&gt;</span> <span class="k">let</span> <span class="n">newdefs</span> <span class="o">:=</span> <span class="n">defs.push</span> <span class="o">(</span><span class="n">op</span> <span class="n">fA</span> <span class="n">fB</span><span class="o">)</span>
                <span class="o">(</span><span class="n">defLit</span> <span class="o">(</span><span class="n">newdefs.size</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">),</span> <span class="n">newdefs</span><span class="o">)</span>
</pre></div>
</div>
<p>The keyword <code class="docutils literal notranslate"><span class="pre">where</span></code> is used to define an auxiliary function that is not
meant to be used anywhere else.
The function <code class="docutils literal notranslate"><span class="pre">mkDefs</span></code> takes an NNF formula and a list of definitions,
and it returns an augmented list of definitions and a literal
representing the original formula.
More precisely, the list <code class="docutils literal notranslate"><span class="pre">defs</span></code> is an array of disjunctions and conjunctions
of variables,
where the first one corresponds to <code class="docutils literal notranslate"><span class="pre">def_0</span></code>, the next one corresponds to <code class="docutils literal notranslate"><span class="pre">def_1</span></code>,
and so on.
In the cases where the original formula is a conjunction or a disjunction,
the function first recursively creates definitions for the
component formulas and then adds a new definition for the original formula.
The auxiliary function <code class="docutils literal notranslate"><span class="pre">add_def</span></code> first checks to see whether
the formula to be added is already found in the array.
For example, when passed a conjunction <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">∧</span> <span class="pre">def_0</span></code>,
if that formula is already in the list of definitions in position 7,
<code class="docutils literal notranslate"><span class="pre">add_def</span></code> returns <code class="docutils literal notranslate"><span class="pre">def_7</span></code> as the definition of the formula and leaves the array
unchanged.</p>
<p>To illustrate, we start by putting the formula</p>
<div class="math notranslate nohighlight">
\[\lnot (p \land q \liff r) \land (s \limplies p \land t)\]</div>
<p>in negation normal form.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">ex1</span> <span class="o">:=</span> <span class="n">prop</span><span class="bp">!</span><span class="o">{</span><span class="bp">¬</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">↔</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">s</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">t</span><span class="o">)}</span><span class="bp">.</span><span class="n">toNnfForm</span>

<span class="k">#eval</span> <span class="n">toString</span> <span class="n">ex1</span>
</pre></div>
</div>
<p>Removing extraneous parentheses, we get</p>
<div class="math notranslate nohighlight">
\[((p \land q \land \lnot r) \lor (r \land (\lnot p \lor \lnot q)) \land
(\lnot s \lor (p \land t)).\]</div>
<p>In the following, we compute the list of definitions corresponding
to <code class="docutils literal notranslate"><span class="pre">ex1</span></code>, and then we use a little program to print them out in a more
pleasant form.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span>  <span class="n">ex1.mkDefs</span> <span class="bp">#</span><span class="o">[]</span>

<span class="kd">def</span> <span class="n">printDefs</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">NnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="o">⟨</span><span class="n">fm</span><span class="o">,</span> <span class="n">defs</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">A.mkDefs</span> <span class="bp">#</span><span class="o">[]</span>
  <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">&quot;{fm}, where&quot;</span>
  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[:</span><span class="n">defs.size</span><span class="o">]</span> <span class="k">do</span>
    <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">&quot;def_{i} := {defs[i]!}&quot;</span>

<span class="k">#eval</span> <span class="n">printDefs</span> <span class="n">ex1</span>

<span class="c">/-</span>
<span class="cm">output:</span>

<span class="cm">def_7, where</span>
<span class="cm">def_0 := (p ∧ q)</span>
<span class="cm">def_1 := (def_0 ∧ (¬ r))</span>
<span class="cm">def_2 := ((¬ p) ∨ (¬ q))</span>
<span class="cm">def_3 := (r ∧ def_2)</span>
<span class="cm">def_4 := (def_1 ∨ def_3)</span>
<span class="cm">def_5 := (p ∧ t)</span>
<span class="cm">def_6 := ((¬ s) ∨ def_5)</span>
<span class="cm">def_7 := (def_4 ∧ def_6)</span>
<span class="cm">-/</span>
</pre></div>
</div>
<p>We can obtain an equisatisfiable version of the formula by putting
all the definitions into conjunctive normal form, collecting them all
together, and adding one more conjunct with the variable <code class="docutils literal notranslate"><span class="pre">d</span></code> corresponding
to the definition of the top level formula. There is a constant bound
on the size of each CNF definition, which corresponds to a single conjunction
or disjunction. (This would still be true if we added other binary connectives,
like a bi-implication.) Since the number of definitions is linear in the
size of the original formula, the size of the equisatisfiable CNF formula
is linear in the original one.</p>
<p>There is an important optimization of the Tseitin transformation due to
Plaisted and Greenbaum, who observed that for equisatisfiability,
only one direction of the implication is needed for each subformula.
If we start with a formula in negation normal form,
each subformula occurs <em>positively</em>, which means that switching its truth
value from negative to positive can only change the truth value of the entire
formula in the same direction. In that case, only the forward direction
of the implication is needed. For example, the formula <span class="math notranslate nohighlight">\((p \land q) \lor r\)</span>
is equisatisfiable with <span class="math notranslate nohighlight">\((d \lor r) \land (d \to p \land q)\)</span>, which
can be expressed in CNF as <span class="math notranslate nohighlight">\((d \lor r) \land (\lnot d \lor p) \land (\lnot d \lor q)\)</span>.
To see that they are equisatisfiable, notice that any satisfying assignment to
<span class="math notranslate nohighlight">\((p \land q) \lor r\)</span> can be extended to a satisfying assignment of
<span class="math notranslate nohighlight">\((d \lor r) \land (d \limplies p \land q)\)</span> by giving <span class="math notranslate nohighlight">\(d\)</span> the same truth assignment
as <span class="math notranslate nohighlight">\(p \land q\)</span>, and, conversely, <span class="math notranslate nohighlight">\((d \lor r) \land (d \limplies p \land q)\)</span>
entails <span class="math notranslate nohighlight">\((p \land q) \lor r\)</span>.</p>
<p>It isn’t hard to put a implication of the form <span class="math notranslate nohighlight">\((A \limplies B)\)</span> into
conjunctive normal form. The LAMR library defines a function to do that,
and another one that turns the entire list of definitions returned by
<code class="docutils literal notranslate"><span class="pre">mkDefs</span></code> into a single CNF formula.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">implToCnf</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">NnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">CnfForm</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">disj</span> <span class="n">A.neg</span> <span class="n">B</span><span class="o">)</span><span class="bp">.</span><span class="n">toCnfForm</span>

<span class="kd">def</span> <span class="n">defsImplToCnf</span> <span class="o">(</span><span class="n">defs</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">NnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">CnfForm</span> <span class="o">:=</span> <span class="n">aux</span> <span class="n">defs.toList</span> <span class="mi">0</span>
  <span class="n">where</span> <span class="n">aux</span> <span class="o">:</span> <span class="n">List</span> <span class="n">NnfForm</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">CnfForm</span>
  <span class="bp">|</span> <span class="o">[],</span>          <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">nnf</span> <span class="o">::</span> <span class="n">nnfs</span><span class="o">,</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">implToCnf</span> <span class="o">(</span><span class="n">lit</span> <span class="o">(</span><span class="n">defLit</span> <span class="n">n</span><span class="o">))</span> <span class="n">nnf</span> <span class="bp">++</span> <span class="n">aux</span> <span class="n">nnfs</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
<p>If we take the resulting formula and add a conjunct for the
variable representing the top level, we have an equisatisfiable CNF formula,
as desired.</p>
<p>A moment’s reflection shows that we can do better. For example, if
the formula <span class="math notranslate nohighlight">\(A\)</span> is already in CNF, we don’t have to introduce
any definitions at all. The following functions from the library
do their best to interpret an NNF formula as a CNF formula,
introducing definitions only when necessary. The first function,
<code class="docutils literal notranslate"><span class="pre">NnfForm.orToCnf</span></code>, interprets a formula as a clause.
For example, given the formula <span class="math notranslate nohighlight">\(p \lor (q \land \lnot r) \lor \lnot s\)</span>
and a list of definitions, it adds a definition <span class="math notranslate nohighlight">\(d\)</span> for <span class="math notranslate nohighlight">\(q \land \lnot r\)</span> and
returns the clause <span class="math notranslate nohighlight">\(p \lor d \lor \lnot s\)</span>.
The function <code class="docutils literal notranslate"><span class="pre">NnfForm.andToCnf</span></code> does the analogous thing for conjunctions,
and the function <code class="docutils literal notranslate"><span class="pre">NnfForm.toCnf</span></code> puts it all together.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">orToCnf</span> <span class="o">:</span> <span class="n">NnfForm</span> <span class="bp">→</span> <span class="n">Clause</span> <span class="bp">→</span> <span class="n">Array</span> <span class="n">NnfForm</span> <span class="bp">→</span> <span class="n">Clause</span> <span class="bp">×</span> <span class="n">Array</span> <span class="n">NnfForm</span>
  <span class="bp">|</span> <span class="n">lit</span> <span class="n">Lit.tr</span><span class="o">,</span>  <span class="n">cls</span><span class="o">,</span> <span class="n">defs</span>  <span class="bp">=&gt;</span> <span class="o">([</span><span class="n">Lit.tr</span><span class="o">],</span> <span class="n">defs</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">lit</span> <span class="n">Lit.fls</span><span class="o">,</span> <span class="n">cls</span><span class="o">,</span> <span class="n">defs</span>  <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="n">defs</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">lit</span> <span class="n">l</span><span class="o">,</span> <span class="n">cls</span><span class="o">,</span> <span class="n">defs</span>        <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">l</span> <span class="o">::</span> <span class="n">cls</span><span class="o">,</span> <span class="n">defs</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">cls</span><span class="o">,</span> <span class="n">defs</span> <span class="bp">=&gt;</span>
      <span class="k">let</span> <span class="o">⟨</span><span class="n">cls1</span><span class="o">,</span> <span class="n">defs1</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">orToCnf</span> <span class="n">A</span> <span class="n">cls</span> <span class="n">defs</span>
      <span class="k">let</span> <span class="o">⟨</span><span class="n">cls2</span><span class="o">,</span> <span class="n">defs2</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">orToCnf</span> <span class="n">B</span> <span class="n">cls1</span> <span class="n">defs1</span>
      <span class="o">(</span><span class="n">cls1.union&#39;</span> <span class="n">cls2</span><span class="o">,</span> <span class="n">defs2</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">A</span><span class="o">,</span> <span class="n">cls</span><span class="o">,</span> <span class="n">defs</span> <span class="bp">=&gt;</span>
      <span class="k">let</span> <span class="o">⟨</span><span class="n">l</span><span class="o">,</span> <span class="n">defs1</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">A.mkDefs</span> <span class="n">defs</span>
      <span class="o">(</span><span class="n">l</span><span class="o">::</span><span class="n">cls</span><span class="o">,</span> <span class="n">defs1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">andToCnf</span> <span class="o">:</span> <span class="n">NnfForm</span> <span class="bp">→</span> <span class="n">Array</span> <span class="n">NnfForm</span> <span class="bp">→</span> <span class="n">CnfForm</span> <span class="bp">×</span> <span class="n">Array</span> <span class="n">NnfForm</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">defs</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="o">⟨</span><span class="n">fA</span><span class="o">,</span> <span class="n">defs1</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">andToCnf</span> <span class="n">A</span> <span class="n">defs</span>
    <span class="k">let</span> <span class="o">⟨</span><span class="n">fB</span><span class="o">,</span> <span class="n">defs2</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">andToCnf</span> <span class="n">B</span> <span class="n">defs1</span>
    <span class="o">(</span><span class="n">fA.union&#39;</span> <span class="n">fB</span><span class="o">,</span> <span class="n">defs2</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">A</span><span class="o">,</span> <span class="n">defs</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="o">⟨</span><span class="n">cls</span><span class="o">,</span> <span class="n">defs1</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">orToCnf</span> <span class="n">A</span> <span class="o">[]</span> <span class="n">defs</span>
    <span class="o">([</span><span class="n">cls</span><span class="o">],</span> <span class="n">defs1</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">toCnf</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">NnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">CnfForm</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="o">⟨</span><span class="n">cnf</span><span class="o">,</span> <span class="n">defs</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">andToCnf</span> <span class="n">A</span> <span class="bp">#</span><span class="o">[]</span>
  <span class="n">cnf.union&#39;</span> <span class="o">(</span><span class="n">defsImplToCnf</span> <span class="n">defs</span><span class="o">)</span>
</pre></div>
</div>
<p>The following example tests it out on <code class="docutils literal notranslate"><span class="pre">ex1.toCnf</span></code>.
The comment afterward shows the resulting CNF formula
and then reconstructs the definitions to show that the result is equivalent
to the original formula.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">toString</span> <span class="n">ex1.toCnf</span>

<span class="c">/-</span>
<span class="cm">Here is ex1:</span>

<span class="cm">((p ∧ q ∧ ¬ r) ∨ (r ∧ (¬ p ∨ ¬ q)) ∧ (¬ s ∨ (p ∧ t))</span>

<span class="cm">Here is the CNF formula:</span>

<span class="cm">def_3 def_1,</span>
<span class="cm">def_4 -s,</span>
<span class="cm">-def_0 p,</span>
<span class="cm">-def_0 q,</span>
<span class="cm">-def_1 def_0,</span>
<span class="cm">-def_1 -r,</span>
<span class="cm">-def_2 -p -q,</span>
<span class="cm">-def_3 r,</span>
<span class="cm">-def_3 def_2,</span>
<span class="cm">-r -def_2 def_3,</span>
<span class="cm">-def_4 p,</span>
<span class="cm">-def_4 t,</span>

<span class="cm">Here we check to make sure it works:</span>

<span class="cm">def_0 := p ∧ q</span>
<span class="cm">def_1 := p ∧ q ∧ ¬ r</span>
<span class="cm">def_2 := ¬ p ∨ ¬ q</span>
<span class="cm">def_3 := r ∧ (¬ p ∨ ¬ q)</span>
<span class="cm">def_4 := p ∧ t</span>

<span class="cm">def_3 def_1 := (p ∧ q ∧ ¬ r) ∨ (p ∧ q ∧ ¬ r)</span>
<span class="cm">def_4 -s    := ¬ s ∨ (p ∧ t)</span>

<span class="cm">Each &#39;:=&#39; is really an implication.</span>
<span class="cm">-/</span>
</pre></div>
</div>
<p>There is one additional optimization that we have not implemented in the library:
we can be more efficient with iterated conjunctions and disjunctions.
For example, you can check that <span class="math notranslate nohighlight">\(d \limplies \ell_1 \land \cdots \land \ell_n\)</span>
can be represented by the conjunction of the clauses <span class="math notranslate nohighlight">\(\lnot d \lor \ell_1\)</span> to
<span class="math notranslate nohighlight">\(\lnot d \lor \ell_n\)</span>, and <span class="math notranslate nohighlight">\(d \limplies \ell_1 \lor \cdots \lor \ell_n\)</span>
can be represented by the single clause <span class="math notranslate nohighlight">\(\lnot d \lor \ell_1 \lor \cdots \lor \ell_n\)</span>.</p>
</section>
<section id="unit-propagation-and-the-pure-literal-rule">
<span id="section-unit-propagation-and-the-pure-literal-rule"></span><h2><span class="section-number">6.2. </span>Unit propagation and the pure literal rule<a class="headerlink" href="#unit-propagation-and-the-pure-literal-rule" title="Link to this heading"></a></h2>
<p>In earlier chapters, we considered only truth assignments that assign a truth value to all propositional
variables. However, complete search methods for SAT like DPLL use <em>partial assignments</em>, which assign truth
values to some subset of the variables. For a clause <span class="math notranslate nohighlight">\(C\)</span> and partial truth assignment <span class="math notranslate nohighlight">\(\tau\)</span>,
we denote by <span class="math notranslate nohighlight">\(\tval{C}_\tau\)</span> the reduced clause constructed by removing falsified literals. If
<span class="math notranslate nohighlight">\(\tau\)</span> satisfies a literal in <span class="math notranslate nohighlight">\(C\)</span>, we interpret <span class="math notranslate nohighlight">\(\tval{C}_\tau\)</span> as the
singleton clause consisting of <span class="math notranslate nohighlight">\(\top\)</span>,
while if <span class="math notranslate nohighlight">\(\tau\)</span> falsifies all literals in <span class="math notranslate nohighlight">\(C\)</span>, then <span class="math notranslate nohighlight">\(\tval{C}_\tau\)</span> is the empty clause, which we take to represent <span class="math notranslate nohighlight">\(\bot\)</span>. For a CNF formula <span class="math notranslate nohighlight">\(\Gamma\)</span>,
we denote by <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span> the conjunction of <span class="math notranslate nohighlight">\(\tval{C}_\tau\)</span> with <span class="math notranslate nohighlight">\(C \in \Gamma\)</span>,
where we throw away the clauses <span class="math notranslate nohighlight">\(C\)</span> such that <span class="math notranslate nohighlight">\(\tval{C}_\tau\)</span> is <span class="math notranslate nohighlight">\(\top\)</span>.
Remember that if <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span> is an empty conjunction,
we interpret it as being true. In other words, we identify the empty conjunction with <span class="math notranslate nohighlight">\(\top\)</span>.
On the other hand, if <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span> contains an empty clause, then <span class="math notranslate nohighlight">\(\tval{\Gamma}\)</span>
is equivalent to <span class="math notranslate nohighlight">\(\bot\)</span>.</p>
<p>Notice that we are reusing the notation <span class="math notranslate nohighlight">\(\tval{A}_\tau\)</span> that we introduced
in <a class="reference internal" href="propositional_logic.html#section-semantics-propositional-logic"><span class="std std-numref">Section 4.2</span></a> to describe the evaluation of a formula <span class="math notranslate nohighlight">\(A\)</span> under a truth assignment <span class="math notranslate nohighlight">\(\tau\)</span>.
This is an abuse of notation, because in that section we were interpreting <span class="math notranslate nohighlight">\(\tval{A}_\tau\)</span>
as a <em>truth value</em>, whereas now we are taking <span class="math notranslate nohighlight">\(\tval{C}_\tau\)</span> to be a <em>clause</em>
and we are taking <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span> to be <em>CNF formula</em>.
But the abuse is harmless, and, indeed, quite helpful.
Notice that if <span class="math notranslate nohighlight">\(\tau\)</span> is a partial truth assignment that assigns values to
all the variables in a clause <span class="math notranslate nohighlight">\(C\)</span>, then <span class="math notranslate nohighlight">\(\tval{C}_\tau\)</span> evaluates to either the empty
clause or <span class="math notranslate nohighlight">\(\top\)</span>,
and if <span class="math notranslate nohighlight">\(\tau\)</span> is a partial truth assignment that assigns values to
all the variables in a CNF formula <span class="math notranslate nohighlight">\(\Gamma\)</span>,
then <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span> evaluates to either the empty CNF formula, <span class="math notranslate nohighlight">\(\top\)</span>,
or the singleton conjunction of the empty clause, which is our CNF representation of <span class="math notranslate nohighlight">\(\bot\)</span>.
In that sense, the notation we are using in this chapter is a generalization of the
notation we used to describe the semantics of propositional logic.</p>
<p>Remember also that if <span class="math notranslate nohighlight">\(\tau\)</span> is a truth assignment in the sense of <a class="reference internal" href="propositional_logic.html#section-semantics-propositional-logic"><span class="std std-numref">Section 4.2</span></a>,
the semantic evaluation <span class="math notranslate nohighlight">\(\tval{A}_\tau\)</span> only depends on the values of <span class="math notranslate nohighlight">\(\tau\)</span>
that are assigned to variables that occur in <span class="math notranslate nohighlight">\(\tval{A}\)</span>.
In this chapter, when we say “truth assignment,” we will generally mean “partial truth assignment,”
and the analogous fact holds: the values of <span class="math notranslate nohighlight">\(\tval{C}_\tau\)</span> and <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span>
depend only on the variables found in <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(\Gamma\)</span>, respectively.
In particular, if <span class="math notranslate nohighlight">\(\tau\)</span> is a satisfying assignment for <span class="math notranslate nohighlight">\(C\)</span>,
we can assume without loss of generality that <span class="math notranslate nohighlight">\(\tau\)</span> assigns values only to the variables
that occur in <span class="math notranslate nohighlight">\(C\)</span>, and similarly for <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<p>A key SAT-solving technique is <em>unit propagation</em>. Given a CNF formula <span class="math notranslate nohighlight">\(\Gamma\)</span> and a truth assignment
<span class="math notranslate nohighlight">\(\tau\)</span>, a clause <span class="math notranslate nohighlight">\(C \in \Gamma\)</span> is <em>unit under</em> <span class="math notranslate nohighlight">\(\tau\)</span> if <span class="math notranslate nohighlight">\(\tau\)</span> falsifies all but one literal of
<span class="math notranslate nohighlight">\(C\)</span> and the remaining literal is unassigned. In other words, <span class="math notranslate nohighlight">\(C\)</span> is unit under <span class="math notranslate nohighlight">\(\tau\)</span> if <span class="math notranslate nohighlight">\(\tval{C}_\tau\)</span> consists of a single literal. The only way to satisfy
<span class="math notranslate nohighlight">\(C\)</span> is to assign that literal to true. Unit propagation iteratively extends <span class="math notranslate nohighlight">\(\tau\)</span> by satisfying all unit clauses. This process
continues until either no new unit clauses are generated by the extended <span class="math notranslate nohighlight">\(\tau\)</span> or until the extended <span class="math notranslate nohighlight">\(\tau\)</span>
falsifies a clause in <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<p>For example, consider the partial truth assignment <span class="math notranslate nohighlight">\(\tau\)</span> with <span class="math notranslate nohighlight">\(\tau(p_1) = \top\)</span> and the following formula:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\Gamma_\mathrm{unit} :=  (\lnot p_1 \lor \lnot p_3 \lor p_4) \land
      (\lnot p_1 \lor \lnot p_2 \lor p_3) \land (\lnot p_1 \lor p_2) \land (p_1 \lor p_3 \lor p_6) \land \\
  (\lnot p_1 \lor p_4 \lor \lnot p_5) \land (p_1 \lor \lnot p_6) \land (p_4 \lor p_5 \lor p_6) \land (p_5 \lor \lnot p_6)\end{split}\]</div>
<p>The clause <span class="math notranslate nohighlight">\((\lnot p_1 \lor p_2)\)</span> is unit under <span class="math notranslate nohighlight">\(\tau\)</span> because <span class="math notranslate nohighlight">\(\tval{(\lnot p_1 \lor p_2)}_{\tau} = (p_2)\)</span>.
Hence unit propagation will extend <span class="math notranslate nohighlight">\(\tau\)</span> by
assigning <span class="math notranslate nohighlight">\(p_2\)</span> to <span class="math notranslate nohighlight">\(\top\)</span>. Under the extended <span class="math notranslate nohighlight">\(\tau\)</span>, <span class="math notranslate nohighlight">\((\lnot p_1 \lor \lnot p_2 \lor p_3)\)</span>
is unit, which will further extend  <span class="math notranslate nohighlight">\(\tau\)</span> by assigning <span class="math notranslate nohighlight">\(p_3\)</span> to <span class="math notranslate nohighlight">\(\top\)</span>. Now the
clause <span class="math notranslate nohighlight">\((\lnot p_1 \lor \lnot p_3 \lor p_4)\)</span> becomes unit and thus assigns <span class="math notranslate nohighlight">\(p_4\)</span> to <span class="math notranslate nohighlight">\(\top\)</span>.
Ultimately, no unit clauses remain and unit propagation terminates with <span class="math notranslate nohighlight">\(\tau(p_1) = \tau(p_2) = \tau(p_3) = \tau(p_4) = \top\)</span>.</p>
<p>Another important simplification technique is the <em>pure literal rule</em>. A literal <span class="math notranslate nohighlight">\(l\)</span> is called pure in a formula <span class="math notranslate nohighlight">\(\Gamma\)</span> if
it always occurs with the same polarity. If a pure literal <span class="math notranslate nohighlight">\(l\)</span> only occurs positively (in other
words, only <span class="math notranslate nohighlight">\(l\)</span> occurs in the formula), the pure literal rule sets it to <span class="math notranslate nohighlight">\(\top\)</span>.
If it only occurs negatively (which is to say, <span class="math notranslate nohighlight">\(\lnot l\)</span> occurs only positively), the pure
literal rule sets it to <span class="math notranslate nohighlight">\(\bot\)</span>.</p>
<p>In contrast to unit propagation, the pure literal rule can reduce the number of satisfying assignments. Consider for
example for the formula <span class="math notranslate nohighlight">\(\Gamma = (p \lor q) \land (\lnot q \lor r) \land (q \lor \lnot r)\)</span>. The literal <span class="math notranslate nohighlight">\(p\)</span>
occurs only positively,
so the pure literal rule will assign it to <span class="math notranslate nohighlight">\(\tau(p) = \top\)</span>. We leave it to you to check that <span class="math notranslate nohighlight">\(\Gamma\)</span> has
three satisfying assignments, while <span class="math notranslate nohighlight">\(\tval{\Gamma}_{\tau}\)</span> has only two satisfying assignments.</p>
</section>
<section id="dpll">
<span id="section-dpll"></span><h2><span class="section-number">6.3. </span>DPLL<a class="headerlink" href="#dpll" title="Link to this heading"></a></h2>
<p>One of the first and most well-known decision procedures for SAT problems is the Davis-Putnam-Logemann-Loveland
(DPLL) algorithm, which was invented by Davis, Logemann, and Loveland in 1962,
based on
earlier work by Davis and Putnam in 1960. DPLL is a complete, backtracking-based search algorithm
that builds a binary tree of truth assignments. For nearly four decades since its invention, almost all
complete SAT solvers have been based on DPLL.</p>
<p>The DPLL procedure is a recursive algorithm that takes a CNF formula <span class="math notranslate nohighlight">\(\Gamma\)</span> and a truth assignment <span class="math notranslate nohighlight">\(\tau\)</span>
as input and returns a Boolean indicating whether <span class="math notranslate nohighlight">\(\Gamma\)</span> under the assignment <span class="math notranslate nohighlight">\(\tau\)</span> can be satisfied.
Each recursive call starts by extending <span class="math notranslate nohighlight">\(\tau\)</span> using unit propagation and the pure literal rule.
Afterwards, it checks whether the formula is satisfiable (<span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau = \top\)</span>) or unsatisfiable (<span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau = \bot\)</span>).
In either of those cases it returns <span class="math notranslate nohighlight">\(\top\)</span> or <span class="math notranslate nohighlight">\(\bot\)</span>, respectively. Otherwise, it selects an unassigned propositional variable <span class="math notranslate nohighlight">\(p\)</span>
and recursively calls DPLL with one branch extending <span class="math notranslate nohighlight">\(\tau\)</span> with <span class="math notranslate nohighlight">\(\tau(p) = \top\)</span> and another branch
extending <span class="math notranslate nohighlight">\(\tau\)</span> with <span class="math notranslate nohighlight">\(\tau(p) = \bot\)</span>. If one of the calls returns <span class="math notranslate nohighlight">\(\top\)</span> it returns <span class="math notranslate nohighlight">\(\top\)</span>, otherwise it
returns <span class="math notranslate nohighlight">\(\bot\)</span>.</p>
<p>The effectiveness of DPLL depends strongly on the quality of the propositional variables that are selected for the
recursive calls. The propositional variable selected for a recursive call is called a <em>decision variable</em>. A simple but
effective heuristic is to pick the variable that occurs most frequently in the
shortest clauses. This heuristics is called <em>MOMS</em> (Maximum Occurrence in clauses of Minimum Size). More
expensive heuristics are based on <em>lookaheads</em>, that is, assigning a variable to a truth value and measuring how much the formula can be simplified as a result.</p>
<p>Consider the following CNF formula:</p>
<div class="math notranslate nohighlight">
\[\Gamma_\mathrm{DPLL} :=  (p_1 \lor p_2 \lor \lnot p_3) \land (\lnot p_1 \lor p_2 \lor p_3) \land (\lnot p_1 \lor \lnot p_2 \lor p_3) \land (p_1 \lor p_3) \land (\lnot p_1 \lor \lnot p_3)\]</div>
<p>Selecting <span class="math notranslate nohighlight">\(p_3\)</span> as decision variable in the root node results in a DPLL tree with two leaf nodes. However, when selecting <span class="math notranslate nohighlight">\(p_2\)</span> as decision variable in the root node,
the DPLL tree consists of four leaf nodes. The figure below shows the DPLL trees with green nodes denoting satisfying assignments, while black nodes denote falsifying assignments.</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/dpll.png"><img alt="dpll example" class="align-center" src="_images/dpll.png" style="height: 150px;" /></a>
</div></blockquote>
<p>We have implemented a basic version of the DPLL procedure in Lean,
which can be found in the <code class="docutils literal notranslate"><span class="pre">Examples</span></code> folder.
We will start at the top level and work our way down.
The function <code class="docutils literal notranslate"><span class="pre">dpllSat</span></code> accepts a CNF formula and returns either a satisfying
assignment or <code class="docutils literal notranslate"><span class="pre">none</span></code> if there aren’t any.
It calls <code class="docutils literal notranslate"><span class="pre">propagateUnits</span></code> to perform unit propagation,
and then calls <code class="docutils literal notranslate"><span class="pre">dpllSatAux</span></code> to iteratively pick an unassigned variable
and split on that variable.
We use the keyword <code class="docutils literal notranslate"><span class="pre">partial</span></code> to allow for an arbitrary recursive call.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">partial</span> <span class="kd">def</span> <span class="n">dpllSatAux</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="n">PropAssignment</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">CnfForm</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">Option</span> <span class="o">(</span><span class="n">PropAssignment</span> <span class="bp">×</span> <span class="n">CnfForm</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">φ.hasEmpty</span> <span class="k">then</span> <span class="n">none</span>
  <span class="k">else</span> <span class="k">match</span> <span class="n">pickSplit</span><span class="bp">?</span> <span class="n">φ</span> <span class="k">with</span>
  <span class="c1">-- No variables left to split on, we found a solution.</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="bp">=&gt;</span> <span class="n">some</span> <span class="o">(</span><span class="n">τ</span><span class="o">,</span> <span class="n">φ</span><span class="o">)</span>
  <span class="c1">-- Split on `x`.</span>
  <span class="c1">-- `&lt;|&gt;` is the &quot;or else&quot; operator, which tries one action and if that fails</span>
  <span class="c1">-- tries the other.</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">goWithNew</span> <span class="n">x</span> <span class="n">τ</span> <span class="n">φ</span> <span class="bp">&lt;|&gt;</span> <span class="n">goWithNew</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="n">τ</span> <span class="n">φ</span>

<span class="n">where</span>
  <span class="sd">/-- Assigns `x` to true and continues out DPLL. -/</span>
  <span class="n">goWithNew</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Lit</span><span class="o">)</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="n">PropAssignment</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">CnfForm</span><span class="o">)</span> <span class="o">:</span>
      <span class="n">Option</span> <span class="o">(</span><span class="n">PropAssignment</span> <span class="bp">×</span> <span class="n">CnfForm</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">τ&#39;</span><span class="o">,</span> <span class="n">φ&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">propagateWithNew</span> <span class="n">x</span> <span class="n">τ</span> <span class="n">φ</span>
    <span class="n">dpllSatAux</span> <span class="n">τ&#39;</span> <span class="n">φ&#39;</span>

<span class="sd">/-- Solve `φ` using DPLL. Return a satisfying assignment if found, otherwise `none`. -/</span>
<span class="kd">def</span> <span class="n">dpllSat</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">CnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">Option</span> <span class="n">PropAssignment</span> <span class="o">:=</span>
  <span class="k">let</span> <span class="o">⟨</span><span class="n">τ</span><span class="o">,</span> <span class="n">φ</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">propagateUnits</span> <span class="o">[]</span> <span class="n">φ</span>
  <span class="o">(</span><span class="n">dpllSatAux</span> <span class="n">τ</span> <span class="n">φ</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="k">fun</span> <span class="o">⟨</span><span class="n">τ</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span> <span class="bp">=&gt;</span> <span class="n">τ</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">pickSplit?</span></code> naively chooses the first variable it finds.
It follows the Lean convention of using a question mark for a function that
returns an element of an option type.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">pickSplit</span><span class="bp">?</span> <span class="o">:</span> <span class="n">CnfForm</span> <span class="bp">→</span> <span class="n">Option</span> <span class="n">Lit</span>
  <span class="bp">|</span> <span class="o">[]</span>       <span class="bp">=&gt;</span> <span class="n">none</span>
  <span class="bp">|</span> <span class="n">c</span> <span class="o">::</span> <span class="n">cs</span>  <span class="bp">=&gt;</span> <span class="k">match</span> <span class="n">c</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">x</span>
    <span class="bp">|</span> <span class="n">_</span>      <span class="bp">=&gt;</span> <span class="n">pickSplit</span><span class="bp">?</span> <span class="n">cs</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">propagateUnits</span></code> performs unit propagation and returns the resulting
formula and the augmented truth assignment.
As long as there is a unit clause, it simplifies the formula and adds the new
literal to the assignment.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">partial</span> <span class="kd">def</span> <span class="n">propagateUnits</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="n">PropAssignment</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">CnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">PropAssignment</span> <span class="bp">×</span> <span class="n">CnfForm</span> <span class="o">:=</span>
  <span class="c1">-- If `φ` is unsat, we&#39;re done.</span>
  <span class="k">if</span> <span class="n">φ.hasEmpty</span> <span class="k">then</span> <span class="o">⟨</span><span class="n">τ</span><span class="o">,</span> <span class="n">φ</span><span class="o">⟩</span>
  <span class="k">else</span> <span class="k">match</span> <span class="n">φ.findUnit</span> <span class="k">with</span>
    <span class="c1">-- If there are no unit clauses, we&#39;re done.</span>
    <span class="bp">|</span> <span class="n">none</span>   <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="n">τ</span><span class="o">,</span> <span class="n">φ</span><span class="o">⟩</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="n">x</span> <span class="bp">=&gt;</span>
      <span class="c1">-- If there is a unit clause `x`, simplify the formula</span>
      <span class="c1">-- assuming `x` is true and continue propagating.</span>
      <span class="k">let</span> <span class="n">φ&#39;</span> <span class="o">:=</span> <span class="n">simplify</span> <span class="n">x</span> <span class="n">φ</span>
      <span class="k">if</span> <span class="n">τ.mem</span> <span class="n">x.name</span>
      <span class="k">then</span> <span class="n">panic</span><span class="bp">!</span> <span class="n">s</span><span class="bp">!</span><span class="s2">&quot;&#39;{x}&#39; has already been assigned and should not appear in the formula.&quot;</span>
      <span class="k">else</span> <span class="n">propagateUnits</span> <span class="o">(</span><span class="n">τ.withLit</span> <span class="n">x</span><span class="o">)</span> <span class="n">φ&#39;</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">propagateWithNew</span></code> is used to perform a split on the literal <code class="docutils literal notranslate"><span class="pre">x</span></code>.
It assigns the value of <code class="docutils literal notranslate"><span class="pre">x</span></code> and then does unit propagation.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">propagateWithNew</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Lit</span><span class="o">)</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="n">PropAssignment</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">CnfForm</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">PropAssignment</span> <span class="bp">×</span> <span class="n">CnfForm</span> <span class="o">:=</span>
  <span class="n">propagateUnits</span> <span class="o">(</span><span class="n">τ.withLit</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">simplify</span> <span class="n">x</span> <span class="n">φ</span><span class="o">)</span>
</pre></div>
</div>
<p>Finally, the function <code class="docutils literal notranslate"><span class="pre">simplify</span></code> simplifies a CNF formula by assigning the literal <code class="docutils literal notranslate"><span class="pre">x</span></code>
to true, assuming <code class="docutils literal notranslate"><span class="pre">x</span></code> is not one of the constants <code class="docutils literal notranslate"><span class="pre">⊥</span></code> or <code class="docutils literal notranslate"><span class="pre">⊤</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">simplify</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Lit</span><span class="o">)</span> <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="n">CnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">CnfForm</span> <span class="o">:=</span>
  <span class="n">assert</span><span class="bp">!</span> <span class="n">x</span> <span class="bp">!=</span> <span class="n">lit</span><span class="bp">!</span><span class="o">{</span><span class="bp">⊥</span><span class="o">}</span> <span class="bp">&amp;&amp;</span> <span class="n">x</span> <span class="bp">!=</span> <span class="n">lit</span><span class="bp">!</span><span class="o">{</span><span class="bp">⊤</span><span class="o">}</span>
  <span class="k">match</span> <span class="n">φ</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="o">[]</span>      <span class="bp">=&gt;</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="n">c</span> <span class="o">::</span> <span class="n">cs</span> <span class="bp">=&gt;</span>
               <span class="k">let</span> <span class="n">cs&#39;</span> <span class="o">:=</span> <span class="n">simplify</span> <span class="n">x</span> <span class="n">cs</span>
               <span class="c1">-- If clause became satisfied, erase it from the CNF</span>
               <span class="k">if</span> <span class="n">c.elem</span> <span class="n">x</span> <span class="k">then</span> <span class="n">cs&#39;</span>
               <span class="c1">-- Otherwise erase any falsified literals</span>
               <span class="k">else</span> <span class="n">c.eraseAll</span> <span class="n">x.negate</span> <span class="o">::</span> <span class="n">cs&#39;</span>

<span class="k">#eval</span> <span class="n">toString</span> <span class="bp">&lt;|</span> <span class="n">simplify</span> <span class="n">lit</span><span class="bp">!</span><span class="o">{</span><span class="n">p</span><span class="o">}</span> <span class="n">cnf</span><span class="bp">!</span><span class="o">{</span><span class="n">p</span> <span class="bp">-</span><span class="n">q</span> <span class="n">p</span> <span class="bp">-</span><span class="n">p</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span> <span class="n">q</span><span class="o">,</span> <span class="bp">-</span><span class="n">q</span> <span class="bp">-</span><span class="n">p</span><span class="o">,</span> <span class="bp">-</span><span class="n">p</span><span class="o">}</span>
</pre></div>
</div>
</section>
<section id="autarkies-and-2-sat">
<span id="section-autarkies-and-2-sat"></span><h2><span class="section-number">6.4. </span>Autarkies and 2-SAT<a class="headerlink" href="#autarkies-and-2-sat" title="Link to this heading"></a></h2>
<p>Unit propagation and the pure literal rule form the core of the DPLL algorithm.
In this section, we present a generalization of the pure literal rule,
and we illustrate its use by providing an efficient algorithm for a restricted version of SAT.</p>
<p>The notion of an <em>autarky</em> or <em>autarky assignment</em> is a generalization of
the notion of a pure literal. An autarky for a set of clauses is an assignment that satisfies all
the clauses that are touched by the assignment, in other words,
all the clauses that have at least one literal assigned.
A satisfying assignment of a set of clauses is one example of an autarky.
The assignment given by the pure literal rule is another.
There are often more interesting autarkies that are somewhere in between the two.</p>
<p>Notice that if <span class="math notranslate nohighlight">\(\tau\)</span> is an autarky for <span class="math notranslate nohighlight">\(\Gamma\)</span>,
then <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau \subseteq \Gamma\)</span>.
To see this, suppose <span class="math notranslate nohighlight">\(C\)</span> is any clause in <span class="math notranslate nohighlight">\(\Gamma\)</span>.
If <span class="math notranslate nohighlight">\(C\)</span> is touched by <span class="math notranslate nohighlight">\(\tau\)</span>, then <span class="math notranslate nohighlight">\(\tval{C}_\tau = \top\)</span>,
and so it is removed from <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span>.
If <span class="math notranslate nohighlight">\(C\)</span> is not touched by <span class="math notranslate nohighlight">\(\tau\)</span>, then <span class="math notranslate nohighlight">\(\tval{C}_\tau = C\)</span>.
Since every element of <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span> is of one of these two forms,
we have that <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau \subseteq \Gamma\)</span>.</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>Let <span class="math notranslate nohighlight">\(\tau\)</span> be an autarky for formula <span class="math notranslate nohighlight">\(\Gamma\)</span>. Then
<span class="math notranslate nohighlight">\(\Gamma\)</span> and <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span> are satisfiability equivalent.</p>
</div>
<div class="admonition-proof admonition">
<p class="admonition-title">Proof</p>
<p>If <span class="math notranslate nohighlight">\(\Gamma\)</span> is satisfiable, then since <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau \subseteq \Gamma\)</span>,
we know that <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span> is satisfiable as well.
Conversely, suppose <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span> is satisfiable
and let <span class="math notranslate nohighlight">\(\tau_1\)</span> be an assignment that satisfies <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span>.
We can assume that <span class="math notranslate nohighlight">\(\tau_1\)</span> only assigns values to the variables of
<span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span>, which are distinct from the variables of <span class="math notranslate nohighlight">\(\tau\)</span>.
Then the assignment <span class="math notranslate nohighlight">\(\tau_2\)</span> which is the union of <span class="math notranslate nohighlight">\(\tau\)</span> and <span class="math notranslate nohighlight">\(\tau_1\)</span>
satisfies <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
</div>
<p>We now turn to a restricted version of SAT.
A CNF formula is called <span class="math notranslate nohighlight">\(k\)</span>-SAT if the length of all clauses is at most <span class="math notranslate nohighlight">\(k\)</span>.
2-SAT formulas can be solved in polynomial time, while <span class="math notranslate nohighlight">\(k\)</span>-SAT is NP-complete
for <span class="math notranslate nohighlight">\(k \geq 3\)</span>. A simple, efficient
decision procedure for 2-SAT uses only unit propagation and autarky reasoning. The decision procedure is based
on the following observation. Given a 2-SAT formula <span class="math notranslate nohighlight">\(\Gamma\)</span> that contains a propositional
variable <span class="math notranslate nohighlight">\(p\)</span>, unit propagation on <span class="math notranslate nohighlight">\(\Gamma\)</span> using <span class="math notranslate nohighlight">\(\tau(p) = \top\)</span> has two possible
outcomes: (1) it results in a conflict, meaning that all satisfying assignments of <span class="math notranslate nohighlight">\(\Gamma\)</span>
have to assign <span class="math notranslate nohighlight">\(p\)</span> to <span class="math notranslate nohighlight">\(\bot\)</span>, or (2) unit propagation does not result in a conflict, in which case the
extended assignment after unit propagation is an autarky. To understand the latter case, note that
assigning a literal in any clause of length two either satisfies the clause (if the literal is true) or
reduces it to a unit clause (if the literal is false). So if there isn’t a conflict, then it is impossible
that unit propagation will produce a clause that is touched but not satisfied.</p>
<p>The decision procedure works as follows. Given a 2-SAT formula <span class="math notranslate nohighlight">\(\Gamma\)</span>, we pick
a propositional variable <span class="math notranslate nohighlight">\(p\)</span> occurring in <span class="math notranslate nohighlight">\(\Gamma\)</span> and compute the result
of unit propagation on <span class="math notranslate nohighlight">\(\Gamma\)</span> using <span class="math notranslate nohighlight">\(\tau(p) = \top\)</span>. If unit propagation
does not result in a conflict, let <span class="math notranslate nohighlight">\(\tau'\)</span> be the extended assignment and we continue
with <span class="math notranslate nohighlight">\(\tval{\Gamma}_{\tau'}\)</span>. Otherwise let <span class="math notranslate nohighlight">\(\tau''(p) = \bot\)</span> and we continue with
<span class="math notranslate nohighlight">\(\tval{\Gamma}_{\tau''}\)</span>. This process is repeated until the formula is empty,
which indicates that the original formula is satisfiable,
or contains the empty clause,
which indicates that the original clause is unsatisfiable.</p>
</section>
<section id="cdcl">
<span id="section-cdcl"></span><h2><span class="section-number">6.5. </span>CDCL<a class="headerlink" href="#cdcl" title="Link to this heading"></a></h2>
<p>The Conflict-Driven Clause-Learning (CDCL) decision procedure is the most successful SAT solving
paradigm. Although it evolved from DPLL, modern implementations of CDCL have hardly any resemblance
with the classic decision procedure. The algorithms differ in core algorithmic choices.
When designing an algorithm, one typically needs to choose between making the algorithm smart or
making it fast. Having it both ways is generally not an option due to conflicting requirements for the datastructures.
State-of-the-art DPLL algorithms are designed to be smart: spend serious computational effort to
pick the best variable in each recursive call to make the binary tree relatively small. As we will describe below,
CDCL focuses on being fast. Unit propagation is by far the most computationally expensive step
and everything in a CDCL solver is designed by make that as fast as possible. That prevents
more complicated heuristics. Another important design decision for SAT solving algorithms is
determining whether you plan to find a satisfying assignment or prove that none exists. DPLL
focuses on finding a satisfying assignment by picking the most satisfiable branch first, while
CDCL, as the name suggests, prefers conflicts and wants to find a short refutation. A
satisfying assignment is a counterexample to the claim that no refutation exists.</p>
<p>The early development of CDCL is four decades later than DPLL. While DPLL simply backtracks
when a conflict (leaf node) is reached, CDCL turns this conflict into a conflict clause that is
added to the formula. The first and arguably most important step towards CDCL is the invention
which clause to add: the first unique implication point. The first unique implication point is an
invention by Marques-Silva and Sakallah (1996) and is still used in all modern day top-tier
solvers.</p>
<p>The best decision heuristic for CDCL selects the unassigned variable that occurs
most frequently in recently learned conflict clauses. This heuristic, called
Variable-State Independent Decaying Sum (VSIDS in short), was introduced
in the zChaff SAT solver by Moskewicz and co-authors (2001). The heuristic
was been improved over the years, in particular by Eén and Sörensson (2003)
in their solver MiniSAT. In recent years some other advances have been made as well.
However, selecting variables in recent conflict clauses is still the foundation.</p>
<p>Adding clauses to the input formula could significantly increase the cost of unit propagation.
Therefore clause learning was not immediately successful. The contribution that showed the
effectiveness of clause learning in practice is the 2-literal watchpointers datastructure.
In short, the solver does not maintain a full occurrence list of clauses, but only an
occurrence list of the first two literals in a clause. These first two literals are required to
have the following invariant: either both literals are unassigned or one of them is
assigned to true. That invariant is enough to ensure that the clause is not unit. In case
an assignment breaks the invariant, then the entire clause is explored to check whether
it is possible to fix the invariant by swapping a satisfied or unassigned literal to the first
two positions. If this is not possible, the clause is unit and the unassigned literal
is assigned to true or the clause is falsified which triggers the learning procedure in
the solver.</p>
<p>Another key difference between CDCL and DPLL is that the former restarts very
frequently. Restarting sounds drastic, but simply means that all variables are
unassigned. The remainder of the solver state, such as the heuristics and the
learned clauses, are not altered. Modern SAT solver restart often, roughly
a thousand times per second (although this depends on the size of the formula).
As a consequence, no binary search tree is constructed. Instead, CDCL might
be best viewed a conflict-clause generator without any systematic search.</p>
<p>The are various other parts in CDCL solvers that are important for fast
performance but that are beyond the scope of this course. For example,
CDCL solvers do not only learn many clauses, but they also aggressively
delete them to reduce the impact on unit propagation. Also, CDCL solvers
use techniques to rewrite the formula, so called inprocessing techniques.
In top-tier solvers, about half the runtime can be devoted to such
techniques.</p>
</section>
<section id="exercises">
<h2><span class="section-number">6.6. </span>Exercises<a class="headerlink" href="#exercises" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>Write, in Lean, a predicate <code class="docutils literal notranslate"><span class="pre">isAutarky</span></code> that takes an assignment
<span class="math notranslate nohighlight">\(\tau\)</span> (of type <code class="docutils literal notranslate"><span class="pre">PropAssignment</span></code>) and a CNF formula <span class="math notranslate nohighlight">\(\Gamma\)</span>
(of type <code class="docutils literal notranslate"><span class="pre">CnfForm</span></code>) and returns true or false depending on whether <span class="math notranslate nohighlight">\(\tau\)</span>
is an autarky for <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p></li>
<li><p>Write in Lean a function <code class="docutils literal notranslate"><span class="pre">getPure</span></code> that takes a CNF formula <span class="math notranslate nohighlight">\(\Gamma\)</span>
and returns a <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">Lit</span></code> of all pure literals in <span class="math notranslate nohighlight">\(\Gamma\)</span>.
The function does not need to find all pure literals on pure literal
assignment until fixpoint, only the literals the are pure in <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p></li>
</ol>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="implementing_propositional_logic.html" class="btn btn-neutral float-left" title="5. Implementing Propositional Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="using_sat_solvers.html" class="btn btn-neutral float-right" title="7. Using SAT Solvers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>