<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>7. Using SAT Solvers &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=0731ccc3" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=2709fde1"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script>window.MathJax = {"loader": {"load": ["[tex]/bussproofs"]}, "tex": {"packages": {"[+]": ["bussproofs"]}, "macros": {"fn": ["\\mathit{#1}", 1], "fa": ["\\forall #1. \\,", 1], "ex": ["\\exists #1. \\,", 1], "bN": "{\\mathbb{N}}", "bZ": "{\\mathbb{Z}}", "bR": "{\\mathbb{R}}", "limplies": "\\to", "liff": "\\leftrightarrow", "proves": "\\vdash", "append": "\\mathbin{+\\mkern-10mu+}", "tval": ["[\\![#1]\\!]", 1], "fCenter": "\\proves", "mdl": ["\\mathfrak{#1}", 1]}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="8. Proof Systems for Propositional Logic" href="proof_systems_for_propositional_logic.html" />
    <link rel="prev" title="6. Decision Procedures for Propositional Logic" href="decision_procedures_for_propositional_logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Logic and Mechanized Reasoning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures for Propositional Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">7. Using SAT Solvers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#first-examples">7.1. First examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#encoding-problems">7.2. Encoding problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercise-grid-coloring">7.3. Exercise: grid coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercise-numbermind">7.4. Exercise: NumberMind</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_propositional_logic.html">8. Proof Systems for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_proof_assistant.html">9. Using Lean as a Proof Assistant</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">11. Implementing First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_first_order_logic.html">12. Decision Procedures for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">13. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_first_order_logic.html">14. Proof Systems for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">15. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="beyond_first_order_logic.html">16. Beyond First-Order Logic</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">7. </span>Using SAT Solvers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/using_sat_solvers.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="using-sat-solvers">
<span id="chapter-using-sat-solvers"></span><h1><span class="section-number">7. </span>Using SAT Solvers<a class="headerlink" href="#using-sat-solvers" title="Link to this heading"></a></h1>
<p>A satisfiability (SAT) solver determines whether a propositional formula has a satisfying assignment.
The performance of SAT solvers has improved significantly in the last two decades. In the late 1990s,
only formulas with thousands of variables and thousands of clauses could be solved. Today,
many propositional formulas with millions of variables and millions of clauses can be solved.
In this chapter, we will explain how to use SAT solvers and how to encode problems into
propositional logic.</p>
<section id="first-examples">
<span id="section-first-examples"></span><h2><span class="section-number">7.1. </span>First examples<a class="headerlink" href="#first-examples" title="Link to this heading"></a></h2>
<p>Remember that contemporary SAT solvers determine that satisfiability of propositional formulas
in conjunctive normal form. Specifically, they use a format for specifying such formulas known
as the <em>DIMACS</em> format. Our <em>LAMR</em> library proves a function that converts any CNF formula
to that format, sends it to a SAT solver called <em>CaDiCaL</em>, and parses the answer.
The following can be found in <cite>Examples/using_sat_solver/examples.lean</cite>:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">cadicalExample</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">result</span><span class="o">)</span> <span class="bp">←</span> <span class="n">callCadical</span> <span class="n">exCnf0</span>
  <span class="n">IO.println</span> <span class="s2">&quot;Output from CaDiCaL :</span><span class="se">\n</span><span class="s2">&quot;</span>
  <span class="c1">-- IO.println s</span>
  <span class="c1">-- IO.println &quot;\n\n&quot;</span>
  <span class="n">IO.println</span> <span class="o">(</span><span class="n">formatResult</span> <span class="n">result</span><span class="o">)</span>
  <span class="n">pure</span> <span class="o">()</span>

<span class="k">#eval</span> <span class="n">cadicalExample</span>
</pre></div>
</div>
<p>It uses the same example CNF formulas defined in <a class="reference internal" href="implementing_propositional_logic.html#section-implementing-propositional-normal-forms"><span class="std std-numref">Section 5.3</span></a>.
You can change <cite>exCnf0</cite> to <cite>exCnf1</cite> or <cite>exCnf2</cite>,
or use any other CNF formula you want.
If you uncomment the two lines that begin <cite>IO.println</cite>,
the Lean output will show you the raw output from CaDiCaL.</p>
</section>
<section id="encoding-problems">
<span id="section-encoding-problems"></span><h2><span class="section-number">7.2. </span>Encoding problems<a class="headerlink" href="#encoding-problems" title="Link to this heading"></a></h2>
<p>All NP-complete problems can be transformed in polynomial time into a SAT problem
(i.e., into a propositional formula). For many problems, such a transformation
is quite natural. For some other problems, the transformation can be complicated.
The transformation is not unique. Frequently there exist many way to encode a
problem as a propositional formula. The encoding can have a big impact on the
runtime of SAT solvers. Generally, the smallest encoding for a problem (in terms
of the number of variables and the number of clauses) results in relatively strong
performance. In this section we will describe a few encodings.</p>
<p>One way to encode a problem into propositional logic is to describe it first using some high-level constraints.
Let’s consider a couple of high-level constraints: Constrain a sequence of literals such that
at least one of them is true (<cite>atLeastOne</cite>), or that at most one of the is true (<cite>atMostOne</cite>),
or that an odd number of them is true (<cite>XOR</cite>). Afterwards these constraints are encoded
into propositional logical to obtain, so a SAT solver can be used to solve the resulting
formula.</p>
<p>How to encode <cite>atLeastOne</cite>, <cite>atMostOne</cite>, and <cite>XOR</cite> as a set of clauses? The constraint
<cite>atLeastOne</cite> is easy: simply use the disjunction of all the literals in the sequence. The second
constraint is requires multiple clauses. The naive way generates a quadratic number of
clauses: for each pair of literals <span class="math notranslate nohighlight">\((l_i, l_j)\)</span> in the sequence, include the clause <span class="math notranslate nohighlight">\(\lnot l_i \lor \lnot l_j\)</span>.
The naive way of encoding the <cite>XOR</cite> constraint results in an exponential number of clauses:
all possible clauses over the literals such that an odd number of them are negated. For example,
the encoding of <cite>XOR</cite><span class="math notranslate nohighlight">\((l_1,l_2,l_3)\)</span> produces the following clauses:
<span class="math notranslate nohighlight">\(l_1 \lor l_2 \lor \lnot l_3, l_1 \lor \lnot l_2 \lor l_3, \lnot l_1 \lor l_2 \lor l_3, \lnot l_1 \lor \lnot l_2 \lor \lnot l_3\)</span></p>
<p>Although a quadratic number of clauses produced by can be acceptable <cite>atMostOne</cite> for a
reasonable small sequence of literals, the exponential number of clauses produced by <cite>XOR</cite>
would result in formulas that are hard to solve solely due to the size of the formula.
Fortunately, one can encode both <cite>atMostOne</cite> and <cite>XOR</cite> using a linear number of
clauses using the following trick: In case the sequence consists of more than four literals,
split the constraint into two such that the first uses the first three literals of the sequence appended by a new literal <span class="math notranslate nohighlight">\(y\)</span>, while
the second uses the remainder of the sequence appended by the literal <span class="math notranslate nohighlight">\(\lnot y\)</span>.
For example, <cite>atMostOne</cite><span class="math notranslate nohighlight">\((l_1,\dots,l_n)\)</span> is split into <cite>atMostOne</cite><span class="math notranslate nohighlight">\((l_1,l_2,l_3,y)\)</span>
and <cite>atMostOne</cite><span class="math notranslate nohighlight">\((l_4,\dots, l_n,\lnot y)\)</span>. The splitting is repeated until none of the
constraints has a sequence longer than four.</p>
<p>Another approach to encode a problem into propositional logic is to express it
first as another NP-complete problem and afterwards transform the result into
propositional logic. Let’s demonstrate this approach for graph coloring.
The graph coloring problem asks whether a given graph can be colored with
a given number of colors such that adjacent vertices have different colors. Graph coloring
problems can be easily encoded into a propositional formula, and SAT solvers
can frequently solve these formulas efficiently.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> and <span class="math notranslate nohighlight">\(k\)</span> colors, the encoding uses <span class="math notranslate nohighlight">\(k|V|\)</span> Boolean
variables <span class="math notranslate nohighlight">\(x_{i,j}\)</span> with <span class="math notranslate nohighlight">\(i \in \{1,\dots,|V|\}\)</span> and <span class="math notranslate nohighlight">\(j \in \{1,\dots,k\}\)</span>
and <span class="math notranslate nohighlight">\(|V| +k|E|\)</span> clauses.
If <span class="math notranslate nohighlight">\(x_{i,j}\)</span> is assigned to true it means that vertex <span class="math notranslate nohighlight">\(i\)</span> is assigned color <span class="math notranslate nohighlight">\(j\)</span>.
The clauses encode two constraints: each vertex has a color and adjacent vertices have
a different color. The first constraint can be encoded using a single clause per vertex. For example,
for vertex <span class="math notranslate nohighlight">\(i\)</span>, we have the following clause: <span class="math notranslate nohighlight">\(x_{i,1} \lor \dots \lor x_{i,k}\)</span>.
The second constraint requires <span class="math notranslate nohighlight">\(k\)</span>
binary clauses. For example, for an edge between vertices <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(i\)</span>, we have the
following binary clauses: <span class="math notranslate nohighlight">\((\lnot x_{h,1} \lor \lnot x_{i,1}) \land \dots \land (\lnot x_{h,k} \lor \lnot x_{i,k})\)</span>.</p>
<p>The CNF formulas for a triangle (a fully connected graph with three vertices) for two colors and
three colors is shown below. The first one is unsatisfiable, while the second one is satisfiable.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">triangleCnf2</span> <span class="o">:=</span> <span class="bp">!</span><span class="n">cnf</span><span class="o">{</span>
  <span class="n">x11</span> <span class="n">x12</span><span class="o">,</span>
  <span class="n">x21</span> <span class="n">x22</span><span class="o">,</span>
  <span class="n">x31</span> <span class="n">x32</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x11</span> <span class="bp">-</span><span class="n">x21</span><span class="o">,</span> <span class="bp">-</span><span class="n">x12</span> <span class="bp">-</span><span class="n">x22</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x11</span> <span class="bp">-</span><span class="n">x31</span><span class="o">,</span> <span class="bp">-</span><span class="n">x12</span> <span class="bp">-</span><span class="n">x32</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x21</span> <span class="bp">-</span><span class="n">x31</span><span class="o">,</span> <span class="bp">-</span><span class="n">x22</span> <span class="bp">-</span><span class="n">x32</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">triangleCnf3</span> <span class="o">:=</span> <span class="bp">!</span><span class="n">cnf</span><span class="o">{</span>
  <span class="n">x11</span> <span class="n">x12</span> <span class="n">x13</span><span class="o">,</span>
  <span class="n">x21</span> <span class="n">x22</span> <span class="n">x23</span><span class="o">,</span>
  <span class="n">x31</span> <span class="n">x32</span> <span class="n">x33</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x11</span> <span class="bp">-</span><span class="n">x21</span><span class="o">,</span> <span class="bp">-</span><span class="n">x12</span> <span class="bp">-</span><span class="n">x22</span><span class="o">,</span> <span class="bp">-</span><span class="n">x13</span> <span class="bp">-</span><span class="n">x23</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x11</span> <span class="bp">-</span><span class="n">x31</span><span class="o">,</span> <span class="bp">-</span><span class="n">x12</span> <span class="bp">-</span><span class="n">x32</span><span class="o">,</span> <span class="bp">-</span><span class="n">x13</span> <span class="bp">-</span><span class="n">x33</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x21</span> <span class="bp">-</span><span class="n">x31</span><span class="o">,</span> <span class="bp">-</span><span class="n">x22</span> <span class="bp">-</span><span class="n">x32</span><span class="o">,</span> <span class="bp">-</span><span class="n">x23</span> <span class="bp">-</span><span class="n">x23</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Many problems, such as scheduling and planning, can naturally be expressed as a graph coloring problem. We can then transform the graph coloring
problem into a SAT problem using the encoding described above.</p>
<p>An example of a problem that can be expressed as a graph coloring problem is the popular puzzle Sudoku:
Place number is a grid consisting of nine squares subdivided into a further nine smaller squares in such a way that every
number appears once in each horizontal line, vertical line, and square. This puzzle can be seen as a graph coloring
where each small square is a vertex, and vertices are connected if and only if the corresponding small squares occur
the the same horizontal line, vertical line, or square. Below is one of the hardest sudoku puzzles with only 17 given numbers.</p>
<a class="reference internal image-reference" href="_images/sudoku.png"><img alt="sudoku puzzle" class="align-center" src="_images/sudoku.png" style="width: 200px;" /></a>
<p>If you take a look at the file <cite>sudoku.lean</cite> in the <cite>Examples</cite> folder,
you will see that it is easily solved by a SAT solver.</p>
</section>
<section id="exercise-grid-coloring">
<h2><span class="section-number">7.3. </span>Exercise: grid coloring<a class="headerlink" href="#exercise-grid-coloring" title="Link to this heading"></a></h2>
<p>Ramsey Theory deals with patterns that cannot be avoided indefinitely. In
this exercise we focus on a pattern of coloring a <span class="math notranslate nohighlight">\(n \times m\)</span> grid with <span class="math notranslate nohighlight">\(k\)</span> colors:
Consider all possible rectangles within the grid whose length and width are
at least 2. We try to color the grid using <span class="math notranslate nohighlight">\(k\)</span> colors so that no such rectangle
has the same color for its four corners. When this is possible, we say that
the <span class="math notranslate nohighlight">\(n \times m\)</span> grid is <span class="math notranslate nohighlight">\(k\)</span>-colorable while avoiding monochromatic rectangles. When
using <span class="math notranslate nohighlight">\(k\)</span> colors, it is relatively easy to construct a valid <span class="math notranslate nohighlight">\(k^2 \times k^2\)</span> grid.
However, only few valid grids that are larger than <span class="math notranslate nohighlight">\(k^2 \times k^2\)</span> are known. An
example of a valid <span class="math notranslate nohighlight">\(3\)</span>-coloring of the <span class="math notranslate nohighlight">\(9 \times 9\)</span> grid is shown below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0 0 1 1 2 2 0 1 2
2 0 0 1 1 2 2 0 1
1 2 0 0 1 1 2 2 0
0 1 2 0 0 1 1 2 2
2 0 1 2 0 0 1 1 2
2 2 0 1 2 0 0 1 1
1 2 2 0 1 2 0 0 1
1 1 2 2 0 1 2 0 0
0 1 1 2 2 0 1 2 0
</pre></div>
</div>
<p>Write a Lean function that takes as input three natural numbers
<span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(m\)</span>, and <span class="math notranslate nohighlight">\(k\)</span>, which returns a CNF formula of
Lean data type <code class="docutils literal notranslate"><span class="pre">CnfForm</span></code> which is satisfiable if an only if there
exists a valid <span class="math notranslate nohighlight">\(k\)</span>-coloring of the <span class="math notranslate nohighlight">\(n \times m\)</span> grid, that is,
a coloring without monochromatic rectangles. (Hint: The
encoding requires two types of clauses. First, each square needs to have one color. Second, if four squares form the corners of a rectangle,
then they cannot have the same color.)</p>
<p>Next, use the Lean interface to CaDiCaL to solve the formula
with <span class="math notranslate nohighlight">\(n=10\)</span>, <span class="math notranslate nohighlight">\(m=10\)</span>, and <span class="math notranslate nohighlight">\(k=3\)</span> and the formula with <span class="math notranslate nohighlight">\(n=9\)</span>, <span class="math notranslate nohighlight">\(m=12\)</span>, and <span class="math notranslate nohighlight">\(k=3\)</span>.
Both formulas should be satisfiable. The answer should consist of two lists (one for each formula)
using Lean data type <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">Lit</span></code> containing only all positive literals assigned to true (<span class="math notranslate nohighlight">\(\top\)</span>).</p>
<p>Finally, given a <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">Lit</span></code> containing only all positive literals assigned to true
for a grid-coloring problem, decode it into a grid of numbers similar to the <span class="math notranslate nohighlight">\(9 \times 9\)</span> grid shown above.
Use the function to display the solutions of <span class="math notranslate nohighlight">\(n=10\)</span>, <span class="math notranslate nohighlight">\(m=10\)</span>, and <span class="math notranslate nohighlight">\(k=3\)</span> and of <span class="math notranslate nohighlight">\(n=9\)</span>, <span class="math notranslate nohighlight">\(m=12\)</span>, and <span class="math notranslate nohighlight">\(k=3\)</span>.
You can assume that the decoding function knows <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(m\)</span>, and <span class="math notranslate nohighlight">\(k\)</span> of the grid-coloring problem.</p>
</section>
<section id="exercise-numbermind">
<h2><span class="section-number">7.4. </span>Exercise: NumberMind<a class="headerlink" href="#exercise-numbermind" title="Link to this heading"></a></h2>
<p>The game Number Mind is a variant of the well known game Master Mind.
Instead of colored pegs, you have to guess a secret sequence of digits.
After each guess you’re only told in how many places you’ve guessed the
correct digit. So, if the sequence was 1234 and you guessed 2036, you’d
be told that you have one correct digit; however, you would <em>not</em> be told
that you also have another digit in the wrong place.</p>
<p>For instance, given the following guesses for a 5-digit secret sequence,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>90342 ;2 correct
70794 ;0 correct
39458 ;2 correct
34109 ;1 correct
51545 ;2 correct
12531 ;1 correct
</pre></div>
</div>
<p>the correct sequence 39542 is unique.</p>
<p>Given the following guesses,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>5616185650518293 ;2 correct
3847439647293047 ;1 correct
5855462940810587 ;3 correct
9742855507068353 ;3 correct
4296849643607543 ;3 correct
3174248439465858 ;1 correct
4513559094146117 ;2 correct
7890971548908067 ;3 correct
8157356344118483 ;1 correct
2615250744386899 ;2 correct
8690095851526254 ;3 correct
6375711915077050 ;1 correct
6913859173121360 ;1 correct
6442889055042768 ;2 correct
2321386104303845 ;0 correct
2326509471271448 ;2 correct
5251583379644322 ;2 correct
1748270476758276 ;3 correct
4895722652190306 ;1 correct
3041631117224635 ;3 correct
1841236454324589 ;3 correct
2659862637316867 ;2 correct
</pre></div>
</div>
<p>find the unique 16-digit secret sequence, as follows.</p>
<p>First, write a Lean function that takes as input a <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">Lit</span></code> and a natural number <span class="math notranslate nohighlight">\(k\)</span>
and returns a propositional formula of Lean data type <code class="docutils literal notranslate"><span class="pre">CnfForm</span></code> that is satisfiable if and
only if exactly <span class="math notranslate nohighlight">\(k\)</span> literals of list are satisfied. Use propositional variables <span class="math notranslate nohighlight">\(p_{i, j}\)</span> which are
true if and only if position <span class="math notranslate nohighlight">\(i\)</span> has the digit <span class="math notranslate nohighlight">\(j\)</span>. No other variables are required.
(Hint: The easiest way to encode that exactly <span class="math notranslate nohighlight">\(k\)</span> literals are true is by splitting it in at-least
<span class="math notranslate nohighlight">\(k\)</span> are true and at-most <span class="math notranslate nohighlight">\(k`\)</span> are true. No auxiliary propositional variables are required.)</p>
<p>Then write a Lean program that can solve Number Mind puzzles. The input is a list of
exactly-<span class="math notranslate nohighlight">\(k\)</span> constraints with a constraint being a list of literals and a number <span class="math notranslate nohighlight">\(k\)</span>. The meaning
of a constraint is that exactly <span class="math notranslate nohighlight">\(k\)</span> of the literals are true. The program should
return a formula of Lean data type <code class="docutils literal notranslate"><span class="pre">CnfForm</span></code> that is satisfiable if and only if
all constraints are satisfied. Note that Number Mind puzzles require i) constraints enforcing how many
digits are correct <em>and</em> ii) constraints enforcing that for each position exactly one digit can be
present in a solution.</p>
<p>Finally, run the program to solve the Number Mind puzzle shown above with 16 digits
using the CaDiCaL interface. Transform the solution into a sequence of digits.</p>
<p>The solution of the Number Mind puzzle shown above is claimed to be unique.
use CaDiCaL to show that this claim is correct.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="decision_procedures_for_propositional_logic.html" class="btn btn-neutral float-left" title="6. Decision Procedures for Propositional Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="proof_systems_for_propositional_logic.html" class="btn btn-neutral float-right" title="8. Proof Systems for Propositional Logic" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>