

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>8. Using SAT Solvers &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>window.MathJax = {"loader": {"load": ["[tex]/bussproofs"]}, "tex": {"packages": {"[+]": ["bussproofs"]}, "macros": {"fn": ["\\mathit{#1}", 1], "bN": "{\\mathbb{N}}", "bZ": "{\\mathbb{Z}}", "bR": "{\\mathbb{R}}", "limplies": "{\\to}", "liff": "{\\leftrightarrow}", "proves": "{\\vdash}", "append": "\\mathbin{+\\mkern-10mu+}", "tval": ["[\\![#1]\\!]", 1]}}}</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="9. Deduction for Propositional Logic" href="deduction_for_propositional_logic.html" />
    <link rel="prev" title="7. Decision Procedures" href="decision_procedures_for_propositional_logic.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Logic and Mechanized Reasoning
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_proof_assistant.html">6. Lean as a Proof Assistant</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">7. Decision Procedures</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Using SAT Solvers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#first-examples">8.1. First examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#encoding-problems">8.2. Encoding problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercise-grid-coloring">8.3. Exercise: grid coloring</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercise-numbermind">8.4. Exercise: NumberMind</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="deduction_for_propositional_logic.html">9. Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="terms_and_formulas.html">10. Terms and Formulas</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_terms_and_formulas.html">11. Implementing Terms and Formulas</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">12. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">13. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">14. Implementing First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">15. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="simple_type_theory.html">16. Simple Type Theory</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">8. </span>Using SAT Solvers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/using_sat_solvers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="using-sat-solvers">
<span id="chapter-using-sat-solvers"></span><h1><span class="section-number">8. </span>Using SAT Solvers<a class="headerlink" href="#using-sat-solvers" title="Permalink to this headline">¶</a></h1>
<p>A satisfiability (SAT) solver determines whether a propositional formula has a satisfying assignment.
The performance of SAT solvers has improved significantly in the last two decades. In the late 1990s,
only formulas with thousands of variables and thousands of clauses could be solved. Today,
many propositional formulas with millions of variables and millions of clauses can be solved.
In this chapter, we will explain how to use SAT solvers and how to encode problems into
propositional logic.</p>
<div class="section" id="first-examples">
<span id="section-first-examples"></span><h2><span class="section-number">8.1. </span>First examples<a class="headerlink" href="#first-examples" title="Permalink to this headline">¶</a></h2>
<p>Remember that contemporary SAT solvers determine that satisfiability of propositional formulas
in conjunctive normal form. Specifically, they use a format for specifying such formulas known
as the <em>DIMACS</em> format. Our <em>LAMR</em> library proves a function that converts any CNF formula
to that format, sends it to a SAT solver called <em>CaDiCaL</em>, and parses the answer.
The following can be found in <cite>Examples/using_sat_solver/examples.lean</cite>:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">cadicalExample</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">let</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">result</span><span class="o">)</span> <span class="bp">←</span> <span class="n">callCadical</span> <span class="n">exCnf0</span>
  <span class="n">IO.println</span> <span class="s2">&quot;Output from CaDiCaL :</span><span class="se">\n</span><span class="s2">&quot;</span>
  <span class="c1">--IO.println s</span>
  <span class="c1">--IO.println &quot;\n\n&quot;</span>
  <span class="n">IO.println</span> <span class="o">(</span><span class="n">formatResult</span> <span class="n">result</span><span class="o">)</span>
  <span class="n">pure</span> <span class="o">()</span>

<span class="k">#eval</span> <span class="n">cadicalExample</span>
</pre></div>
</div>
<p>It uses the same example CNF formulas defined in <a class="reference internal" href="implementing_propositional_logic.html#section-implementing-propositional-normal-forms"><span class="std std-numref">Section 5.3</span></a>.
You can change <cite>exCnf0</cite> to <cite>exCnf1</cite> or <cite>exCnf2</cite>,
or use any other CNF formula you want.
If you uncomment the two lines that begin <cite>IO.println</cite>,
the Lean output will show you the raw output from CaDiCaL.</p>
</div>
<div class="section" id="encoding-problems">
<span id="section-encoding-problems"></span><h2><span class="section-number">8.2. </span>Encoding problems<a class="headerlink" href="#encoding-problems" title="Permalink to this headline">¶</a></h2>
<p>All NP-complete problems can be transformed in polynomial time into a SAT problem
(i.e., into a propositional formula). For many problems, such a transformation
is quite natural. For some other problems, the transformation can be complicated.
The transformation is not unique. Frequently there exist many way to encode a
problem as a propositional formula. The encoding can have a big impact on the
runtime of SAT solvers. Generally, the smallest encoding for a problem (in terms
of the number of variables and the number of clauses) results in relatively strong
performance. In this section we will describe a few encodings.</p>
<p>One way to encode a problem into propositional logic is to describe it first using some high-level constraints.
Let’s consider a couple of high-level constraints: Constrain a sequence of literals such that
at least one of them is true (<cite>atLeastOne</cite>), or that at most one of the is true (<cite>atMostOne</cite>),
or that an odd number of them is true (<cite>XOR</cite>). Afterwards these constraints are encoded
into propositional logical to obtain, so a SAT solver can be used to solve the resulting
formula.</p>
<p>How to encode <cite>atLeastOne</cite>, <cite>atMostOne</cite>, and <cite>XOR</cite> as a set of clauses? The constraint
<cite>atLeastOne</cite> is easy: simply use the disjunction of all the literals in the sequence. The second
constraint is requires multiple clauses. The naive way generates a quadratic number of
clauses: for each pair of literals <span class="math notranslate nohighlight">\((l_i, l_j)\)</span> in the sequence, include the clause <span class="math notranslate nohighlight">\(\lnot l_i \lor \lnot l_j\)</span>.
The naive way of encoding the <cite>XOR</cite> constraint results in an exponential number of clauses:
all possible clauses over the literals such that an odd number of them are negated. For example,
the encoding of <cite>XOR</cite><span class="math notranslate nohighlight">\((l_1,l_2,l_3)\)</span> produces the following clauses:
<span class="math notranslate nohighlight">\(l_1 \lor l_2 \lor \lnot l_3, l_1 \lor \lnot l_2 \lor l_3, \lnot l_1 \lor l_2 \lor l_3, \lnot l_1 \lor \lnot l_2 \lor \lnot l_3\)</span></p>
<p>Although a quadratic number of clauses produced by can be acceptable <cite>atMostOne</cite> for a
reasonable small sequence of literals, the exponential number of clauses produced by <cite>XOR</cite>
would result in formulas that are hard to solve solely due to the size of the formula.
Fortunately, one can encode both <cite>atMostOne</cite> and <cite>XOR</cite> using a linear number of
clauses using the following trick: In case the sequence consists of more than four literals,
split the constraint into two such that the first uses the first three literals of the sequence appended by a new literal <span class="math notranslate nohighlight">\(y\)</span>, while
the second uses the remainder of the sequence appended by the literal <span class="math notranslate nohighlight">\(\lnot y\)</span>.
For example, <cite>atMostOne</cite><span class="math notranslate nohighlight">\((l_1,\dots,l_n)\)</span> is split into <cite>atMostOne</cite><span class="math notranslate nohighlight">\((l_1,l_2,l_3,y)\)</span>
and <cite>atMostOne</cite><span class="math notranslate nohighlight">\((l_4,\dots, l_n,\lnot y)\)</span>. The splitting is repeated until none of the
constraints has a sequence longer than four.</p>
<p>Another approach to encode a problem into propositional logic is to express it
first as another NP-complete problem and afterwards transform the result into
propositional logic. Let’s demonstrate this approach for graph coloring.
The graph coloring problem asks whether a given graph can be colored with
a given number of colors such that adjacent vertices have different colors. Graph coloring
problems can be easily encoded into a propositional formula, and SAT solvers
can frequently solve these formulas efficiently.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> and <span class="math notranslate nohighlight">\(k\)</span> colors, the encoding uses <span class="math notranslate nohighlight">\(k|V|\)</span> Boolean
variables <span class="math notranslate nohighlight">\(x_{i,j}\)</span> with <span class="math notranslate nohighlight">\(i \in \{1,\dots,|V|\}\)</span> and <span class="math notranslate nohighlight">\(j \in \{1,\dots,k\}\)</span>
and <span class="math notranslate nohighlight">\(|V| +k|E|\)</span> clauses.
If <span class="math notranslate nohighlight">\(x_{i,j}\)</span> is assigned to true it means that vertex <span class="math notranslate nohighlight">\(i\)</span> is assigned color <span class="math notranslate nohighlight">\(j\)</span>.
The clauses encode two constraints: each vertex has a color and adjacent vertices have
a different color. The first constraint can be encoded using a single clause per vertex. For example,
for vertex <span class="math notranslate nohighlight">\(i\)</span>, we have the following clause: <span class="math notranslate nohighlight">\(x_{i,1} \lor \dots \lor x_{i,k}\)</span>.
The second constraint requires <span class="math notranslate nohighlight">\(k\)</span>
binary clauses. For example, for an edge between vertices <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(i\)</span>, we have the
following binary clauses: <span class="math notranslate nohighlight">\((\lnot x_{h,1} \lor \lnot x_{i,1}) \land \dots \land (\lnot x_{h,k} \lor \lnot x_{i,k})\)</span>.</p>
<p>The CNF formulas for a triangle (a fully connected graph with three vertices) for two colors and
three colors is shown below. The first one is unsatisfiable, while the second one is satisfiable.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">triangleCnf2</span> <span class="o">:=</span> <span class="bp">!</span><span class="n">cnf</span><span class="o">{</span>
  <span class="n">x11</span> <span class="n">x12</span><span class="o">,</span>
  <span class="n">x21</span> <span class="n">x22</span><span class="o">,</span>
  <span class="n">x31</span> <span class="n">x32</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x11</span> <span class="bp">-</span><span class="n">x21</span><span class="o">,</span> <span class="bp">-</span><span class="n">x12</span> <span class="bp">-</span><span class="n">x22</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x11</span> <span class="bp">-</span><span class="n">x31</span><span class="o">,</span> <span class="bp">-</span><span class="n">x12</span> <span class="bp">-</span><span class="n">x32</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x21</span> <span class="bp">-</span><span class="n">x31</span><span class="o">,</span> <span class="bp">-</span><span class="n">x22</span> <span class="bp">-</span><span class="n">x32</span>
<span class="o">}</span>

<span class="kd">def</span> <span class="n">triangleCnf3</span> <span class="o">:=</span> <span class="bp">!</span><span class="n">cnf</span><span class="o">{</span>
  <span class="n">x11</span> <span class="n">x12</span> <span class="n">x13</span><span class="o">,</span>
  <span class="n">x21</span> <span class="n">x22</span> <span class="n">x23</span><span class="o">,</span>
  <span class="n">x31</span> <span class="n">x32</span> <span class="n">x33</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x11</span> <span class="bp">-</span><span class="n">x21</span><span class="o">,</span> <span class="bp">-</span><span class="n">x12</span> <span class="bp">-</span><span class="n">x22</span><span class="o">,</span> <span class="bp">-</span><span class="n">x13</span> <span class="bp">-</span><span class="n">x23</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x11</span> <span class="bp">-</span><span class="n">x31</span><span class="o">,</span> <span class="bp">-</span><span class="n">x12</span> <span class="bp">-</span><span class="n">x32</span><span class="o">,</span> <span class="bp">-</span><span class="n">x13</span> <span class="bp">-</span><span class="n">x33</span><span class="o">,</span>
  <span class="bp">-</span><span class="n">x21</span> <span class="bp">-</span><span class="n">x31</span><span class="o">,</span> <span class="bp">-</span><span class="n">x22</span> <span class="bp">-</span><span class="n">x32</span><span class="o">,</span> <span class="bp">-</span><span class="n">x23</span> <span class="bp">-</span><span class="n">x23</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Many problems, such as scheduling and planning, can naturally be expressed as a graph coloring problem. We can then transform the graph coloring
problem into a SAT problem using the encoding described above.</p>
<p>An example of a problem that can be expressed as a graph coloring problem is the popular puzzle Sudoku:
Place number is a grid consisting of nine squares subdivided into a further nine smaller squares in such a way that every
number appears once in each horizontal line, vertical line, and square. This puzzle can be seen as a graph coloring
where each small square is a vertex, and vertices are connected if and only if the corresponding small squares occur
the the same horizontal line, vertical line, or square. Below is one of the hardest sudoko puzzles with only 17 given numbers.
It can be easily solved using a SAT solver.</p>
<a class="reference internal image-reference" href="_images/sudoku.png"><img alt="sudoku puzzle" class="align-center" src="_images/sudoku.png" style="width: 200px;" /></a>
</div>
<div class="section" id="exercise-grid-coloring">
<h2><span class="section-number">8.3. </span>Exercise: grid coloring<a class="headerlink" href="#exercise-grid-coloring" title="Permalink to this headline">¶</a></h2>
<p>Ramsey Theory deals with patterns that cannot be avoided indefinitely. In
this exercise we focus on a pattern of coloring a <span class="math notranslate nohighlight">\(n \times m\)</span> grid with <span class="math notranslate nohighlight">\(k\)</span> colors:
Consider all possible rectangles within the grid whose length and width are
at least 2. Try to color the grid using <span class="math notranslate nohighlight">\(k\)</span> colors so that no such rectangle
has the same color for its four corners. When this is possible, we say that
the <span class="math notranslate nohighlight">\(n \times m\)</span> grid is <span class="math notranslate nohighlight">\(k\)</span>-colorable while avoiding monochromatic rectangles. When
using <span class="math notranslate nohighlight">\(k\)</span> colors, it is relatively easy to construct a valid <span class="math notranslate nohighlight">\(k^2 \times k^2\)</span> grid.
However, only few valid grids that are larger than <span class="math notranslate nohighlight">\(k^2 \times k^2\)</span> are known. An
example of a valid <span class="math notranslate nohighlight">\(3\)</span>-coloring of the <span class="math notranslate nohighlight">\(9 \times 9\)</span> grid is shown below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0 0 1 1 2 2 0 1 2
2 0 0 1 1 2 2 0 1
1 2 0 0 1 1 2 2 0
0 1 2 0 0 1 1 2 2
2 0 1 2 0 0 1 1 2
2 2 0 1 2 0 0 1 1
1 2 2 0 1 2 0 0 1
1 1 2 2 0 1 2 0 0
0 1 1 2 2 0 1 2 0
</pre></div>
</div>
<p>Step 1. Encode whether there exists a coloring of the grid using three colors
so that no such rectangle has the same color for its four corners. The
encoding requires two types of constraints. First, each square needs to have
at least one color. Second, if four squares form the corners of a rectangle,
then they cannot have the same color.</p>
<p>Step 2. Solve the encoding for a <span class="math notranslate nohighlight">\(10 \times 10\)</span> grid using a SAT solver and decode the
solution into a valid coloring. Show the output of the SAT solver and a valid
3-coloring similar to the one above of the <span class="math notranslate nohighlight">\(9 \times 9\)</span> grid.</p>
<p>Note that any valid coloring can be turned into another valid coloring by
permuting the rows, columns, or colors. However, such valid colorings are
isomorphic.</p>
<p>Step 3. Use the tool Shatter to (partially) break the symmetries of the
encoding in Step 1 and count the number of solutions of the resulting
formula.</p>
</div>
<div class="section" id="exercise-numbermind">
<h2><span class="section-number">8.4. </span>Exercise: NumberMind<a class="headerlink" href="#exercise-numbermind" title="Permalink to this headline">¶</a></h2>
<p>The game Number Mind is a variant of the well known game Master Mind.</p>
<p>Instead of colored pegs, you have to guess a secret sequence of digits.
After each guess you’re only told in how many places you’ve guessed the
correct digit. So, if the sequence was 1234 and you guessed 2036, you’d
be told that you have one correct digit; however, you would NOT be told
that you also have another digit in the wrong place.</p>
<p>For instance, given the following guesses for a 5-digit secret sequence,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>90342 ;2 correct
70794 ;0 correct
39458 ;2 correct
34109 ;1 correct
51545 ;2 correct
12531 ;1 correct
</pre></div>
</div>
<p>The correct sequence 39542 is unique.</p>
<p>Based on the following guesses,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>5616185650518293 ;2 correct
3847439647293047 ;1 correct
5855462940810587 ;3 correct
9742855507068353 ;3 correct
4296849643607543 ;3 correct
3174248439465858 ;1 correct
4513559094146117 ;2 correct
7890971548908067 ;3 correct
8157356344118483 ;1 correct
2615250744386899 ;2 correct
8690095851526254 ;3 correct
6375711915077050 ;1 correct
6913859173121360 ;1 correct
6442889055042768 ;2 correct
2321386104303845 ;0 correct
2326509471271448 ;2 correct
5251583379644322 ;2 correct
1748270476758276 ;3 correct
4895722652190306 ;1 correct
3041631117224635 ;3 correct
1841236454324589 ;3 correct
2659862637316867 ;2 correct
</pre></div>
</div>
<p>Find the unique 16-digit secret sequence.</p>
<p>Step 1. Encode finding the correct sequence as a SAT problem.
Use Boolean variables <span class="math notranslate nohighlight">\(x_{i,j}\)</span> which are true if and only if
at position i there is the digit j. The encoding consists of
two parts: i) at each position there is exactly one digit; and
ii) the correct number of digits from each line is matched.
The encoding should <em>only</em> use these <span class="math notranslate nohighlight">\(x_{i,j}\)</span> variables.</p>
<p>Step 2. Show that the correct sequence is unique. Which clause
do you need to add to the encoding of Step 1?</p>
<p>Step 3. Reduce the size of the encoding by replacing the
cardinality constraints from ii) in Step 1 by using the
Sinz encoding.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="deduction_for_propositional_logic.html" class="btn btn-neutral float-right" title="9. Deduction for Propositional Logic" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="decision_procedures_for_propositional_logic.html" class="btn btn-neutral float-left" title="7. Decision Procedures" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Jeremy Avigad, Seul Baek, Marijn J. H. Heule, Wojciech Nawrocki, and Emre Yolcu.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>