<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>13. Equality and Induction in Lean &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="14. Decision Procedures for Arithmetic" href="decision_procedures_for_arithmetic.html" />
    <link rel="prev" title="12. Decision Procedures for Equality" href="decision_procedures_for_equality.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Logic and Mechanized Reasoning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_propositional_logic.html">8. Proof Systems for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_proof_assistant.html">9. Using Lean as a Proof Assistant</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">11. Implementing First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_equality.html">12. Decision Procedures for Equality</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">13. Equality and Induction in Lean</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#equational-reasoning">13.1. Equational reasoning</a></li>
<li class="toctree-l2"><a class="reference internal" href="#induction">13.2. Induction</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_arithmetic.html">14. Decision Procedures for Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">15. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_first_order_logic.html">16. Proof Systems for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">17. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="beyond_first_order_logic.html">18. Beyond First-Order Logic</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><span class="section-number">13. </span>Equality and Induction in Lean</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/equality_and_induction_in_lean.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="equality-and-induction-in-lean">
<span id="chapter-equality-and-induction-in-lean"></span><h1><span class="section-number">13. </span>Equality and Induction in Lean<a class="headerlink" href="#equality-and-induction-in-lean" title="Permalink to this heading"></a></h1>
<p>With the introduction of first-order logic, we have come a long way toward modeling full-blown
mathematical and computational reasoning reasoning.
Lean’s internal logic subsumes first-order logic, which means that one can write down terms
the describe objects, express relationships between them, and prove things about them.
For example, if <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>
are variables ranging over integers and <code class="docutils literal notranslate"><span class="pre">xs</span></code> and <code class="docutils literal notranslate"><span class="pre">ys</span></code> are variables ranging over lists of
integers, the expression <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">+</span> <span class="pre">3</span></code>
is a term denoting an integer and the expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">::</span> <span class="pre">xs</span> <span class="pre">++</span> <span class="pre">[3]</span> <span class="pre">++</span> <span class="pre">ys</span></code> is a term denoting a list
of integers. In Lean, the expressions <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">3</span></code>, and <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">∈</span> <span class="pre">xs</span></code> are
<em>propositions</em> that say that <code class="docutils literal notranslate"><span class="pre">x</span></code> is less than <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">+</span> <span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">+</span> <span class="pre">3</span></code>, and
<code class="docutils literal notranslate"><span class="pre">x</span></code> is an element of the list <code class="docutils literal notranslate"><span class="pre">xs</span></code>, respectively. The symbols <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">=</span></code>, and <code class="docutils literal notranslate"><span class="pre">∈</span></code> denote
binary relations, since they express a relationship between the terms on either side.</p>
<section id="equational-reasoning">
<span id="section-equational-reasoning-in-lean"></span><h2><span class="section-number">13.1. </span>Equational reasoning<a class="headerlink" href="#equational-reasoning" title="Permalink to this heading"></a></h2>
<p>Mathematically, the most fundamental relation is the equality relationship.
Equality satisfies two axiomatic properties: first, everything is equal to itself, and
second, equal terms can be substituted for one another. In Lean, these are implemented by the
tactics <code class="docutils literal notranslate"><span class="pre">rfl</span></code> and <code class="docutils literal notranslate"><span class="pre">rw</span></code>, respectively. The first is short for <code class="docutils literal notranslate"><span class="pre">reflexivity</span></code>, and the
second is short for <code class="docutils literal notranslate"><span class="pre">rewrite</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
</pre></div>
</div>
<p>In the second example, the rewrite tactic replaces <code class="docutils literal notranslate"><span class="pre">b</span></code> by <code class="docutils literal notranslate"><span class="pre">c</span></code> in the goal and then
automatically applies reflexivity to finish it off.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">rw</span></code> tactic takes a list of identities and rewrites with them one at a time.
You can use a left arrow to indicate that the tactic should use an equation in the
reverse direction:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">d</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">e</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">f</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="o">,</span> <span class="bp">←</span><span class="n">h2</span><span class="o">,</span> <span class="n">h3</span><span class="o">]</span>
</pre></div>
</div>
<p>Notice that even common properties like the symmetry and transitivity of equality can
be reduced to the substitution property and reflexivity.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">c</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">]</span>
</pre></div>
</div>
<p>You can also rewrite with general identities. In Lean, when you write <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">*</span> <span class="pre">c</span></code>, parentheses
associate to the left, so the expression is interpreted as <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">*</span> <span class="pre">b)</span> <span class="pre">*</span> <span class="pre">c</span></code>. The identities
<code class="docutils literal notranslate"><span class="pre">mul_assoc</span></code>, <code class="docutils literal notranslate"><span class="pre">mul_comm</span></code>, and <code class="docutils literal notranslate"><span class="pre">mul_left_comm</span></code> can be used to move the parentheses around.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="o">(</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">))</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">mul_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">mul_left_comm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">))</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="bp">←</span><span class="n">mul_assoc</span><span class="o">]</span>
</pre></div>
</div>
<p>Notice that your cursor after the comma in the list of the identities shows that goal
at the point, so you can step through a sequence of rewrites to see what is happening.</p>
<p>You can specialize identities at particular arguments. For example, <code class="docutils literal notranslate"><span class="pre">mul_comm</span> <span class="pre">c</span> <span class="pre">a</span></code> is the
identity <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">*</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">c</span></code>, and <code class="docutils literal notranslate"><span class="pre">mul_comm</span> <span class="pre">c</span></code> is the identity <code class="docutils literal notranslate"><span class="pre">∀</span> <span class="pre">x,</span> <span class="pre">c</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">c</span></code>.
Notice that Lean uses the same syntax for applying a theorem to arguments as it does for
applying a function to arguments. In the underlying foundation, the two are instances
of the same thing.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">mul_assoc</span> <span class="n">b</span> <span class="n">a</span> <span class="n">c</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span> <span class="n">a</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">d</span> <span class="bp">=</span> <span class="n">e</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h2</span><span class="o">,</span> <span class="n">h3</span><span class="o">,</span> <span class="n">h1</span><span class="o">,</span> <span class="n">add_comm</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">add_assoc</span><span class="o">]</span>
</pre></div>
</div>
<p>You can also use <code class="docutils literal notranslate"><span class="pre">rw</span></code> with the <code class="docutils literal notranslate"><span class="pre">at</span></code> modifier to rewrite at a particular hypothesis.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">e</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="o">]</span> <span class="n">at</span> <span class="n">h2</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">h2</span><span class="o">,</span> <span class="n">h3</span><span class="o">,</span> <span class="bp">←</span><span class="n">add_assoc</span><span class="o">,</span> <span class="n">add_comm</span> <span class="n">c</span><span class="o">]</span>
</pre></div>
</div>
<p>Sometimes, you only want to replace a single occurrence of a term. You can use the <code class="docutils literal notranslate"><span class="pre">nth_rw</span></code>
tactic for that.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">nth_rw</span> <span class="mi">1</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">nth_rw</span> <span class="pre">1</span> <span class="pre">[h]</span></code> applies the rewrite <code class="docutils literal notranslate"><span class="pre">h</span></code> to the first occurrence of <code class="docutils literal notranslate"><span class="pre">a</span></code>
in the conclusion.</p>
<p>Mathlib has specialized tactics for proving particular types of equations. For example,
<code class="docutils literal notranslate"><span class="pre">norm_num</span></code> can be used for concrete calculations and <code class="docutils literal notranslate"><span class="pre">ring</span></code> can be used to prove
identities involving addition, subtraction, multiplication, integer coefficients, and
natural number exponents.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="mi">123</span> <span class="bp">*</span> <span class="mi">345</span> <span class="bp">=</span> <span class="mi">42435</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">norm_num</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span><span class="bp">*</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">ring</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">ring</span>
</pre></div>
</div>
<p>Rewriting with the name of a function amounts to unfolding the definition, or, if
it is defined by cases, its defining clauses.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">fib</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fib</span> <span class="n">n</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">fib</span><span class="o">,</span> <span class="n">fib</span><span class="o">]</span>
  <span class="n">ring</span>
</pre></div>
</div>
<p>Finally, Lean will let you rewrite with propositional equivalences.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="o">(</span><span class="n">not_and_or</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">Q</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">not_not</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">not_and_or</span><span class="o">,</span> <span class="n">not_not</span><span class="o">]</span>
</pre></div>
</div>
<p>Sometimes Lean will surprise you by not making you prove something you think you should have to.
When it needs to, Lean will unfold definitions and apply computational rules to simplify
an expression, and so it can often treat syntactically different expressions as being the
same. In the next example, Lean unfolds the definition of addition and determines <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">0</span></code>
and <code class="docutils literal notranslate"><span class="pre">n</span></code> are <em>definitionally equal</em>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rfl</span>
</pre></div>
</div>
<p>Replacing <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">0</span></code> by <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">+</span> <span class="pre">n</span></code> does not work, however. Definitional equality
is subtle and we will discuss it in detail here, but it might be helpful to know that Lean can
generally unfold a recursive definition or a definition on cases when it has to.
This feature of Lean is probably at play when you find that <code class="docutils literal notranslate"><span class="pre">rw</span></code> declares a
goal solved when you thought you had more work to do.</p>
<p>Lean has other automation that can handle equational reasoning, most notably, a tactic
called <code class="docutils literal notranslate"><span class="pre">simp</span></code> that simplifies expressions using a database of identities that have been
marked for its use.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">fib</span> <span class="mi">8</span> <span class="bp">=</span> <span class="mi">21</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">fib</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">simp</span>
</pre></div>
</div>
<p>As usual, hovering over <code class="docutils literal notranslate"><span class="pre">simp</span></code> provides more information about how it works.
In the real world, you should feel free to use automation like <code class="docutils literal notranslate"><span class="pre">simp</span></code> with reckless abandon.
The more automation the better! That’s what this course is all about. But for the
exercises
we will ask you to do proofs using more elementary tactics — for example, using only
the <code class="docutils literal notranslate"><span class="pre">rw</span></code> tactic to prove identities — so that you acquire a solid understanding of the
principles of reasoning that they implement.</p>
</section>
<section id="induction">
<span id="section-lean-induction"></span><h2><span class="section-number">13.2. </span>Induction<a class="headerlink" href="#induction" title="Permalink to this heading"></a></h2>
<p>With only equality and the propositional connectives, our vocabulary is limited.
In Lean, it is possible to describe any precise mathematical property or relationship, and,
indeed, a vast number of them are already defined in Mathlib.
But even with just equality and the propositional connectives, we can prove
some interesting theorems, and so we will make a small start on that here.</p>
<p>In <a class="reference internal" href="mathematical_background.html#chapter-mathematical-background"><span class="std std-numref">Chapter 2</span></a> we reviewed the principle
of induction, and we have seen throughout this book that Lean allows us to define inductive
data types and to define functions on those types by structural recursion.
We now introduce Lean’s <code class="docutils literal notranslate"><span class="pre">induction</span></code> tactic.
In the next example, we define the function <code class="docutils literal notranslate"><span class="pre">sum_up_to</span> <span class="pre">n</span></code> that sums the numbers
up to and including <code class="docutils literal notranslate"><span class="pre">n</span></code>, and we use induction to prove that it is equal to
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">(n</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">/</span> <span class="pre">2</span></code> for every <code class="docutils literal notranslate"><span class="pre">n</span></code>.
(We state this in a roundabout way to avoid having to deal with division.)</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">sum_up_to</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">sum_up_to</span> <span class="n">n</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">sum_up_to</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">sum_up_to</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">sum_up_to</span><span class="o">,</span> <span class="n">mul_add</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>
      <span class="n">ring</span>
</pre></div>
</div>
<p>As usual, hovering over <code class="docutils literal notranslate"><span class="pre">induction</span></code> gives you more information about its syntax and usage,
including variations. Here the two cases are named <code class="docutils literal notranslate"><span class="pre">zero</span></code> and <code class="docutils literal notranslate"><span class="pre">succ</span></code>, corresponding to
the two canonical ways of constructing a natural number. In the <code class="docutils literal notranslate"><span class="pre">succ</span></code> case
we name the variable <code class="docutils literal notranslate"><span class="pre">n</span></code> and the inductive hypothesis <code class="docutils literal notranslate"><span class="pre">ih</span></code>.
It is unfortunate that the two cases of the induction use <code class="docutils literal notranslate"><span class="pre">Nat.zero</span></code> and <code class="docutils literal notranslate"><span class="pre">Nat.succ</span> <span class="pre">n</span></code>
instead of the (definitionally equal) expressions <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code>, respectively, but the
equations <code class="docutils literal notranslate"><span class="pre">Nat.zero_eq</span></code> and <code class="docutils literal notranslate"><span class="pre">Nat.succ_eq_add_one</span></code> fix that. Rewriting with
<code class="docutils literal notranslate"><span class="pre">sum_up_to</span></code> unfolds the definition, and hovering over <code class="docutils literal notranslate"><span class="pre">mul_add</span></code> shows that it
distributes the multiplication over addition so that we can apply the inductive hypothesis.
Remember that you can step through the rewrites in the infoview window by moving your cursor
down the list. Here is another example of a proof by induction:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">sum_odds</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">sum_odds</span> <span class="n">n</span>

<span class="kd">theorem</span> <span class="n">sum_odds_eq_square</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">sum_odds</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">^</span><span class="mi">2</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">sum_odds</span><span class="o">,</span> <span class="n">pow_two</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">sum_odds</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>
      <span class="n">ring</span>
</pre></div>
</div>
<p>In fact, in Lean’s library, addition and multiplication on the natural numbers are defined
recursively and their properties are proved using induction. In the example below,
we define addition with the name <code class="docutils literal notranslate"><span class="pre">add'</span></code> to avoid clashing with names in the library,
and we open the <code class="docutils literal notranslate"><span class="pre">Nat</span></code> namespace to shorten names like <code class="docutils literal notranslate"><span class="pre">succ</span></code> and <code class="docutils literal notranslate"><span class="pre">zero_eq</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span> <span class="n">Nat</span>

<span class="kd">def</span> <span class="n">add&#39;</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">m</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">add&#39;</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="kd">theorem</span> <span class="n">zero_add&#39;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">add&#39;</span> <span class="mi">0</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add&#39;</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add&#39;</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">succ_add&#39;</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">add&#39;</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add&#39;</span> <span class="n">m</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add&#39;</span><span class="o">,</span> <span class="n">add&#39;</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">add&#39;</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">add&#39;</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">add&#39;_comm</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">add&#39;</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">add&#39;</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">m</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">zero_add&#39;</span><span class="o">,</span> <span class="n">add&#39;</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="n">m</span> <span class="n">ih</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">add&#39;</span><span class="o">,</span> <span class="n">succ_add&#39;</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>
</pre></div>
</div>
<p>Lean supports induction on any inductive type, not just the natural numbers.
Remember that Lean’s core library defines the <code class="docutils literal notranslate"><span class="pre">List</span></code> data type
and notation for it.
In the example below, we open the namespace, declare some variables, and
confirm the recursive definition of the append function.
The proofs by reflexivity show that <code class="docutils literal notranslate"><span class="pre">nil_append</span></code> and <code class="docutils literal notranslate"><span class="pre">cons_append</span></code> are definitionally
true, which is to say, they following by unfolding the definition of <code class="docutils literal notranslate"><span class="pre">append</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span> <span class="n">List</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="n">cs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">[]</span> <span class="bp">++</span> <span class="n">as</span> <span class="bp">=</span> <span class="n">as</span> <span class="o">:=</span> <span class="n">nil_append</span> <span class="n">as</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">as</span><span class="o">)</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">::</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cons_append</span> <span class="n">a</span> <span class="n">as</span> <span class="n">bs</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">[]</span> <span class="bp">++</span> <span class="n">as</span> <span class="bp">=</span> <span class="n">as</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">as</span><span class="o">)</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">::</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">variable</span></code> command does not do anything substantial.
It tells Lean that when the corresponding identifiers are used
in definitions and theorems that follow,
they should be interpreted as arguments to those theorems and proofs,
with the indicated types.
The curly brackets around the declaration <code class="docutils literal notranslate"><span class="pre">α</span> <span class="pre">:</span> <span class="pre">Type</span></code> indicate that that
argument is meant to be <em>implicit</em>, which is to say,
users do not have to write it explicitly.
Rather, Lean is expected to infer it from the context.</p>
<p>The library stores the theorems <code class="docutils literal notranslate"><span class="pre">[]</span> <span class="pre">++</span> <span class="pre">as</span></code> and
<code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">::</span> <span class="pre">as)</span> <span class="pre">++</span> <span class="pre">bs</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">::</span> <span class="pre">(as</span> <span class="pre">++</span> <span class="pre">bs)</span></code> under the names <code class="docutils literal notranslate"><span class="pre">nil_append</span></code>
and <code class="docutils literal notranslate"><span class="pre">cons_append</span></code>, respectively.
You can see the statements by writing <code class="docutils literal notranslate"><span class="pre">#check</span> <span class="pre">nil_append</span></code> and <code class="docutils literal notranslate"><span class="pre">#check</span> <span class="pre">cons_append</span></code>.
Remember that we took these to be the defining equations for the
<code class="docutils literal notranslate"><span class="pre">append</span></code> function in <a class="reference internal" href="mathematical_background.html#section-generalized-induction-and-recursion"><span class="std std-numref">Section 2.3</span></a>.</p>
<p>Lean’s library also proves <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">++</span> <span class="pre">[]</span></code> under the name <code class="docutils literal notranslate"><span class="pre">append_nil</span></code>,
but to illustrate how proofs like this go, we will prove it again
under the name <code class="docutils literal notranslate"><span class="pre">append_nil'</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">append_nil&#39;</span> <span class="o">:</span> <span class="n">as</span> <span class="bp">++</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">as</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">as</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nil_append</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">cons_append</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>
</pre></div>
</div>
<p>Even though the proof is straightforward, some cleverness is needed to decide which variable
to induct on. The fact that <code class="docutils literal notranslate"><span class="pre">append</span></code> is defined by recursion on the first argument makes
<code class="docutils literal notranslate"><span class="pre">as</span></code> the natural choice. Similarly, we can prove the associativity of the <code class="docutils literal notranslate"><span class="pre">append</span></code> function.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">append_assoc&#39;</span> <span class="o">:</span> <span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">=</span> <span class="n">as</span> <span class="bp">++</span> <span class="o">(</span><span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">as</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nil_append</span><span class="o">,</span> <span class="n">nil_append</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">cons_append</span><span class="o">,</span> <span class="n">cons_append</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="n">cons_append</span><span class="o">]</span>
</pre></div>
</div>
<p>Sometimes proving even simple identities can be challenging. Lean defines the list <code class="docutils literal notranslate"><span class="pre">reverse</span></code>
function using a tail recursive auxiliary function <code class="docutils literal notranslate"><span class="pre">reverseAux</span> <span class="pre">as</span> <span class="pre">bs</span></code>,
which in turn uses an accumulator to append the reverse of <code class="docutils literal notranslate"><span class="pre">as</span></code> to <code class="docutils literal notranslate"><span class="pre">bs</span></code></p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">reverse</span> <span class="n">as</span> <span class="bp">=</span> <span class="n">reverseAux</span> <span class="n">as</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">reverseAux</span> <span class="o">[]</span> <span class="n">bs</span> <span class="bp">=</span> <span class="n">bs</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">reverseAux</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">as</span><span class="o">)</span> <span class="n">bs</span> <span class="bp">=</span> <span class="n">reverseAux</span> <span class="n">as</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">bs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
<p>If you try proving <code class="docutils literal notranslate"><span class="pre">reverse</span> <span class="pre">(as</span> <span class="pre">++</span> <span class="pre">bs)</span> <span class="pre">=</span> <span class="pre">reverse</span> <span class="pre">bs</span> <span class="pre">++</span> <span class="pre">reverse</span> <span class="pre">as</span></code>, you’ll find that
it isn’t easy. It turns out to be best to prove the following two identities first:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">reverseAux_append</span> <span class="o">:</span> <span class="n">reverseAux</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span><span class="o">)</span> <span class="n">cs</span> <span class="bp">=</span> <span class="n">reverseAux</span> <span class="n">bs</span> <span class="o">(</span><span class="n">reverseAux</span> <span class="n">as</span> <span class="n">cs</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">as</span> <span class="n">generalizing</span> <span class="n">cs</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nil_append</span><span class="o">,</span> <span class="n">reverseAux</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">cons_append</span><span class="o">,</span> <span class="n">reverseAux</span><span class="o">,</span> <span class="n">reverseAux</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">reverseAux_append&#39;</span> <span class="o">:</span> <span class="n">reverseAux</span> <span class="n">as</span> <span class="o">(</span><span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span><span class="o">)</span> <span class="bp">=</span> <span class="n">reverseAux</span> <span class="n">as</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">as</span> <span class="n">generalizing</span> <span class="n">bs</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">reverseAux</span><span class="o">,</span> <span class="n">reverseAux</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">reverseAux</span><span class="o">,</span> <span class="n">reverseAux</span><span class="o">,</span> <span class="bp">←</span><span class="n">cons_append</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">generalizing</span></code> clause in the two induction tells Lean that the inductive hypothesis
should be applied to any choice of second parameter, not just the one from the
previous step. Mathematically, what is going on is that we are proving by induction
on <code class="docutils literal notranslate"><span class="pre">as</span></code> that the identity holds <em>for every choice of</em> the second parameter.
This is needed because the recursive step of <code class="docutils literal notranslate"><span class="pre">reverseAux</span></code> uses a different parameter in the
recursive call.
You should try deleting the <code class="docutils literal notranslate"><span class="pre">generalizing</span></code> clause to see what goes
wrong when we omit it.</p>
<p>With those facts in hand, we have the identity we are after:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">reverse_append</span> <span class="o">:</span> <span class="n">reverse</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span><span class="o">)</span> <span class="bp">=</span> <span class="n">reverse</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">reverse</span> <span class="n">as</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">reverse</span><span class="o">,</span> <span class="n">reverseAux_append</span><span class="o">,</span> <span class="n">reverse</span><span class="o">,</span> <span class="bp">←</span><span class="n">reverseAux_append&#39;</span><span class="o">,</span> <span class="n">nil_append</span><span class="o">,</span>
      <span class="n">reverse</span><span class="o">]</span>
</pre></div>
</div>
<p>As a similar exercise, we encourage you to prove that for any list <code class="docutils literal notranslate"><span class="pre">as</span></code>,
<code class="docutils literal notranslate"><span class="pre">reverse</span> <span class="pre">(reverse</span> <span class="pre">as)</span> <span class="pre">=</span> <span class="pre">as</span></code>. You can do this by proving suitable lemmas about <code class="docutils literal notranslate"><span class="pre">reverseAux</span></code>.</p>
<p>Let’s consider one last example, which brings us closer to the kinds of logical operations
that we have been implementing in Lean.
We have often relied on the fact that when we evaluate
a propositional formula relative to a truth assignment, the resulting truth value only depends
on the variables that occur in the formula.
We can formalize in Lean what it means to say that a variable <code class="docutils literal notranslate"><span class="pre">v</span></code> occurs in <code class="docutils literal notranslate"><span class="pre">A</span></code> in Lean
as follows:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">namespace</span> <span class="n">PropForm</span>

<span class="kd">def</span> <span class="n">Occurs</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="kt">Prop</span>
  <span class="bp">|</span> <span class="n">tr</span> <span class="bp">=&gt;</span> <span class="n">False</span>
  <span class="bp">|</span> <span class="n">fls</span> <span class="bp">=&gt;</span> <span class="n">False</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="n">w</span> <span class="bp">=&gt;</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">w</span>
  <span class="bp">|</span> <span class="n">neg</span> <span class="n">A</span> <span class="bp">=&gt;</span> <span class="n">Occurs</span> <span class="n">v</span> <span class="n">A</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">Occurs</span> <span class="n">v</span> <span class="n">A</span> <span class="bp">∨</span> <span class="n">Occurs</span> <span class="n">v</span> <span class="n">B</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">Occurs</span> <span class="n">v</span> <span class="n">A</span> <span class="bp">∨</span> <span class="n">Occurs</span> <span class="n">v</span> <span class="n">B</span>
  <span class="bp">|</span> <span class="n">impl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">Occurs</span> <span class="n">v</span> <span class="n">A</span> <span class="bp">∨</span> <span class="n">Occurs</span> <span class="n">v</span> <span class="n">B</span>
  <span class="bp">|</span> <span class="n">biImpl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="n">Occurs</span> <span class="n">v</span> <span class="n">A</span> <span class="bp">∨</span> <span class="n">Occurs</span> <span class="n">v</span> <span class="n">B</span>
</pre></div>
</div>
<p>Here we follow Lean’s convention of using capital letters for propositions, properties, and
predicates. We could just as well have defined a function <code class="docutils literal notranslate"><span class="pre">vars</span> <span class="pre">:</span> <span class="pre">PropForm</span> <span class="pre">→</span> <span class="pre">Finset</span> <span class="pre">String</span></code>
that returns the finite set of variables contained in a propositional formula, in which case
<code class="docutils literal notranslate"><span class="pre">Occurs</span> <span class="pre">v</span> <span class="pre">A</span></code> would be equivalent to <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">∈</span> <span class="pre">vars</span> <span class="pre">A</span></code>.</p>
<p>In the past, we have also defined an evaluation function for propositional formulas relative
to a partial truth assignment, an element of type <code class="docutils literal notranslate"><span class="pre">PropAssignment</span></code>.
Here, to simplify the discussion, we will use total assignments to propositional variables,
represented as functions of type <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">→</span> <span class="pre">Bool</span></code>.
The evaluation function for propositional formulas is then defined straightforwardly as follows.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">eval</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:</span> <span class="n">PropForm</span> <span class="bp">→</span> <span class="n">Bool</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">v</span> <span class="n">s</span>
  <span class="bp">|</span> <span class="n">tr</span> <span class="bp">=&gt;</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">fls</span> <span class="bp">=&gt;</span> <span class="n">false</span>
  <span class="bp">|</span> <span class="n">neg</span> <span class="n">A</span> <span class="bp">=&gt;</span> <span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">impl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">biImpl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">B</span><span class="o">))</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">B</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">v</span> <span class="n">A</span><span class="o">))</span>
</pre></div>
</div>
<p>The following theorem formalizes the statement that changing the value of a truth assignment
at a variable that does not occur in a formula does not change the value of the formula.
The proof is mainly a matter of unfolding definitions and checking all the cases.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variable</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">PropForm</span><span class="o">)</span> <span class="o">(</span><span class="n">τ</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">eval_of_not_occurs</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">Occurs</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">A.eval</span> <span class="o">(</span><span class="k">fun</span> <span class="n">w</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">w</span> <span class="k">then</span> <span class="n">b</span> <span class="k">else</span> <span class="n">τ</span> <span class="n">w</span><span class="o">)</span> <span class="bp">=</span> <span class="n">A.eval</span> <span class="n">τ</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">A</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="n">s</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Occurs</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">if_neg</span> <span class="n">h</span><span class="o">,</span> <span class="n">eval</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">tr</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">eval</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">fls</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">eval</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">neg</span> <span class="n">A</span> <span class="n">ihA</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">eval</span><span class="o">]</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Occurs</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">ihA</span> <span class="n">h</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ihA</span> <span class="n">ihB</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Occurs</span><span class="o">,</span> <span class="n">not_or</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">hA</span><span class="o">,</span> <span class="n">hB</span><span class="o">⟩</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">eval</span><span class="o">,</span> <span class="n">ihA</span> <span class="n">hA</span><span class="o">,</span> <span class="n">ihB</span> <span class="n">hB</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ihA</span> <span class="n">ihB</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Occurs</span><span class="o">,</span> <span class="n">not_or</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">hA</span><span class="o">,</span> <span class="n">hB</span><span class="o">⟩</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">eval</span><span class="o">,</span> <span class="n">ihA</span> <span class="n">hA</span><span class="o">,</span> <span class="n">ihB</span> <span class="n">hB</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">impl</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ihA</span> <span class="n">ihB</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Occurs</span><span class="o">,</span> <span class="n">not_or</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">hA</span><span class="o">,</span> <span class="n">hB</span><span class="o">⟩</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">eval</span><span class="o">,</span> <span class="n">ihA</span> <span class="n">hA</span><span class="o">,</span> <span class="n">ihB</span> <span class="n">hB</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">biImpl</span> <span class="n">A</span> <span class="n">B</span> <span class="n">ihA</span> <span class="n">ihB</span> <span class="bp">=&gt;</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">Occurs</span><span class="o">,</span> <span class="n">not_or</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">hA</span><span class="o">,</span> <span class="n">hB</span><span class="o">⟩</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">eval</span><span class="o">,</span> <span class="n">ihA</span> <span class="n">hA</span><span class="o">,</span> <span class="n">ihB</span> <span class="n">hB</span><span class="o">]</span>
</pre></div>
</div>
<p>The theorems <code class="docutils literal notranslate"><span class="pre">if_pos</span> <span class="pre">h</span></code> and <code class="docutils literal notranslate"><span class="pre">if_neg</span> <span class="pre">h</span></code> are used to rewrite an if-then-else expression
given the knowledge <code class="docutils literal notranslate"><span class="pre">h</span></code> that the condition is true or false, respectively.
You should step through the proof and make sure you understand how it works.</p>
<p>Verifying proofs involving logical operations or programming constructs often looks like this,
with lots of straightforwrd cases to check.
Because such checking is tedious, the general practice is to verify only one or two
representative cases in a pen-and-paper proof and claim that the others are “similar.”
This is often a source of bugs, however, since a corner case or subtle difference in one
of the cases and render the claim false.
When formalizing such a theorem, it would be nice if the cases can be checked automatically.
Indeed, in this case Lean’s simplifier reduces the proof to a one-liner:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">Occurs</span> <span class="n">v</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">A.eval</span> <span class="o">(</span><span class="k">fun</span> <span class="n">w</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">v</span> <span class="bp">=</span> <span class="n">w</span> <span class="k">then</span> <span class="n">b</span> <span class="k">else</span> <span class="n">τ</span> <span class="n">w</span><span class="o">)</span> <span class="bp">=</span> <span class="n">A.eval</span> <span class="n">τ</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">A</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">Occurs</span><span class="o">,</span> <span class="n">eval</span><span class="o">,</span> <span class="n">not_or</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">]</span> <span class="n">at</span> <span class="bp">*</span>
</pre></div>
</div>
<p>Lean has even more powerful automation, like <a class="reference external" href="https://github.com/leanprover-community/aesop">Aesop</a>,
that is designed for such purposes.
Working through proofs like the one above by hand is a good way to come to terms with
what we want such automation to do,
and the techniques that we are describing in this course form the basis for writing
such automation.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="decision_procedures_for_equality.html" class="btn btn-neutral float-left" title="12. Decision Procedures for Equality" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="decision_procedures_for_arithmetic.html" class="btn btn-neutral float-right" title="14. Decision Procedures for Arithmetic" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>