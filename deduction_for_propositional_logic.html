<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>8. Deduction for Propositional Logic &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script>window.MathJax = {"loader": {"load": ["[tex]/bussproofs"]}, "tex": {"packages": {"[+]": ["bussproofs"]}, "macros": {"fn": ["\\mathit{#1}", 1], "fa": ["\\forall #1. \\,", 1], "ex": ["\\exists #1. \\,", 1], "bN": "{\\mathbb{N}}", "bZ": "{\\mathbb{Z}}", "bR": "{\\mathbb{R}}", "limplies": "\\to", "liff": "\\leftrightarrow", "proves": "\\vdash", "append": "\\mathbin{+\\mkern-10mu+}", "tval": ["[\\![#1]\\!]", 1], "fCenter": "\\proves", "mdl": ["\\mathfrak{#1}", 1]}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="9. Propositional Logic in Lean" href="propositional_logic_in_lean.html" />
    <link rel="prev" title="7. Using SAT Solvers" href="using_sat_solvers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Logic and Mechanized Reasoning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Deduction for Propositional Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#axiomatic-systems">8.1. Axiomatic systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#resolution">8.2. Resolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementing-resolution">8.3. Implementing resolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#resolution-and-dpll">8.4. Resolution and DPLL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-sequent-calculus">8.5. A sequent calculus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#natural-deduction">8.6. Natural deduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#compactness">8.7. Compactness</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">8.8. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">9. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">11. Implementing First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_first_order_logic.html">12. Decision Procedures for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">13. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="deduction_for_first_order_logic.html">14. Deduction for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">15. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">16. First-Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="beyond_first_order_logic.html">17. Beyond First-Order Logic</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><span class="section-number">8. </span>Deduction for Propositional Logic</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/deduction_for_propositional_logic.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="deduction-for-propositional-logic">
<span id="chapter-deduction-for-propositional-logic"></span><h1><span class="section-number">8. </span>Deduction for Propositional Logic<a class="headerlink" href="#deduction-for-propositional-logic" title="Permalink to this heading"></a></h1>
<p>In the study of computational complexity, a <em>language</em> is a set of strings
over some alphabet. For example, we can consider the language PROP consisting of all
propositional formulas, the language SAT consisting of all satisfiable formulas,
and the language TAUT consisting of all tautologies.
We have seen that SAT and TAUT are both <em>decidable</em>,
which is to say, there is are algorithms to decide membership in those sets.
The P=NP question is precisely the question
as to whether there a polynomial time algorithm for SAT, or, equivalently,
for TAUT.</p>
<p>Still speaking in broad terms, a <em>proof system</em> for a language is a relation <span class="math notranslate nohighlight">\(P(d, x)\)</span>
between strings with the property for any <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(x\)</span> is in the language
if and only if there is a <span class="math notranslate nohighlight">\(d\)</span> such that <span class="math notranslate nohighlight">\(P(d, x)\)</span> holds.
In this case, we say that <span class="math notranslate nohighlight">\(d\)</span> is a <em>proof of membership</em> for <span class="math notranslate nohighlight">\(x\)</span>.
We typically require that checking a proof is easy, say, by requiring that <span class="math notranslate nohighlight">\(P(d, x)\)</span>
runs in polynomial time.
This is often easy to do by putting a lot of information into <span class="math notranslate nohighlight">\(d\)</span>.
NP is the class of languages that have a polynomial time proof system with the additional property
that for every <span class="math notranslate nohighlight">\(x\)</span> in the language, there is a proof of membership <span class="math notranslate nohighlight">\(d\)</span> whose
length is polynomially bounded in the length of <span class="math notranslate nohighlight">\(x\)</span>.
The language SAT is in NP because there are short proofs of satisfiability,
namely, the satisfying assignments.</p>
<p>When it comes to propositional logic, when we talk about proof systems,
we generally mean a proof system for TAUT.
In other words, a proof system for propositional logic is supposed to show that a formula is valid.
It can therefore also be used to establish unsatisfiability, since a formula
<span class="math notranslate nohighlight">\(A\)</span> is unsatisfiable if and only if <span class="math notranslate nohighlight">\(\lnot A\)</span> is valid.</p>
<p>Assuming we have a particular proof system in mind, we write <span class="math notranslate nohighlight">\(\proves A\)</span> to mean
that there is a proof of <span class="math notranslate nohighlight">\(A\)</span>.
Remember that we use <span class="math notranslate nohighlight">\(\models A\)</span> to mean that <span class="math notranslate nohighlight">\(A\)</span> is valid.
The property that <span class="math notranslate nohighlight">\(\proves A\)</span> implies <span class="math notranslate nohighlight">\(\models A\)</span> is known as <em>soundness</em>,
and the property that <span class="math notranslate nohighlight">\(\models A\)</span> implies <span class="math notranslate nohighlight">\(\proves A\)</span> is known as <em>completeness</em>.
We want a proof system for propositional logic to be sound and complete.</p>
<p>Given that the set of tautologies in propositional logic is decidable, why do we need a
proof system?
The complexity of the decision procedures provides one answer:
as far as we know, deciding whether or not something is a tautology takes exponential time
in the worst case.
From a theoretical standpoint, it is not clear whether proof systems can do substantially better;
the question as to whether there is a polynomial time polynomially-bounded proof system
for propositional logic is equivalent to the question as to whether NP = coNP,
which is an open question.
But, in practice, checking a proof is usually much more efficient than determining that
something is a tautology from scratch.</p>
<p>Another concern is reliability. Fast decision procedures for propositional logic are highly
optimized and sometimes buggy.
Most modern SAT solvers can be asked to output a proof to justify the claim that the input
is unsatisfiable.
Checking the output with an independent checker adds confidence that the claim is correct.</p>
<p>Yet another reason to be interested in formal notions of proof is that they provide more
faithful models of informal proof, the process by which mathematicians establish that
mathematical claims are true.
Finally, when we turn to first-order logic, we will see that there is no decision procedure
for validity.
In fact, even fairly restricted versions of the question can be undecidable.
In cases like that, the best we can do is search for proofs and counterexamples,
with no guarantee that either will succeed in finite time.
In other words, proof systems for first-order logic are essential.</p>
<p>The notation <span class="math notranslate nohighlight">\(\Gamma \proves A\)</span> is used to express that <span class="math notranslate nohighlight">\(A\)</span>
is provable from a set of hypotheses <span class="math notranslate nohighlight">\(\Gamma\)</span>.
The notation <span class="math notranslate nohighlight">\(\proves A\)</span> therefore abbreviates <span class="math notranslate nohighlight">\(\emptyset \proves A\)</span>.
In this more general setting, soundness says that if <span class="math notranslate nohighlight">\(\Gamma \proves A\)</span>,
then <span class="math notranslate nohighlight">\(\Gamma \models A\)</span>,
and completeness says that if <span class="math notranslate nohighlight">\(\Gamma \models A\)</span>, then <span class="math notranslate nohighlight">\(\Gamma \proves A\)</span>.
If <span class="math notranslate nohighlight">\(\Gamma\)</span> is the finite set <span class="math notranslate nohighlight">\(\{ B_1, \ldots, B_n \}\)</span>,
then <span class="math notranslate nohighlight">\(\Gamma \models A\)</span> is equivalent to <span class="math notranslate nohighlight">\(\models B_1 \land \cdots \land B_n \limplies A\)</span>.
So, for many purposes, we can focus on provability and validity without hypotheses.
If the set <span class="math notranslate nohighlight">\(\Gamma\)</span> is infinite, however, we cannot express <span class="math notranslate nohighlight">\(\Gamma \models A\)</span>
in those terms.
For most of this chapter, we will not worry about infinite sets of hypotheses,
since mechanized reasoning generally has to work with finite representations.
But we will discuss the case where <span class="math notranslate nohighlight">\(\Gamma\)</span> is infinite in <a class="reference internal" href="#section-compactness"><span class="std std-numref">Section 8.7</span></a>.</p>
<p>When it comes to talking about formal proofs, the words <em>proof</em>, <em>deduction</em>,
and <em>derivation</em> are often used interchangeably.
The last two are sometimes useful to distinguish formal derivations from
ordinary (informal) mathematical proofs.</p>
<p>Different proof systems are useful for different purposes. Some are more faithful
to informal proof. These are therefore are easier to write down by hand when we try to
give a formal argument for a claim we can prove informally. Others may be more convenient
to use in automated reasoning, in the sense that they may be easier to generate automatically
or easier to check. Still others may be more useful from a theoretical standpoint,
when we try to reason about provability and the syntactic properties of the system.
For those reasons, a good deal of work in logic is devoted to designing different types
of proof systems and reasoning about the relationships between them.</p>
<p>In this chapter, we will consider four different types of proof systems for propositional
logic. The first type, axiomatic systems, are interesting mostly for historical reasons.
They are neither convenient to work with by hand nor convenient for automated reasoning,
but they do provide a fundamentally intuitive notion of proof, namely, as a sequence of
statement in which each either is an axiom, a hypothesis, or follows from previous lines
by a valid logical inference. The second type, resolution, is fundamental to automated
reasoning. The third, sequent calculi, are also commonly used in automated reasoning, and are
closely related to <em>tableau systems</em>, which are also common.
The last kind, natural deduction, is designed to closely model ordinary
logical reasoning, such as the kind of logical reasoning we use to prove a theorem of
mathematics. It forms the basis for a number of interactive proof systems.</p>
<section id="axiomatic-systems">
<span id="section-axiomatic-systems"></span><h2><span class="section-number">8.1. </span>Axiomatic systems<a class="headerlink" href="#axiomatic-systems" title="Permalink to this heading"></a></h2>
<p>Historically, one way of describing a proof system for propositional logic is to give a list
of axioms, like this one:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(A \limplies (B \limplies A)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((A \limplies (B \limplies C)) \limplies ((A \limplies B) \limplies (A \limplies C))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A \limplies (B \limplies A \land B)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A \land B \limplies A\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A \land B \limplies B\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A \limplies A \lor B\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(B \limplies A \lor B\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\((A \limplies C) \limplies ((B \limplies C) \limplies (A \lor B \limplies C))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot \lnot A \limplies A\)</span>.</p></li>
</ol>
<p>These are really axiom <em>schemas</em>, which is to say, we have an axiom for every choice of
<span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span>, and <span class="math notranslate nohighlight">\(C\)</span>. The only rule of inference in the system is <em>modus ponens</em>,
which is the rule “from <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(A \limplies B\)</span> conclude <span class="math notranslate nohighlight">\(B\)</span>.”
A <em>proof</em> of a formula <span class="math notranslate nohighlight">\(A\)</span> from hypotheses
<span class="math notranslate nohighlight">\(\Gamma\)</span> is a sequence of formula <span class="math notranslate nohighlight">\(C_1, \ldots, C_m\)</span> such that every <span class="math notranslate nohighlight">\(C_i\)</span>
is either:</p>
<ul class="simple">
<li><p>an axiom,</p></li>
<li><p>a hypothesis, or</p></li>
<li><p>consequence of two earlier formulas <span class="math notranslate nohighlight">\(C_j\)</span> and <span class="math notranslate nohighlight">\(C_k\)</span> using modus ponens.</p></li>
</ul>
<p>This proof system is sound and complete.
Proving soundness is straightforward: you only need to check that each axiom is valid
and that modus ponens preserves truth.
This enables us to show, by induction, that each line of a proof <span class="math notranslate nohighlight">\(C_1, \ldots, C_m\)</span>
of <span class="math notranslate nohighlight">\(A\)</span> from <span class="math notranslate nohighlight">\(\Gamma\)</span> is true under an assignment <span class="math notranslate nohighlight">\(\tau\)</span>,
assuming every formula in <span class="math notranslate nohighlight">\(\Gamma\)</span> is.
Proving completeness requires more work.
But axiomatic systems are no longer of much practical interest:
they do not provide convenient means of modeling informal proofs,
and they are not useful for automated reasoning or search.
We will therefore set them aside and focus our attention on other types of proof systems.</p>
</section>
<section id="resolution">
<span id="section-resolution"></span><h2><span class="section-number">8.2. </span>Resolution<a class="headerlink" href="#resolution" title="Permalink to this heading"></a></h2>
<p>A <em>resolution</em> proof is designed to <em>refute</em> a CNF formula, that is, to prove that
it is unsatisfiable.
Let <span class="math notranslate nohighlight">\(\Gamma\)</span> be a CNF formula, represented as a set of clauses.
As in <a class="reference internal" href="decision_procedures_for_propositional_logic.html#section-dpll"><span class="std std-numref">Section 6.3</span></a>, we can assume that none of the clauses contain repeated
literals or a complementary pair, and we can think of each clause as a set of literals.
If <span class="math notranslate nohighlight">\(C\)</span> is a clause and <span class="math notranslate nohighlight">\(\ell\)</span> is a literal, we write <span class="math notranslate nohighlight">\(C, \ell\)</span> for
<span class="math notranslate nohighlight">\(C \lor \ell\)</span>. The <em>resolution rule</em> derives a new clause from an old one:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$C, p$}
\AXC{$D, \lnot p$}
\BIC{$C \lor D$}
\end{prooftree}\]</div></div></blockquote>
<p>The rule says that if either <span class="math notranslate nohighlight">\(C\)</span> or <span class="math notranslate nohighlight">\(p\)</span> is true, and either <span class="math notranslate nohighlight">\(D\)</span> or <span class="math notranslate nohighlight">\(\lnot p\)</span>
is true, then <span class="math notranslate nohighlight">\(C \lor D\)</span> has to be true. A <em>resolution proof</em> of a clause <span class="math notranslate nohighlight">\(C\)</span> from
a set of clauses <span class="math notranslate nohighlight">\(\Gamma\)</span> is a sequence of steps (or a labelled tree) that obtains <span class="math notranslate nohighlight">\(C\)</span>
from <span class="math notranslate nohighlight">\(\Gamma\)</span> using instances of the resolution rule. A <em>resolution refutation</em> of <span class="math notranslate nohighlight">\(\Gamma\)</span>
is a resolution proof of the empty clause from <span class="math notranslate nohighlight">\(\Gamma\)</span>. For example,
the following proof shows that the CNF formula</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[(p \lor q \lor r) \land (\lnot p \lor s) \land (\lnot q \lor s) \land (\lnot r \lor s) \land \lnot s\]</div>
</div></blockquote>
<p>is unsatisfiable:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(p \lor q \lor r\)</span>, hypothesis</p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot p \lor s\)</span>, hypothesis</p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot q \lor s\)</span>, hypothesis</p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot r \lor s\)</span>, hypothesis</p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot s\)</span>, hypothesis</p></li>
<li><p><span class="math notranslate nohighlight">\(q \lor r \lor s\)</span>, resolve 1 and 2 on <span class="math notranslate nohighlight">\(p\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r \lor s\)</span>, resolve 6 and 3 on <span class="math notranslate nohighlight">\(q\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(s\)</span>, resolve 7 and 4 on <span class="math notranslate nohighlight">\(r\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\bot\)</span>, resolve 8 and 5 on <span class="math notranslate nohighlight">\(s\)</span></p></li>
</ol>
</div></blockquote>
<p>The following theorem shows that resolution proofs can refute any unsatisfiable formula.</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>A CNF formula <span class="math notranslate nohighlight">\(\Gamma\)</span> has a resolution refutation if and only if it is unsatisfiable.</p>
</div>
<div class="admonition-proof admonition">
<p class="admonition-title">Proof</p>
<p>The forward direction expresses the soundness of the calculus: if we can derive
<span class="math notranslate nohighlight">\(\bot\)</span> from a set of clauses <span class="math notranslate nohighlight">\(\Gamma\)</span>, then <span class="math notranslate nohighlight">\(\Gamma \models \bot\)</span>.
This follows from the fact that the resolution rule is a valid inference, which is to say,
the hypotheses entail the conclusion. This implies that each line in the proof
is entailed by <span class="math notranslate nohighlight">\(\Gamma\)</span>, so if the proof include <span class="math notranslate nohighlight">\(\bot\)</span>, <span class="math notranslate nohighlight">\(\Gamma\)</span>
is unsatisfiable.</p>
<p>Completeness requires a more subtle argument. We want to show that if <span class="math notranslate nohighlight">\(\Gamma\)</span>
is unsatisfiable, then there is a resolution proof of <span class="math notranslate nohighlight">\(\bot\)</span>.
To do so, use induction on the number of variables occurring in <span class="math notranslate nohighlight">\(\Gamma\)</span>.
If there are no variables occurring in <span class="math notranslate nohighlight">\(\Gamma\)</span> and <span class="math notranslate nohighlight">\(\Gamma\)</span> is unsatisfiable,
then it must contain the empty clause, and so it is immediately refutable.
Otherwise, choose a variable <span class="math notranslate nohighlight">\(p\)</span> that
occurs in <span class="math notranslate nohighlight">\(\Gamma\)</span>, and divide the clauses in <span class="math notranslate nohighlight">\(\Gamma\)</span> into three categories:</p>
<ul class="simple">
<li><p>those of the form <span class="math notranslate nohighlight">\(C_i \lor p\)</span> for some clause <span class="math notranslate nohighlight">\(C_i\)</span></p></li>
<li><p>those of the form <span class="math notranslate nohighlight">\(D_j \lor \lnot p\)</span> for some clause <span class="math notranslate nohighlight">\(D_j\)</span></p></li>
<li><p>those clauses <span class="math notranslate nohighlight">\(E_k\)</span> that contain neither <span class="math notranslate nohighlight">\(p\)</span> nor <span class="math notranslate nohighlight">\(\lnot p\)</span>.</p></li>
</ul>
<p>Let <span class="math notranslate nohighlight">\(\Gamma'\)</span> consist of the clauses <span class="math notranslate nohighlight">\(C_i \lor D_j\)</span> for each <span class="math notranslate nohighlight">\(i\)</span>
and <span class="math notranslate nohighlight">\(j\)</span> together with the clauses <span class="math notranslate nohighlight">\(E_k\)</span>. Notice that all the new clauses
in <span class="math notranslate nohighlight">\(\Gamma'\)</span> follow from clauses in <span class="math notranslate nohighlight">\(\Gamma\)</span> using the resolution rule.
It suffices to show that <span class="math notranslate nohighlight">\(\Gamma'\)</span> is unsatisfiable, because then the inductive hypothesis
implies that there is a
resolution refutation of <span class="math notranslate nohighlight">\(\Gamma'\)</span>, and hence of <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<p>Suppose <span class="math notranslate nohighlight">\(\tau\)</span> satisfies each clause <span class="math notranslate nohighlight">\(E_k\)</span>. If each clause <span class="math notranslate nohighlight">\(C_i\)</span> evaluates
to true under <span class="math notranslate nohighlight">\(\tau\)</span>, then <span class="math notranslate nohighlight">\(\tau[p \mapsto \bot]\)</span> satisfies <span class="math notranslate nohighlight">\(\Gamma\)</span>,
contradicting the fact that we are assuming <span class="math notranslate nohighlight">\(\Gamma\)</span> is unsatisfiable.
Hence some clause <span class="math notranslate nohighlight">\(C_i\)</span> must be false under <span class="math notranslate nohighlight">\(\tau\)</span>. By the dual argument,
some clause <span class="math notranslate nohighlight">\(D_j\)</span> must be false under <span class="math notranslate nohighlight">\(\tau\)</span>. But then <span class="math notranslate nohighlight">\(C_i \lor D_j\)</span>
evaluates to false, which means <span class="math notranslate nohighlight">\(\tau\)</span> does not satisfy <span class="math notranslate nohighlight">\(\Gamma'\)</span>.
In other words, we have shown that any assignment <span class="math notranslate nohighlight">\(\tau\)</span> that satisfies each clause
<span class="math notranslate nohighlight">\(E_k\)</span> cannot satisfy every clause <span class="math notranslate nohighlight">\(C_i \lor D_j\)</span>, so <span class="math notranslate nohighlight">\(\Gamma'\)</span> is unsatisfiable.</p>
</div>
<p>The following fact is implicit in the last argument:</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>Given <span class="math notranslate nohighlight">\(\Gamma\)</span> and <span class="math notranslate nohighlight">\(\Gamma'\)</span> as above (without the assumption that <span class="math notranslate nohighlight">\(\Gamma\)</span>
is unsatisfiable), <span class="math notranslate nohighlight">\(\Gamma\)</span> and <span class="math notranslate nohighlight">\(\Gamma'\)</span> are equisatisfiable.</p>
</div>
<p>You should try to spell out a proof of this explicitly. In fact, the completeness argument only
requires one direction of this theorem, namely, that if <span class="math notranslate nohighlight">\(\Gamma'\)</span> is
unsatisfiable, then so is <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
</section>
<section id="implementing-resolution">
<span id="section-implementing-resolution"></span><h2><span class="section-number">8.3. </span>Implementing resolution<a class="headerlink" href="#implementing-resolution" title="Permalink to this heading"></a></h2>
<p>The completeness proof we have just seen gives rise to yet another decision procedure
for propositional logic: given a CNF formula <span class="math notranslate nohighlight">\(\Gamma\)</span> as a set of clauses,
pick any variable <span class="math notranslate nohighlight">\(p\)</span> and replace all the pairs of clauses of the form
<span class="math notranslate nohighlight">\(C_i \lor p\)</span> and <span class="math notranslate nohighlight">\(D_j \lor \lnot p\)</span> by <span class="math notranslate nohighlight">\(C_i \lor D_j\)</span>.
If we manage to derive the empty clause that way
(that is, from clauses <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(\lnot p\)</span>), we know that <span class="math notranslate nohighlight">\(\Gamma\)</span>
is unsatisfiable. Otherwise, we pick another variable <span class="math notranslate nohighlight">\(q\)</span> and repeat the process.
If eventually we obtain the clause <span class="math notranslate nohighlight">\(\bot\)</span>, we know
the original CNF formula is unsatisfiable.</p>
<p>It’s easy to code this up in Lean. Notice that the resolution rule can be defined as follows:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">resolve</span> <span class="o">(</span><span class="n">c₁</span> <span class="n">c₂</span> <span class="o">:</span> <span class="n">Clause</span><span class="o">)</span> <span class="o">(</span><span class="n">var</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">Clause</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">c₁.erase</span> <span class="o">(</span><span class="n">Lit.pos</span> <span class="n">var</span><span class="o">))</span><span class="bp">.</span><span class="n">union&#39;</span> <span class="o">(</span><span class="n">c₂.erase</span> <span class="o">(</span><span class="n">Lit.neg</span> <span class="n">var</span><span class="o">))</span>
</pre></div>
</div>
<p>Given a list of clauses, we can sort them relative to the variable <code class="docutils literal notranslate"><span class="pre">var</span></code> as follows:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">getPosNegClauses</span> <span class="o">(</span><span class="n">var</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">List</span> <span class="n">Clause</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Clause</span> <span class="bp">×</span> <span class="n">List</span> <span class="n">Clause</span> <span class="bp">×</span> <span class="n">List</span> <span class="n">Clause</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="o">([],</span> <span class="o">[],</span> <span class="o">[])</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">c</span> <span class="o">::</span> <span class="n">cs</span><span class="o">)</span> <span class="bp">=&gt;</span>
    <span class="k">let</span> <span class="o">(</span><span class="n">pos</span><span class="o">,</span> <span class="n">neg</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="o">:=</span> <span class="n">getPosNegClauses</span> <span class="n">var</span> <span class="n">cs</span>
    <span class="k">if</span> <span class="n">Lit.pos</span> <span class="n">var</span> <span class="bp">∈</span> <span class="n">c</span> <span class="k">then</span>
      <span class="o">(</span><span class="n">c</span> <span class="o">::</span> <span class="n">pos</span><span class="o">,</span> <span class="n">neg</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">Lit.neg</span> <span class="n">var</span> <span class="bp">∈</span> <span class="n">c</span> <span class="k">then</span>
      <span class="o">(</span><span class="n">pos</span><span class="o">,</span> <span class="n">c</span> <span class="o">::</span> <span class="n">neg</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="o">(</span><span class="n">pos</span><span class="o">,</span> <span class="n">neg</span><span class="o">,</span> <span class="n">c</span> <span class="o">::</span> <span class="n">rest</span><span class="o">)</span>
</pre></div>
</div>
<p>Then, given a function <code class="docutils literal notranslate"><span class="pre">CnfForm.getvar?</span></code> that chooses a variable in a CNF formula
(returning none if there aren’t any) and another function <code class="docutils literal notranslate"><span class="pre">IsTautology</span></code> that determines
whether a clause is a tautology, we can determine whether there is a resolution refutation
as follows:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">partial</span> <span class="kd">def</span> <span class="n">refute</span> <span class="o">(</span><span class="n">cnf</span> <span class="o">:</span> <span class="n">CnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">if</span> <span class="n">cnf.contains</span> <span class="o">[]</span> <span class="k">then</span>  <span class="c1">-- the empty clause</span>
    <span class="n">true</span>
  <span class="k">else</span>
    <span class="k">match</span> <span class="n">cnf.getVar</span><span class="bp">?</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="n">none</span>     <span class="bp">=&gt;</span> <span class="n">false</span>
      <span class="bp">|</span> <span class="n">some</span> <span class="n">var</span> <span class="bp">=&gt;</span> <span class="n">Id.run</span> <span class="k">do</span>
          <span class="k">let</span> <span class="o">(</span><span class="n">pos</span><span class="o">,</span> <span class="n">neg</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="o">:=</span> <span class="n">getPosNegClauses</span> <span class="n">var</span> <span class="n">cnf</span>
          <span class="k">let</span> <span class="n">mut</span> <span class="n">new_clauses</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Clause</span> <span class="o">:=</span> <span class="o">[]</span>
          <span class="n">for</span> <span class="n">c₁</span> <span class="k">in</span> <span class="n">pos</span> <span class="k">do</span>
            <span class="n">for</span> <span class="n">c₂</span> <span class="k">in</span> <span class="n">neg</span> <span class="k">do</span>
              <span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">resolve</span> <span class="n">c₁</span> <span class="n">c₂</span> <span class="n">var</span>
              <span class="k">if</span> <span class="bp">¬</span> <span class="n">IsTautology</span> <span class="n">c</span> <span class="k">then</span>
                <span class="n">new_clauses</span> <span class="o">:=</span> <span class="n">c</span> <span class="o">::</span> <span class="n">new_clauses</span>
          <span class="n">refute</span> <span class="o">(</span><span class="n">new_clauses</span> <span class="bp">++</span> <span class="n">rest</span><span class="o">)</span>
</pre></div>
</div>
<p>If you are a hard core functional programmer, you can replace the second case with
an expression using <cite>map</cite>, <cite>union’</cite>, <cite>Union</cite>, and <cite>filter</cite>, but it isn’t more efficient
or any easier to read.</p>
<p>The examples file includes some examples of the procedure in use, but you should try
some of your own.
This is a good place to mention that Lean will allow you do add print statements as
debugging tools, and if you do that, you can trace the progress of the search.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">partial</span> <span class="kd">def</span> <span class="n">refute&#39;</span> <span class="o">(</span><span class="n">cnf</span> <span class="o">:</span> <span class="n">CnfForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">if</span> <span class="n">cnf.contains</span> <span class="o">[]</span> <span class="k">then</span>  <span class="c1">-- the empty clause</span>
    <span class="n">dbg_trace</span> <span class="n">f</span><span class="bp">!</span><span class="s2">&quot;derived the empty clause&quot;</span>
    <span class="n">true</span>
  <span class="k">else</span>
    <span class="n">dbg_trace</span> <span class="n">f</span><span class="bp">!</span><span class="s2">&quot;cnf: {cnf}&quot;</span>
    <span class="k">match</span> <span class="n">cnf.getVar</span><span class="bp">?</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="n">none</span>     <span class="bp">=&gt;</span>
          <span class="n">dbg_trace</span> <span class="n">f</span><span class="bp">!</span><span class="s2">&quot;failed; nothing left to split on&quot;</span>
          <span class="n">false</span>
      <span class="bp">|</span> <span class="n">some</span> <span class="n">var</span> <span class="bp">=&gt;</span> <span class="n">Id.run</span> <span class="k">do</span>
          <span class="n">dbg_trace</span> <span class="n">f</span><span class="bp">!</span><span class="s2">&quot;split on {var}&quot;</span>
          <span class="k">let</span> <span class="o">(</span><span class="n">pos</span><span class="o">,</span> <span class="n">neg</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="o">:=</span> <span class="n">getPosNegClauses</span> <span class="n">var</span> <span class="n">cnf</span>
          <span class="k">let</span> <span class="n">mut</span> <span class="n">new_clauses</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Clause</span> <span class="o">:=</span> <span class="o">[]</span>
          <span class="n">for</span> <span class="n">c₁</span> <span class="k">in</span> <span class="n">pos</span> <span class="k">do</span>
            <span class="n">for</span> <span class="n">c₂</span> <span class="k">in</span> <span class="n">neg</span> <span class="k">do</span>
              <span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">resolve</span> <span class="n">c₁</span> <span class="n">c₂</span> <span class="n">var</span>
              <span class="k">if</span> <span class="bp">¬</span> <span class="n">IsTautology</span> <span class="n">c</span> <span class="k">then</span>
                <span class="n">new_clauses</span> <span class="o">:=</span> <span class="n">c</span> <span class="o">::</span> <span class="n">new_clauses</span>
          <span class="n">refute&#39;</span> <span class="o">(</span><span class="n">new_clauses</span> <span class="bp">++</span> <span class="n">rest</span><span class="o">)</span>
</pre></div>
</div>
<p>This procedure for evaluating the satisfiability of a CNF formula is fairly naive.
One can do better by incorporating unit propagation and the pure literal rule,
as described in
<a class="reference internal" href="decision_procedures_for_propositional_logic.html#section-unit-propagation-and-the-pure-literal-rule"><span class="std std-numref">Section 6.2</span></a>.
The resulting procedure is known as the Davis-Putnam procedure, or DP.
In general, splitting on variables can lead to exponential increase in the size
of the formula under consideration at each stage,
and one can be more clever about choosing which variable to split on,
for example, choosing the variable
that minimizes the number of clauses in the next step.</p>
<p>Rather than pursuing such optimization, however, we will use the naive procedure to
illustrate a common theme in automated reasoning.
By the completeness of the refutation procedure we have designed, we know that for any
CNF formula <span class="math notranslate nohighlight">\(\Gamma\)</span>, either there is a satisfying assignment or a resolution refutation.
Often, when we have a decision procedure or a search procedure, we can modify it to return
additional information.
When <span class="math notranslate nohighlight">\(\Gamma\)</span> is satisfiable, it would be nice if the procedure actually <em>returned</em> the satisfying
assignment, and otherwise it would be nice if the procedure actually <em>returned</em> a
resolution refutation.</p>
<p>Our goal here is to think about how to obtain a proof in the latter case.
For that, we need to have some sort of computational representation of resolution proofs.
Here is one option:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">Step</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">hyp</span> <span class="o">(</span><span class="n">clause</span> <span class="o">:</span> <span class="n">Clause</span><span class="o">)</span> <span class="o">:</span> <span class="n">Step</span>
  <span class="bp">|</span> <span class="n">res</span> <span class="o">(</span><span class="n">var</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Step</span>
<span class="n">deriving</span> <span class="n">Inhabited</span><span class="o">,</span> <span class="n">Repr</span>

<span class="kd">def</span> <span class="n">Proof</span> <span class="o">:=</span> <span class="n">Array</span> <span class="n">Step</span> <span class="n">deriving</span> <span class="n">Inhabited</span><span class="o">,</span> <span class="n">Repr</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">GetElem</span> <span class="n">Proof</span> <span class="n">Nat</span> <span class="n">Step</span> <span class="o">(</span><span class="k">fun</span> <span class="n">xs</span> <span class="n">i</span> <span class="bp">=&gt;</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">xs.size</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">inferInstanceAs</span> <span class="o">(</span><span class="n">GetElem</span> <span class="o">(</span><span class="n">Array</span> <span class="n">Step</span><span class="o">)</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span>
</pre></div>
</div>
<p>A resolution proof is a sequence of steps, where each line is either a hypothesis or a resolution
inference. The <code class="docutils literal notranslate"><span class="pre">instance</span></code> command is Lean boilerplate that will allow us to write <code class="docutils literal notranslate"><span class="pre">p[i]!</span></code>
to refer to step <code class="docutils literal notranslate"><span class="pre">i</span></code> of a resolution proof by telling Lean that the notation
is inherited from the underlying array representation.</p>
<p>A proof is only well formed if each resolution step refers to prior steps, which we can
check as follows.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">Proof.wellFormed</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Proof</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[:</span><span class="n">p.size</span><span class="o">]</span> <span class="k">do</span>
    <span class="k">match</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="bp">!</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="bp">.</span><span class="n">hyp</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">continue</span>
      <span class="bp">|</span> <span class="bp">.</span><span class="n">res</span> <span class="n">_</span> <span class="n">pos</span> <span class="n">neg</span> <span class="bp">=&gt;</span>
          <span class="k">if</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">pos</span> <span class="bp">∨</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">neg</span> <span class="k">then</span>
            <span class="n">return</span> <span class="n">false</span>
  <span class="n">true</span>
</pre></div>
</div>
<p>The notation <code class="docutils literal notranslate"><span class="pre">.hyp</span></code> and <code class="docutils literal notranslate"><span class="pre">.res</span></code> rely on another useful syntactic gadget in Lean: because
Lean is expecting something of type <code class="docutils literal notranslate"><span class="pre">Step</span></code> at that point, it interprets those expressions
as <code class="docutils literal notranslate"><span class="pre">Step.hyp</span></code> and <code class="docutils literal notranslate"><span class="pre">Step.res</span></code>. This saves us the trouble of opening the namespace or
writing <code class="docutils literal notranslate"><span class="pre">Step</span></code> explicitly.</p>
<p>Assuming the proof is well formed, we can pretty-print it.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">Proof.show</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Proof</span><span class="o">)</span> <span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="k">do</span>
  <span class="k">if</span> <span class="bp">¬</span> <span class="n">p.wellFormed</span> <span class="k">then</span>
    <span class="n">IO.println</span> <span class="s2">&quot;Proof is not well-formed.&quot;</span>
    <span class="n">return</span>
  <span class="k">let</span> <span class="n">mut</span> <span class="n">clauses</span> <span class="o">:</span> <span class="n">Array</span> <span class="n">Clause</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[]</span>
  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[:</span><span class="n">p.size</span><span class="o">]</span> <span class="k">do</span>
    <span class="k">match</span> <span class="n">p</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="bp">!</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="n">Step.hyp</span> <span class="n">c</span> <span class="bp">=&gt;</span>
          <span class="n">clauses</span> <span class="o">:=</span> <span class="n">clauses.push</span> <span class="n">c</span>
          <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">&quot;{i}: hypothesis: {c}&quot;</span>
      <span class="bp">|</span> <span class="n">Step.res</span> <span class="n">var</span> <span class="n">pos</span> <span class="n">neg</span> <span class="bp">=&gt;</span>
          <span class="k">let</span> <span class="n">resolvent</span> <span class="o">:=</span> <span class="n">resolve</span> <span class="n">clauses</span><span class="o">[</span><span class="n">pos</span><span class="o">]</span><span class="bp">!</span> <span class="n">clauses</span><span class="o">[</span><span class="n">neg</span><span class="o">]</span><span class="bp">!</span> <span class="n">var</span>
          <span class="n">clauses</span> <span class="o">:=</span> <span class="n">clauses.push</span> <span class="n">resolvent</span>
          <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">&quot;{i}: resolve {pos}, {neg} on {var}: {resolvent}&quot;</span>
</pre></div>
</div>
<p>This enables us to write resolution proofs by hand and see the results.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">example1</span> <span class="o">:</span> <span class="n">Proof</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[</span>
  <span class="bp">.</span><span class="n">hyp</span> <span class="n">clause</span><span class="bp">!</span><span class="o">{</span><span class="n">p</span> <span class="n">q</span><span class="o">},</span>
  <span class="bp">.</span><span class="n">hyp</span> <span class="n">clause</span><span class="bp">!</span><span class="o">{</span><span class="bp">-</span><span class="n">p</span><span class="o">},</span>
  <span class="bp">.</span><span class="n">hyp</span> <span class="n">clause</span><span class="bp">!</span><span class="o">{</span><span class="bp">-</span><span class="n">q</span><span class="o">},</span>
  <span class="bp">.</span><span class="n">res</span> <span class="s2">&quot;p&quot;</span> <span class="mi">0</span> <span class="mi">1</span><span class="o">,</span>
  <span class="bp">.</span><span class="n">res</span> <span class="s2">&quot;q&quot;</span> <span class="mi">3</span> <span class="mi">2</span>
<span class="o">]</span>

<span class="k">#eval</span> <span class="n">example1.wellFormed</span>
<span class="k">#eval</span> <span class="n">example1.show</span>

<span class="kd">def</span> <span class="n">example2</span> <span class="o">:</span> <span class="n">Proof</span> <span class="o">:=</span> <span class="bp">#</span><span class="o">[</span>
  <span class="bp">.</span><span class="n">hyp</span> <span class="n">clause</span><span class="bp">!</span><span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span><span class="o">},</span>
  <span class="bp">.</span><span class="n">hyp</span> <span class="n">clause</span><span class="bp">!</span><span class="o">{</span><span class="bp">-</span><span class="n">p</span> <span class="n">s</span><span class="o">},</span>
  <span class="bp">.</span><span class="n">hyp</span> <span class="n">clause</span><span class="bp">!</span><span class="o">{</span><span class="bp">-</span><span class="n">q</span> <span class="n">s</span><span class="o">},</span>
  <span class="bp">.</span><span class="n">hyp</span> <span class="n">clause</span><span class="bp">!</span><span class="o">{</span><span class="bp">-</span><span class="n">r</span> <span class="n">s</span><span class="o">},</span>
  <span class="bp">.</span><span class="n">hyp</span> <span class="n">clause</span><span class="bp">!</span><span class="o">{</span><span class="bp">-</span><span class="n">s</span><span class="o">},</span>
  <span class="bp">.</span><span class="n">res</span> <span class="s2">&quot;p&quot;</span> <span class="mi">0</span> <span class="mi">1</span><span class="o">,</span>
  <span class="bp">.</span><span class="n">res</span> <span class="s2">&quot;q&quot;</span> <span class="mi">5</span> <span class="mi">2</span><span class="o">,</span>
  <span class="bp">.</span><span class="n">res</span> <span class="s2">&quot;r&quot;</span> <span class="mi">6</span> <span class="mi">3</span><span class="o">,</span>
  <span class="bp">.</span><span class="n">res</span> <span class="s2">&quot;s&quot;</span> <span class="mi">7</span> <span class="mi">4</span>
<span class="o">]</span>

<span class="k">#eval</span> <span class="n">example2.wellFormed</span>
<span class="k">#eval</span> <span class="n">example2.show</span>
</pre></div>
</div>
<p>Notice that our proof format does not store the clause that is derived at each step,
because that can be reconstructed from the proof, as we just did with our pretty-printer.
But for some purposes,
it is more convenient to use a representation that stores the clause with the
resolution steps as well as with the hypotheses.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">VerboseStep</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">hyp</span> <span class="o">(</span><span class="n">clause</span> <span class="o">:</span> <span class="n">Clause</span><span class="o">)</span> <span class="o">:</span> <span class="n">VerboseStep</span>
  <span class="bp">|</span> <span class="n">res</span> <span class="o">(</span><span class="n">var</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">pos</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">clause</span> <span class="o">:</span> <span class="n">Clause</span><span class="o">):</span> <span class="n">VerboseStep</span>
<span class="n">deriving</span> <span class="n">Inhabited</span><span class="o">,</span> <span class="n">Repr</span>

<span class="kd">def</span> <span class="n">VerboseProof</span> <span class="o">:=</span> <span class="n">Array</span> <span class="n">VerboseStep</span> <span class="n">deriving</span> <span class="n">Inhabited</span><span class="o">,</span> <span class="n">Repr</span>
</pre></div>
</div>
<p>We are now in a good position to modify the <code class="docutils literal notranslate"><span class="pre">refute</span></code> procedure above to build a refutation as
it goes.
It is easier to use the verbose proof format, because that makes it easy to refer to the
clauses we have derived.
In other words, the procedure to refute a CNF formula should start by adding all the clauses
in the formula as hypotheses and then iteratively add the clauses that are derived
by the resolution rule.
Since the proof includes all the clauses we derive along the way, we ought to keep track of
a list of numbers that represent the CNF formula at each stage of the algorithm,
that is, the lines of the proof that correspond to the clauses in the CNF formula that are
still active.
Otherwise, the structure of the procedure mirrors that of <code class="docutils literal notranslate"><span class="pre">refute</span></code>.</p>
<p>We encourage you to try your hand at making these modifications and then showing the refutations
the procedure obtains.
Note that the proofs are obtained this way are not efficient:
the procedure, as we described it, logs every clause that
is derived in the search, whether or not it contributes to the final proof of <span class="math notranslate nohighlight">\(\bot\)</span>.
We therefore also encourage you to think about how you can trim these proofs to the
clauses that are needed.</p>
</section>
<section id="resolution-and-dpll">
<h2><span class="section-number">8.4. </span>Resolution and DPLL<a class="headerlink" href="#resolution-and-dpll" title="Permalink to this heading"></a></h2>
<p>Recall the theorem established in <a class="reference internal" href="#section-resolution"><span class="std std-numref">Section 8.2</span></a>:</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>A CNF formula <span class="math notranslate nohighlight">\(\Gamma\)</span> has a resolution refutation if and only if it is unsatisfiable.</p>
</div>
<p>Our proof gave rise to a procedure, DP, that searches for such a refutation.
We now describe an alternative proof that is closer in spirit to the DPLL procedure we described
in <a class="reference internal" href="decision_procedures_for_propositional_logic.html#chapter-decision-procedures-for-propositional-logic"><span class="std std-numref">Chapter 6</span></a>.
Rather than think of the proof in terms of a search for a refutation, we think of it in terms
of a search for a satisfying assignment.</p>
<div class="admonition-proof admonition">
<p class="admonition-title">Proof</p>
<p>As before, soundness follows straightforwardly from the fact that the resolution rule preserves
truth under any truth assignment, while the empty clause is unsatisfiable.</p>
<p>To prove completeness, we use induction on the number of propositional variables
to show that if <span class="math notranslate nohighlight">\(\Gamma\)</span> is unsatisfiable, there is a resolution refutation
of <span class="math notranslate nohighlight">\(\Gamma\)</span>.
If there are no variables, the fact that <span class="math notranslate nohighlight">\(\Gamma\)</span> is unsatisfiable means that
it must be the set consisting of the empty clause, and we are done.</p>
<p>In the induction step, let <span class="math notranslate nohighlight">\(p\)</span> be any variable that occurs in <span class="math notranslate nohighlight">\(\Gamma\)</span>.
If <span class="math notranslate nohighlight">\(\Gamma\)</span> is unsatisfiable, then so are <span class="math notranslate nohighlight">\(\tval{\Gamma}_{[p \mapsto \top]}\)</span>
and <span class="math notranslate nohighlight">\(\tval{\Gamma}_{[p \mapsto \bot]}\)</span>. By the inductive hypothesis,
both of these are refutable.</p>
<p>Remember the relationship between <span class="math notranslate nohighlight">\(\tval{\Gamma}_{[p \mapsto \top]}\)</span> and <span class="math notranslate nohighlight">\(\Gamma\)</span>:
in the former, we remove all the clauses that include <span class="math notranslate nohighlight">\(p\)</span> and delete <span class="math notranslate nohighlight">\(\lnot p\)</span>
from the remaining clauses.
So a resolution refutation of the empty clause from <span class="math notranslate nohighlight">\(\tval{\Gamma}_{[p \mapsto \top]}\)</span>
uses only the clauses of <span class="math notranslate nohighlight">\(\tval{\Gamma}\)</span> that don’t contain <span class="math notranslate nohighlight">\(p\)</span>,
possibly with <span class="math notranslate nohighlight">\(\lnot p\)</span> removed.
Restoring <span class="math notranslate nohighlight">\(\lnot p\)</span> to all the initial clauses yields either a proof of the
empty clause or a proof of <span class="math notranslate nohighlight">\(\lnot p\)</span>.</p>
<p>In the first case, we have a proof of the empty clause from <span class="math notranslate nohighlight">\(\Gamma\)</span>, and we are done.
Otherwise, applying the inductive hypotheses to <span class="math notranslate nohighlight">\(\tval{\Gamma}_{[\lnot p \mapsto \bot]}\)</span>
and repeating the previous argument,
we obtain either a proof of the empty clause or a proof of <span class="math notranslate nohighlight">\(p\)</span>.
Once again, in the first case, we are done. Otherwise, we apply the resolution rule to the
proof of <span class="math notranslate nohighlight">\(p\)</span> and the proof of <span class="math notranslate nohighlight">\(\lnot p\)</span>, and we have a proof of the empty clause.</p>
</div>
<p>We can once again view the completeness proof as a decision procedure in disguise.
The strategy of picking a variable <span class="math notranslate nohighlight">\(p\)</span> and trying to refute
<span class="math notranslate nohighlight">\(\tval{\Gamma}_{[p \mapsto \top]}\)</span> and <span class="math notranslate nohighlight">\(\tval{\Gamma}_{[p \mapsto \bot]}\)</span>
simultaneously is exactly the splitting rule of DPLL,
formulated in terms of demonstrating unsatisfiability rather than searching for a satisfying
assignment. We can formulate the theorem above in more constructive terms as follows:</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>For any CNF formula <span class="math notranslate nohighlight">\(\Gamma\)</span>, either <span class="math notranslate nohighlight">\(\Gamma\)</span> is satisfiable or there is a
resolution refutation.</p>
</div>
<p>Remember that at any point in the DPLL search, we have a partial assignment <span class="math notranslate nohighlight">\(\tau\)</span>
that we are trying to extend to a satisfying assignment to <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span>.
If we fail, we then have to give up on <span class="math notranslate nohighlight">\(\tau\)</span>, backtrack, and try another path.
To extract either a satisfying assignment or a resolution proof from the result,
it suffices to show the following constructively:</p>
<blockquote>
<div><p>For any partial truth assignment <span class="math notranslate nohighlight">\(\tau\)</span>,
either <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span> is satisfiable
or there is a resolution proof of a clause <span class="math notranslate nohighlight">\(C\)</span> from <span class="math notranslate nohighlight">\(\Gamma\)</span> such that
<span class="math notranslate nohighlight">\(\tval{C}_\tau = \bot\)</span>.</p>
</div></blockquote>
<p>This yields the desired conclusion when <span class="math notranslate nohighlight">\(\tau\)</span> is the empty assignment,
since the only clause that evaluates to <span class="math notranslate nohighlight">\(\bot\)</span> under the empty assignment is the empty clause.</p>
<p>We will sketch an explanation of how to read off the information above from the DPLL search,
and we will leave it as an exercise for you to fill in the details.
Remember that there are three steps that are interleaved in DPLL:</p>
<ol class="arabic simple">
<li><p>splitting on a variable <span class="math notranslate nohighlight">\(p\)</span></p></li>
<li><p>unit propagation</p></li>
<li><p>removing pure literals</p></li>
</ol>
<p>Unit propagation can be viewed as a special case of the splitting rule:
If a CNF formula contains a unit clause with literal <span class="math notranslate nohighlight">\(\ell\)</span>,
then splitting on <span class="math notranslate nohighlight">\(\ell\)</span> fails immediately on one branch,
and the other branch corresponds to the result of applying unit propagation.</p>
<p>Reasoning about the pure literal rule is more subtle. Suppose <span class="math notranslate nohighlight">\(\ell\)</span> is pure in
<span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span>, and consider the DPLL search
starting from <span class="math notranslate nohighlight">\(\tval{\Gamma}_{\tau[\ell \mapsto \top]}\)</span>,
which is a subset of <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span>. If DPLL finds a satisfying assignment
to <span class="math notranslate nohighlight">\(\tval{\Gamma}_{\tau[\ell \mapsto \top]}\)</span>, it can be extended to a satisfying
assignment to <span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span> by mapping <span class="math notranslate nohighlight">\(\ell\)</span> to <span class="math notranslate nohighlight">\(\top\)</span>.
On the other hand, for any clause <span class="math notranslate nohighlight">\(C\)</span> such that <span class="math notranslate nohighlight">\(\tval{C}_{\tau[\ell \mapsto \top]} = \bot\)</span>,
we have <span class="math notranslate nohighlight">\(\tval{C}_\tau = \bot\)</span>, because <span class="math notranslate nohighlight">\(\ell\)</span> is pure in all the clauses of
<span class="math notranslate nohighlight">\(\tval{\Gamma}_\tau\)</span>.</p>
<p>So we only have to deal with the splitting rule. A satisfying assignment for either branch
results in a satisfying assignment for <span class="math notranslate nohighlight">\(\Gamma\)</span>, so we only only have to prove the following:</p>
<blockquote>
<div><p>If there are a resolution proof of a clause <span class="math notranslate nohighlight">\(C\)</span> from <span class="math notranslate nohighlight">\(\Gamma\)</span> such that
<span class="math notranslate nohighlight">\(\tval{C}_{\tau[p \mapsto \top]} = \bot\)</span>
and a resolution proof of a clause <span class="math notranslate nohighlight">\(D\)</span> from <span class="math notranslate nohighlight">\(\Gamma\)</span> such that
<span class="math notranslate nohighlight">\(\tval{D}_{\tau[p \mapsto \bot]} = \bot\)</span>,
then there is a resolution proof of a clause <span class="math notranslate nohighlight">\(E\)</span> from <span class="math notranslate nohighlight">\(\Gamma\)</span> such that
<span class="math notranslate nohighlight">\(\tval{E}_\tau = \bot\)</span>.</p>
</div></blockquote>
<p>We leave the proof of this fact to you.</p>
</section>
<section id="a-sequent-calculus">
<span id="section-propositional-sequent-calculus"></span><h2><span class="section-number">8.5. </span>A sequent calculus<a class="headerlink" href="#a-sequent-calculus" title="Permalink to this heading"></a></h2>
<p>Let <span class="math notranslate nohighlight">\(\Gamma\)</span> be a finite set of propositional formula in negation normal form.
The next calculus we will consider is designed to prove that the disjunction of the formulas
in <span class="math notranslate nohighlight">\(\Gamma\)</span> is valid, which is to say, for every truth assignment <span class="math notranslate nohighlight">\(\tau\)</span>,
at least one of the formula in <span class="math notranslate nohighlight">\(\Gamma\)</span> is true. If <span class="math notranslate nohighlight">\(A\)</span> is a formula,
we write <span class="math notranslate nohighlight">\(\Gamma, A\)</span> instead of <span class="math notranslate nohighlight">\(\Gamma \cup \{ A \}\)</span>.
The rules are as follows:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$\Gamma, p, \lnot p$}
\end{prooftree}\]

\[\begin{prooftree}
\AXC{$\Gamma, A$}
\AXC{$\Gamma, B$}
\BIC{$\Gamma, A \land B$}
\end{prooftree}\quad\quad
\begin{prooftree}
\AXC{$\Gamma, A, B$}
\UIC{$\Gamma, A \lor B$}
\end{prooftree}
\]</div></div></blockquote>
<p>The first rule says that either something in <span class="math notranslate nohighlight">\(\Gamma\)</span> is true,
or <span class="math notranslate nohighlight">\(p\)</span> is true, or <span class="math notranslate nohighlight">\(\lnot p\)</span> is true. The second rule says that
if either something in <span class="math notranslate nohighlight">\(\Gamma\)</span> is true or <span class="math notranslate nohighlight">\(A\)</span> is true, and
either something in <span class="math notranslate nohighlight">\(\Gamma\)</span> is true or <span class="math notranslate nohighlight">\(B\)</span> is true, then
either something in <span class="math notranslate nohighlight">\(\Gamma\)</span> is true or <span class="math notranslate nohighlight">\(A \land B\)</span> is true.
The third rule says that if either something in <span class="math notranslate nohighlight">\(\Gamma\)</span> is true or <span class="math notranslate nohighlight">\(A\)</span> is true
or <span class="math notranslate nohighlight">\(B\)</span> is true, then either something in <span class="math notranslate nohighlight">\(\Gamma\)</span> is true or <span class="math notranslate nohighlight">\(A \lor B\)</span> is true.
If we take these to be statements about truth values relative to some truth assignment
<span class="math notranslate nohighlight">\(\tau\)</span>,
these rules are clearly sound with respect to the semantics.</p>
<p>The set <span class="math notranslate nohighlight">\(\Gamma\)</span> is called a <em>sequent</em>. (More specifically, it is called
as <em>one-sided</em> sequent; we’ll see two-sided sequents below.)
A system of rules like this is therefore called a sequent calculus.
As with axiomatic systems, we can think of a proof as a sequence of lines,
but it is also common to represent proofs diagrammatically,
as trees whose nodes are labeled by sequents. The following example provides
a proof of the NNF equivalent of
<span class="math notranslate nohighlight">\(A \land (B \lor C) \limplies (A \land B) \lor (A \land C)\)</span>.</p>
<img alt="sequentproof" class="align-center" src="_images/sequentproof.png" />
<p>It is probably easiest to read this from the bottom up.</p>
<p>Remember that saying that a sequent <span class="math notranslate nohighlight">\(\Gamma\)</span> is <em>valid</em> in our semantics means that
for every truth assignment <span class="math notranslate nohighlight">\(\tau\)</span>, we have <span class="math notranslate nohighlight">\(\tval{A}_\tau = \top\)</span> for some
<span class="math notranslate nohighlight">\(A\)</span> in <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>The sequent calculus presented above is sound and complete. In other words,
a sequent <span class="math notranslate nohighlight">\(\Gamma\)</span> is provable if and only if it is valid.</p>
</div>
<div class="admonition-proof admonition">
<p class="admonition-title">Proof</p>
<p>The soundness direction is easy. Suppose there is a proof of <span class="math notranslate nohighlight">\(\Gamma\)</span>.
Let <span class="math notranslate nohighlight">\(\tau\)</span> be any truth assignment.
We have already noted that each rule is sound, which is to say, if the premise or premises
are true under an assignment, then so is the conclusion.
By induction, we have that every sequent in the proof is true under assignment <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
<p>Proving completeness is usually trickier. In this case, we can use
the fact that the rules of the calculus are bidirectional:
any truth assignment that refutes the conclusion of a rule has to refute one of the premises.
We can also use the fact that reading each rule backward decreases the number of binary
connectives.</p>
<p>We prove the following by induction on the number of binary connectives: for every
sequent <span class="math notranslate nohighlight">\(\Gamma\)</span>, either <span class="math notranslate nohighlight">\(\Gamma\)</span> is provable, or there is a truth
assignment that makes every formula in <span class="math notranslate nohighlight">\(\Gamma\)</span> false.
If <span class="math notranslate nohighlight">\(\Gamma\)</span> has no binary connectives, then it is a set of literals.
If <span class="math notranslate nohighlight">\(\Gamma\)</span> contains a complementary pair of literals <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(\lnot P\)</span>,
it is an axiom, and otherwise there is an assignment that makes it false.
For the inductive step, <span class="math notranslate nohighlight">\(\Gamma\)</span> must have a <span class="math notranslate nohighlight">\(\land\)</span> or a <span class="math notranslate nohighlight">\(\lor\)</span>.
Applying the corresponding rule, we have either the premises are valid or there is a
counterexample to one of them. In the first case, <span class="math notranslate nohighlight">\(\Gamma\)</span> is valid, and in the
second case, there is a counterexample to the conclusion.</p>
</div>
<p>Notice that this gives us yet another decision procedure for propositional logic:
start with a sequent <span class="math notranslate nohighlight">\(\Gamma\)</span> (which can consist of a single formula, if you want),
and apply the rules backward. If you reach an axiom on each leaf, you have a proof.
If one branch fails to terminate with an axiom, reading off a counterexample to the leaf yields
a counterexample to <span class="math notranslate nohighlight">\(\Gamma\)</span>.
This is an important idea in automated reasoning, namely, it is desirable to search for a proof in
such a way that failure implies the existence of a counterexample.</p>
<p>What we have described is more precisely a <em>cut-free</em> sequent calculus.
It is also sound to add the cut rule:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$\Gamma, A$}
\AXC{$\Gamma, \mathord{\sim}A$}
\BIC{$\Gamma$}
\end{prooftree}\]
</div></div></blockquote>
<p>Here <span class="math notranslate nohighlight">\(\mathord{\sim}A\)</span> is the negation operator for negation-normal form formulas,
which switches <span class="math notranslate nohighlight">\(\land\)</span> and <span class="math notranslate nohighlight">\(\lor\)</span> and switches positive and negative literals.
Proofs with cuts can be more efficient proofs without them, but we have seen that
the calculus is complete without them.</p>
<p>The cut-free sequent calculus is closely related to <em>tableau</em> proof systems that are also commonly
used in automated reasoning.
In the sequent proof above, there is a lot of needless repetition of formulas; tableau representations
do a better job of recording only what changes as we go up the tree.
Another difference is that tableau proof systems usually don’t require that the formulas are in
negation normal form. Rather, the rules of a tableau system correspond to the sequent rules
for the negation-normal-form equivalents. Since <span class="math notranslate nohighlight">\(A \limplies B\)</span> is equivalent to
<span class="math notranslate nohighlight">\(\lnot A \lor B\)</span>,
this requires changing <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(\lnot A\)</span> as we move up the tree. To avoid introducing
new connectives, tableau systems often annotate formulas with emph{polarities},
so that <span class="math notranslate nohighlight">\(A^+\)</span> represents <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(A^-\)</span> represents <span class="math notranslate nohighlight">\(\lnot A\)</span>.
The most jarring difference between sequent calculi and tableau systems is that the latter
are often described in terms of search for a satisfying assignment rather than searching for a proof.
For example, the rule in the sequent calculus that says</p>
<blockquote>
<div><p>to find a proof of <span class="math notranslate nohighlight">\(A \land B\)</span>, split and find a proof of <span class="math notranslate nohighlight">\(A\)</span> and a proof of <span class="math notranslate nohighlight">\(B\)</span></p>
</div></blockquote>
<p>becomes</p>
<blockquote>
<div><p>to find a satisfying assignment to <span class="math notranslate nohighlight">\(A \lor B\)</span>, split and find a satisfying assignment
to <span class="math notranslate nohighlight">\(A\)</span> or a satisfying assignment to <span class="math notranslate nohighlight">\(B\)</span>.</p>
</div></blockquote>
<p>The automated reasoning community is split between people who like to think in terms
of searching for proofs and people who like to think in terms of searching for models.
It is therefore important to learn how to speak both languages,
and to be able to translate between them on the fly.</p>
</section>
<section id="natural-deduction">
<span id="section-natural-deduction"></span><h2><span class="section-number">8.6. </span>Natural deduction<a class="headerlink" href="#natural-deduction" title="Permalink to this heading"></a></h2>
<p>We now consider a type of deductive system that was introduced by Gerhard Gentzen
in the 1930s, known as <em>natural deduction</em>. As the name suggests,
the system was designed to model the way someone might carry out an informal
logical argument.
As a result, the system is not particularly good for automated reasoning and
proof search,
though it might be a good choice if the goal is to find a human-readable proof in the end.
The main interest, rather, is that it provides a nice framework for representing
informal arguments.
Of all the systems we consider in this section, this one is the closest to the
foundation system of logic that is built in to Lean.</p>
<p>In natural deduction, the goal is to derive sequents of the form
<span class="math notranslate nohighlight">\(\Gamma \fCenter A\)</span>,
where <span class="math notranslate nohighlight">\(\Gamma\)</span> is a finite set of formulas and <span class="math notranslate nohighlight">\(A\)</span> is a formula.
The interpretation of such a sequent is, of course, that <span class="math notranslate nohighlight">\(A\)</span> follows
from the hypotheses in <span class="math notranslate nohighlight">\(\Gamma\)</span>.
Notice that we have overloaded the symbol <span class="math notranslate nohighlight">\(\proves\)</span>, which is ordinarily
used to express the provability relation.
The two are clearly related: <span class="math notranslate nohighlight">\(\Gamma\)</span> proves <span class="math notranslate nohighlight">\(A\)</span> in the ordinary
sense is now interpreted as saying that there is a finite subset <span class="math notranslate nohighlight">\(\Gamma' \subseteq \Gamma\)</span> such that the sequent <span class="math notranslate nohighlight">\(\Gamma \fCenter A\)</span> is derivable in natural deduction.
Sometimes people use other notation for sequents, like <span class="math notranslate nohighlight">\(\Gamma \Rightarrow A\)</span>.
But Lean also uses the <span class="math notranslate nohighlight">\(\proves\)</span> symbol for sequents,
so we will stick with that.</p>
<p>We write “<span class="math notranslate nohighlight">\(\Gamma, A\)</span>” for <span class="math notranslate nohighlight">\(\Gamma \cup \{ A \}\)</span> to represent the hypotheses
in <span class="math notranslate nohighlight">\(\Gamma\)</span> together with the additional hypothesis <span class="math notranslate nohighlight">\(A\)</span>.
Similarly, we write “<span class="math notranslate nohighlight">\(\Gamma, \Delta\)</span>” for <span class="math notranslate nohighlight">\(\Gamma \cup \Delta\)</span>.
The first rule is trivial: we always have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$\Gamma, A \fCenter A$.}
\end{prooftree}\]</div></div></blockquote>
<p>This says that <span class="math notranslate nohighlight">\(A\)</span> follows from any list of assumptions that includes <span class="math notranslate nohighlight">\(A\)</span>.
Most of the other connectives include <em>introduction rules</em>,
which allow us to <em>introduce</em> the connective into a proof,
and <em>elimination rules</em>, that tell us how to use them.
For example, the rules for <span class="math notranslate nohighlight">\(\land\)</span> are as follows:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$\Gamma \fCenter A$}
\AXC{$\Delta \fCenter B$}
\BIC{$\Gamma, \Delta \fCenter A \land B$}
\end{prooftree}
\quad \quad
\begin{prooftree}
\AXC{$\Gamma \fCenter A_0 \land A_1$}
\UIC{$\Gamma \fCenter A_i$}
\end{prooftree}
\]</div></div></blockquote>
<p>The rules for implication are as follows:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$\Gamma, A \fCenter B$}
\UIC{$\Gamma \fCenter A \limplies B$}
\end{prooftree}
\quad \quad
\begin{prooftree}
\AXC{$\Gamma \fCenter A \limplies B$}
\AXC{$\Delta \fCenter A$}
\BIC{$\Gamma, \Delta \fCenter B$}
\end{prooftree}
\]</div></div></blockquote>
<p>Notice that in the introduction rule, to prove <span class="math notranslate nohighlight">\(A \limplies B\)</span>, we
temporarily assume <span class="math notranslate nohighlight">\(A\)</span> and show that <span class="math notranslate nohighlight">\(B\)</span> follows.
The rules for disjunction, which codify proof by cases, are as follows:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$\Gamma \fCenter A_i$}
\UIC{$\Gamma \fCenter A_0 \lor A_1$}
\end{prooftree}
\quad \quad
\begin{prooftree}
\AXC{$\Gamma \fCenter A \lor B$}
\AXC{$\Delta, A \fCenter C$}
\AXC{$\Pi, B \fCenter C$}
\TIC{$\Gamma, \Delta, \Pi \fCenter C$}
\end{prooftree}
\]</div></div></blockquote>
<p>For classical logic, we also add the following principle of proof by contradiction:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$\Gamma, \lnot A \fCenter \bot$}
\UIC{$\Gamma \fCenter A$}
\end{prooftree}
\]</div></div></blockquote>
<p>These rules cover a complete set of connectives, since we can define <span class="math notranslate nohighlight">\(\lnot A\)</span>
to be <span class="math notranslate nohighlight">\(A \limplies \bot\)</span>, define <span class="math notranslate nohighlight">\(\top\)</span> to be <span class="math notranslate nohighlight">\(\lnot \bot\)</span>, and
define <span class="math notranslate nohighlight">\(A \liff B\)</span> to be <span class="math notranslate nohighlight">\((A \limplies B) \land (B \limplies A)\)</span>.
You should think about what the natural rules for these connectives would be if we were
to include them in the calculus.</p>
<p>As an example, here is a proof of <span class="math notranslate nohighlight">\(A \limplies (B \limplies A \land B)\)</span>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$A \fCenter A$}
\AXC{$B \fCenter B$}
\BIC{$A, B \fCenter A \land B$}
\UIC{$A \fCenter B \limplies A \land B$}
\UIC{$\fCenter A \limplies (B \limplies A \land B)$}
\end{prooftree}
\]</div></div></blockquote>
<p>And here is a proof of <span class="math notranslate nohighlight">\(A \land B \limplies B \land A\)</span>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$A \land B \fCenter A \land B$}
\UIC{$A \land B \fCenter B$}
\AXC{$A \land B \fCenter A \land B$}
\UIC{$A \land B \fCenter A$}
\BIC{$A \land B \fCenter B \land A$}
\UIC{$\fCenter A \land B \limplies B \land A$}
\end{prooftree}
\]</div></div></blockquote>
<p>As with the sequent calculus, there are more efficient ways of representing
natural deduction proofs that only show the conclusion at each node and
leave the hypotheses implicit.
This avoids having to repeat a long list of hypotheses at every node.
There are also presentations of sequent calculi for classical logic that use
two-sided sequents, as we did for natural deduction.
The most effective approach is to use sequents of the
form <span class="math notranslate nohighlight">\(\Gamma \fCenter \Delta\)</span>, where <span class="math notranslate nohighlight">\(\Gamma\)</span> and <span class="math notranslate nohighlight">\(\Delta\)</span>
are finite sets and we interpret the sequent as saying that if all the hypotheses
in <span class="math notranslate nohighlight">\(\Gamma\)</span> are true, then at least one of the formulas in <span class="math notranslate nohighlight">\(\Delta\)</span> is true.
This is aligned with the annotations of positive and negative formulas that one
sometimes finds in tableau calculi.</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>Natural deduction is sound and complete for classical propositional logic.
In other words, a sequent <span class="math notranslate nohighlight">\(\Gamma \fCenter A\)</span> is derivable if and only
if <span class="math notranslate nohighlight">\(\Gamma \models A\)</span>.</p>
</div>
<p>We will not take the time to prove this here. One way to prove it is to
show that natural deduction can simulate another calculus, like the sequent calculus,
for which a completeness proof is easier.</p>
<p>One reason for our interest in natural deduction is that it is the basis for Lean’s
internal proof language. In the next chapter, we will start to learn how to write
proofs in Lean, and it will be helpful to understand the instructions we provide the
system as instructions for constructing natural deduction derivations.</p>
</section>
<section id="compactness">
<span id="section-compactness"></span><h2><span class="section-number">8.7. </span>Compactness<a class="headerlink" href="#compactness" title="Permalink to this heading"></a></h2>
<p>In automated reasoning, when we write <span class="math notranslate nohighlight">\(\Gamma \models A\)</span> to express
that <span class="math notranslate nohighlight">\(A\)</span> is entailed by hypotheses in <span class="math notranslate nohighlight">\(\Gamma\)</span>,
we generally have the in mind case where <span class="math notranslate nohighlight">\(\Gamma\)</span> is finite.
But the definition makes sense when <span class="math notranslate nohighlight">\(\Gamma\)</span> is infinite.
The same is true in the when we talk about provability of <span class="math notranslate nohighlight">\(A\)</span>
from a set of hypotheses <span class="math notranslate nohighlight">\(\Gamma\)</span>.
Now, in the case of provability, it is clear that for any set <span class="math notranslate nohighlight">\(\Gamma\)</span>,
finite or infinite, <span class="math notranslate nohighlight">\(\Gamma \proves A\)</span> if and only if there is a finite
subset <span class="math notranslate nohighlight">\(\Gamma' \subseteq \Gamma\)</span> such that <span class="math notranslate nohighlight">\(\Gamma' \proves A\)</span>.
The corresponding fact about the entailment relation is also true:</p>
<div class="admonition-theorem-the-compactness-theorem-for-propositional-logic admonition">
<p class="admonition-title">Theorem (the compactness theorem for propositional logic)</p>
<p>For any set of propositional formulas <span class="math notranslate nohighlight">\(\Gamma\)</span>,
<span class="math notranslate nohighlight">\(\Gamma \models A\)</span> if and only if there is a finite
subset <span class="math notranslate nohighlight">\(\Gamma' \subseteq \Gamma\)</span> such that <span class="math notranslate nohighlight">\(\Gamma' \models A\)</span>.</p>
</div>
<p>In this chapter, we focused on the soundness and completeness theorems in the
case where <span class="math notranslate nohighlight">\(\Gamma\)</span> is finite.
But soundness carries over straightforwardly to the infinite case,
and it is possible to prove completeness for arbitrary <span class="math notranslate nohighlight">\(\Gamma\)</span> as well.
You can check that compactness follows from these stronger versions of soundness
and completeness, given the fact that any proof can use only a finite number of hypotheses.
Conversely, the stronger versions of the completeness theorem
follows from the weaker one using the compactness theorem.</p>
<p>As an example of an application of the compactness theorem, imagine a
finite set of oriented square tiles <span class="math notranslate nohighlight">\(S\)</span>, all the same size, where “oriented” means that
each has is a distinguished top edge.
Suppose each edge of each tile is labeled with finitely many colors.
A <em>tiling of the plane</em> with tiles from <span class="math notranslate nohighlight">\(S\)</span> is an ordinary arrangement of (copies of) tiles in <span class="math notranslate nohighlight">\(S\)</span> in an infinite square grid,
like the squares on an infinite sheet of graph paper,
such that adjacent edges have the same color.</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>Suppose that for every natural number <span class="math notranslate nohighlight">\(n\)</span>, there is an <span class="math notranslate nohighlight">\(n \times n\)</span>
tiling with tiles from <span class="math notranslate nohighlight">\(S\)</span>. Then there is a tiling of the entire
plane with tiles from <span class="math notranslate nohighlight">\(S\)</span>.</p>
</div>
<p>You should think about how this follows from the compactness theorem.</p>
</section>
<section id="exercises">
<h2><span class="section-number">8.8. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading"></a></h2>
<ol class="arabic">
<li><p>Using only axioms 1 and 2 from <a class="reference internal" href="#section-axiomatic-systems"><span class="std std-numref">Section 8.1</span></a>
and modus ponens, show how to derive <span class="math notranslate nohighlight">\(p \to p\)</span>. (It is surprisingly
tricky, but you can do it in 5 lines.)</p></li>
<li><p>Give a resolution refutation of the following list of clauses:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(p \lor q \lor \lnot r\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot p \lor \lnot q \lor r\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(q \lor r  \lor \lnot s\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot q \lor \lnot r \lor s\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(p \lor r \lor s\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot p \lor \lnot r \lor \lnot s\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot p \lor q \lor s\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(p \lor \lnot q \lor \lnot s\)</span>.</p></li>
</ol>
<p>Present your solution as a list of clauses extending the list of starting
clauses, so the first one you derive is numbered 9. For each one,
specify the two clauses that serve as input to the resolution rule by indicating their numbers.
(There is a solution with 11 additional clauses, for a total of 19.)</p>
</li>
<li><p>In <a class="reference internal" href="#section-resolution"><span class="std std-numref">Section 8.2</span></a>, we outline a method for extracting a resolution refutation
of a set of clauses, <span class="math notranslate nohighlight">\(\Gamma\)</span>, from a failed search.
The method relies on the following claim:</p>
<blockquote>
<div><p>If there are a resolution proof of a clause <span class="math notranslate nohighlight">\(C\)</span> from <span class="math notranslate nohighlight">\(\Gamma\)</span> such that
<span class="math notranslate nohighlight">\(\tval{C}_{\tau[p \mapsto \top]} = \bot\)</span>
and a resolution proof of a clause <span class="math notranslate nohighlight">\(D\)</span> from <span class="math notranslate nohighlight">\(\Gamma\)</span> such that
<span class="math notranslate nohighlight">\(\tval{D}_{\tau[p \mapsto \bot]} = \bot\)</span>,
then there is a resolution proof of a clause <span class="math notranslate nohighlight">\(E\)</span> from <span class="math notranslate nohighlight">\(\Gamma\)</span> such that
<span class="math notranslate nohighlight">\(\tval{E}_\tau = \bot\)</span>.</p>
</div></blockquote>
<p>Here <span class="math notranslate nohighlight">\(\tau\)</span> is a partial truth assignment and the notation <span class="math notranslate nohighlight">\(\tval{C}_\tau\)</span> refers to the simplification of the
clause <span class="math notranslate nohighlight">\(C\)</span> with respect to assignment <span class="math notranslate nohighlight">\(\tau\)</span> that is described in <a class="reference internal" href="decision_procedures_for_propositional_logic.html#section-unit-propagation-and-the-pure-literal-rule"><span class="std std-numref">Section 6.2</span></a>.</p>
<p>Prove this claim.</p>
</li>
<li><p>Using the cut-free sequent calculus described in <a class="reference internal" href="#section-propositional-sequent-calculus"><span class="std std-numref">Section 8.5</span></a>,
either construct a proof of the following sequent or use the methods described
in that section to find a counterexample:</p>
<div class="math notranslate nohighlight">
\[((p \lor q) \to r) \lor ((r \to p) \land (r \to q)).\]</div>
</li>
</ol>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="using_sat_solvers.html" class="btn btn-neutral float-left" title="7. Using SAT Solvers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="propositional_logic_in_lean.html" class="btn btn-neutral float-right" title="9. Propositional Logic in Lean" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>