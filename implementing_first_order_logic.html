<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>11. Implementing First-Order Logic &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=0731ccc3" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=2709fde1"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script>window.MathJax = {"loader": {"load": ["[tex]/bussproofs"]}, "tex": {"packages": {"[+]": ["bussproofs"]}, "macros": {"fn": ["\\mathit{#1}", 1], "fa": ["\\forall #1. \\,", 1], "ex": ["\\exists #1. \\,", 1], "bN": "{\\mathbb{N}}", "bZ": "{\\mathbb{Z}}", "bR": "{\\mathbb{R}}", "limplies": "\\to", "liff": "\\leftrightarrow", "proves": "\\vdash", "append": "\\mathbin{+\\mkern-10mu+}", "tval": ["[\\![#1]\\!]", 1], "fCenter": "\\proves", "mdl": ["\\mathfrak{#1}", 1]}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="12. Decision Procedures for First-Order Logic" href="decision_procedures_for_first_order_logic.html" />
    <link rel="prev" title="10. First-Order Logic" href="first_order_logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Logic and Mechanized Reasoning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_propositional_logic.html">8. Proof Systems for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_proof_assistant.html">9. Using Lean as a Proof Assistant</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11. Implementing First-Order Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#terms">11.1. Terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#evaluating-terms">11.2. Evaluating terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#formulas">11.3. Formulas</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unification">11.4. Unification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_first_order_logic.html">12. Decision Procedures for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">13. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_first_order_logic.html">14. Proof Systems for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">15. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="beyond_first_order_logic.html">16. Beyond First-Order Logic</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">11. </span>Implementing First-Order Logic</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/implementing_first_order_logic.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="implementing-first-order-logic">
<span id="chapter-implementing-first-order-logic"></span><h1><span class="section-number">11. </span>Implementing First-Order Logic<a class="headerlink" href="#implementing-first-order-logic" title="Link to this heading"></a></h1>
<p>Our implementation of first-order logic in Lean is similar to our implementation of
propositional logic in Lean,
covering both the syntax and the semantics.
We will also show how to implement <em>unification</em>, and algorithm that is fundamental
to the mechanization of first-order reasoning.</p>
<section id="terms">
<h2><span class="section-number">11.1. </span>Terms<a class="headerlink" href="#terms" title="Link to this heading"></a></h2>
<p>Our implementation of terms is straightforward.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">FOTerm</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">FOTerm</span>
  <span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">FOTerm</span> <span class="bp">→</span> <span class="n">FOTerm</span>
  <span class="n">deriving</span> <span class="n">Repr</span><span class="o">,</span> <span class="n">Inhabited</span><span class="o">,</span> <span class="n">BEq</span>
</pre></div>
</div>
<p>A term is either a variable or a function symbol applied to a list of
terms.
We have defined syntax for <cite>FOTerm</cite>:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">ex1</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="bp">%</span><span class="n">x</span> <span class="o">}</span>
<span class="kd">def</span> <span class="n">ex2</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">c</span> <span class="o">}</span>
<span class="kd">def</span> <span class="n">ex3</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="bp">%</span><span class="n">x</span><span class="o">),</span> <span class="n">f</span><span class="o">(</span><span class="n">g</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">,</span> <span class="n">d</span><span class="o">)),</span> <span class="n">b</span><span class="o">))</span> <span class="o">}</span>

<span class="k">#print</span> <span class="n">ex1</span>
<span class="k">#print</span> <span class="n">ex2</span>
<span class="k">#print</span> <span class="n">ex3</span>

<span class="k">#eval</span> <span class="n">ex1</span>
<span class="k">#eval</span> <span class="n">ex2</span>
<span class="k">#eval</span> <span class="n">ex3</span>
</pre></div>
</div>
<p>The notation <cite>%x</cite> is used for a variable. Notice that a constant like <cite>c</cite> is represented
as an application of the symbol to the empty list. Notice also that the definition
does nothing to check the arity of the function symbols.
Ordinarily, first-order logic allows us to specify that <cite>f</cite> and
<cite>g</cite> are binary functions and that another function, <cite>h</cite>, is unary.
Our definition of <cite>FOTerm</cite> allows the application of any string to any number
of arguments.
This simplifies a number of aspects of the implementation.
As an exercise, you might want to write a function <cite>well-formed</cite> in Lean that,
given a specification of a list of symbols and their arities,
checks that an <cite>FOTerm</cite> uses only those symbols and with the correct arity.
Later in the course, we will talk about systems more expressive than
first-order logic that provide other ways of specifying
a function’s intended arguments.
Lean’s type system provides a very elaborate and expressive means for doing so,
and you can think of the specification of arities in first-order logic as being
a minimal form of a typing judgment.</p>
<p>Remember that to evaluate a first-order language, we need an assignment of values to the variables,
as well as interpretations of the function and relation symbols.
Since our symbols are identified as strings,
in general an interpretation of symbols is an assignment of values to strings:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">FOAssignment</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">String</span> <span class="bp">→</span> <span class="n">α</span>
</pre></div>
</div>
<p>Any function definable in Lean can serve this purpose.
Keep in mind that we have to fix a type <cite>α</cite>, corresponding to the universe
of the structure in which we carry out the interpretation.</p>
<p>Since it is often useful to specify an assignment by giving a finite list of values,
we have implemented syntax for that:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">x</span> <span class="bp">↦</span> <span class="mi">3</span><span class="o">,</span> <span class="n">y</span> <span class="bp">↦</span> <span class="mi">5</span><span class="o">,</span> <span class="n">z</span> <span class="bp">↦</span> <span class="mi">2</span><span class="o">}</span>
</pre></div>
</div>
<p>You can type the symbol <cite>↦</cite> as <cite>\mapsto</cite>.
Formally, the notation produces an <em>association list</em>, essentially just a list of
key / value pairs.
But we have also told Lean how to coerce such an association list to an <cite>FOAssignment</cite>
when necessary.
The following examples provide a few different Lean idioms for specifying that
an <cite>assign!</cite> expression should be interpreted as an <cite>FOAssignment</cite>.
(It should also happen automatically when you pass such an expression as an argument
to a function that expects an <cite>FOAssignment</cite>.)</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">assign1</span> <span class="o">:</span> <span class="n">FOAssignment</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">x</span> <span class="bp">↦</span> <span class="mi">3</span><span class="o">,</span> <span class="n">y</span> <span class="bp">↦</span> <span class="mi">5</span><span class="o">,</span> <span class="n">z</span> <span class="bp">↦</span> <span class="mi">2</span><span class="o">}</span>
<span class="k">#check</span> <span class="n">assign1</span>
<span class="k">#eval</span>  <span class="n">assign1</span> <span class="s2">&quot;x&quot;</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">x</span> <span class="bp">↦</span> <span class="mi">3</span><span class="o">,</span> <span class="n">y</span> <span class="bp">↦</span> <span class="mi">5</span><span class="o">,</span> <span class="n">z</span> <span class="bp">↦</span> <span class="mi">2</span><span class="o">}</span> <span class="o">:</span> <span class="n">FOAssignment</span> <span class="n">Nat</span><span class="o">)</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">id</span> <span class="o">(</span><span class="n">FOAssignment</span> <span class="n">Nat</span><span class="o">)</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">x</span> <span class="bp">↦</span> <span class="mi">3</span><span class="o">,</span> <span class="n">y</span> <span class="bp">↦</span> <span class="mi">5</span><span class="o">,</span> <span class="n">z</span> <span class="bp">↦</span> <span class="mi">2</span><span class="o">}</span>

<span class="k">#check</span> <span class="k">show</span> <span class="n">FOAssignment</span> <span class="n">Nat</span> <span class="k">from</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">x</span> <span class="bp">↦</span> <span class="mi">3</span><span class="o">,</span> <span class="n">y</span> <span class="bp">↦</span> <span class="mi">5</span><span class="o">,</span> <span class="n">z</span> <span class="bp">↦</span> <span class="mi">2</span><span class="o">}</span>

<span class="k">#check</span> <span class="k">let</span> <span class="n">this</span> <span class="o">:</span> <span class="n">FOAssignment</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">x</span> <span class="bp">↦</span> <span class="mi">3</span><span class="o">,</span> <span class="n">y</span> <span class="bp">↦</span> <span class="mi">5</span><span class="o">,</span> <span class="n">z</span> <span class="bp">↦</span> <span class="mi">2</span><span class="o">}</span>
       <span class="n">this</span>
</pre></div>
</div>
<p>It is now easy to define substitution for terms. Such a function should take
a term and an assignment of terms to variables, and replace the variables by the
assigned terms.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">partial</span> <span class="kd">def</span> <span class="n">subst</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">FOAssignment</span> <span class="n">FOTerm</span><span class="o">)</span> <span class="o">:</span> <span class="n">FOTerm</span> <span class="bp">→</span> <span class="n">FOTerm</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="n">x</span>   <span class="bp">=&gt;</span> <span class="n">σ</span> <span class="n">x</span>
  <span class="bp">|</span> <span class="n">app</span> <span class="n">f</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">app</span> <span class="n">f</span> <span class="o">(</span><span class="n">l.map</span> <span class="o">(</span><span class="n">subst</span> <span class="n">σ</span><span class="o">))</span>
</pre></div>
</div>
<p>Here we try it out:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">ex3.subst</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">x</span> <span class="bp">↦</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span><span class="n">h</span><span class="o">(</span><span class="n">a</span><span class="o">)},</span> <span class="n">y</span> <span class="bp">↦</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">h</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">d</span><span class="o">)}}</span>
</pre></div>
</div>
</section>
<section id="evaluating-terms">
<h2><span class="section-number">11.2. </span>Evaluating terms<a class="headerlink" href="#evaluating-terms" title="Link to this heading"></a></h2>
<p>To evaluate a term, we need not only an assignment of values to the variables
occurring in the term, but also an interpretation of all the function symbols.
Setting aside concerns about arities, we can interpret any
function taking some number of elements of <cite>α</cite> to <cite>α</cite> as an element of type
<cite>List α → α</cite>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="sd">/-- an interpretation of function symbols -/</span>
<span class="kd">def</span> <span class="n">FnInterp</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">FOAssignment</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="c1">-- coerces an association list to a function</span>
<span class="kd">instance</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">Coe</span> <span class="o">(</span><span class="n">AssocList</span> <span class="n">String</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">))</span> <span class="o">(</span><span class="n">FnInterp</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="k">fun</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">l.getA</span><span class="o">⟩</span>
</pre></div>
</div>
<p>If a function is intended to be used as a binary function,
we really care about the interpretation when it is applied to lists of
length two.
In our quick-and-dirty implementation, we have to define values for lists
of other lengths, but any values will do. For example,
we can define an interpretation of constants and functions on the natural numbers
as follows:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">arithFnInterp</span> <span class="o">:</span> <span class="n">FnInterp</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="s2">&quot;plus&quot;</span>  <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">l.getA</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">l.getA</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="s2">&quot;times&quot;</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">l.getA</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">l.getA</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="s2">&quot;zero&quot;</span>  <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="s2">&quot;one&quot;</span>   <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
  <span class="bp">|</span> <span class="s2">&quot;two&quot;</span>   <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">2</span>
  <span class="bp">|</span> <span class="s2">&quot;three&quot;</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">3</span>
  <span class="bp">|</span> <span class="n">_</span>       <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">default</span>
</pre></div>
</div>
<p>Or, alternatively:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">arithFnInterp&#39;</span> <span class="o">:</span> <span class="n">FnInterp</span> <span class="n">Nat</span> <span class="o">:=</span>
<span class="n">assign</span><span class="bp">!</span><span class="o">{</span>
  <span class="n">plus</span> <span class="bp">↦</span> <span class="k">fun</span> <span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">=&gt;</span> <span class="n">l.getA</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">l.getA</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">times</span> <span class="bp">↦</span> <span class="k">fun</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">l.getA</span> <span class="mi">0</span> <span class="bp">*</span> <span class="n">l.getA</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">zero</span> <span class="bp">↦</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">one</span> <span class="bp">↦</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">two</span> <span class="bp">↦</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">three</span> <span class="bp">↦</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">3</span> <span class="o">}</span>
</pre></div>
</div>
<p>With <cite>FnInterp</cite> in place, it is easy to define a function that evaluates terms:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="sd">/-- evaluate a term relative to a variable assignment -/</span>
<span class="n">partial</span> <span class="kd">def</span> <span class="n">eval</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">fn</span> <span class="o">:</span> <span class="n">FnInterp</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">FOAssignment</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">FOTerm</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="n">x</span>   <span class="bp">=&gt;</span> <span class="n">σ</span> <span class="n">x</span>
  <span class="bp">|</span> <span class="n">app</span> <span class="n">f</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">fn</span> <span class="n">f</span> <span class="o">(</span><span class="n">l.map</span> <span class="o">(</span><span class="n">eval</span> <span class="n">fn</span> <span class="n">σ</span><span class="o">))</span>
</pre></div>
</div>
<p>Even though the function always terminates, Lean 4 is not yet able to prove
termination automatically, so we use the keyword <cite>partial</cite>.
Let’s try it out.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">arith_ex1</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">plus</span><span class="o">(</span><span class="n">times</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="n">two</span><span class="o">),</span> <span class="n">plus</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">,</span> <span class="n">three</span><span class="o">))</span> <span class="o">}</span>

<span class="k">#eval</span> <span class="n">arith_ex1.eval</span> <span class="n">arithFnInterp</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span> <span class="n">x</span> <span class="bp">↦</span> <span class="mi">3</span><span class="o">,</span> <span class="n">y</span> <span class="bp">↦</span> <span class="mi">5</span> <span class="o">}</span>
<span class="k">#eval</span> <span class="n">arith_ex1.eval</span> <span class="n">arithFnInterp</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span> <span class="n">x</span> <span class="bp">↦</span> <span class="mi">7</span><span class="o">,</span> <span class="n">y</span> <span class="bp">↦</span> <span class="mi">11</span> <span class="o">}</span>
</pre></div>
</div>
<p>When we talked about propositional logic, we proved a theorem that says
that evaluating the result of a substitution is the same as
evaluating the original formula relative to an assignment of the values
of the substituted formula. In the context of terms, the identity is as follows:</p>
<div class="math notranslate nohighlight">
\[\tval{t[s/x]}_\sigma = \tval{t}_{\sigma[x \mapsto \tval{s}_\sigma]}.\]</div>
<p>The proof is essentially the same.
Our current implementation is more general in that it allows us to
substitute multiple terms at once,
but we can see the principle at play in the fact that the two evaluations
below produce the same answer.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">arith_ex2</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">plus</span><span class="o">(</span><span class="n">one</span><span class="o">,</span> <span class="n">times</span><span class="o">(</span><span class="n">three</span><span class="o">,</span> <span class="bp">%</span><span class="n">z</span><span class="o">))}</span>

<span class="kd">def</span> <span class="n">arith_ex3</span> <span class="o">:=</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">plus</span><span class="o">(</span><span class="bp">%</span><span class="n">z</span><span class="o">,</span> <span class="n">two</span><span class="o">)</span> <span class="o">}</span>

<span class="c1">-- these two should give the same result!</span>

<span class="k">#eval</span> <span class="o">(</span><span class="n">arith_ex1.subst</span>
        <span class="n">assign</span><span class="bp">!</span><span class="o">{</span> <span class="n">x</span> <span class="bp">↦</span> <span class="n">arith_ex2</span><span class="o">,</span> <span class="n">y</span> <span class="bp">↦</span> <span class="n">arith_ex3</span> <span class="o">})</span><span class="bp">.</span><span class="n">eval</span>
        <span class="n">arithFnInterp</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">z</span> <span class="bp">↦</span> <span class="mi">7</span><span class="o">}</span>

<span class="k">#eval</span> <span class="n">arith_ex1.eval</span> <span class="n">arithFnInterp</span>
  <span class="n">assign</span><span class="bp">!</span><span class="o">{</span> <span class="n">x</span> <span class="bp">↦</span> <span class="o">(</span><span class="n">arith_ex2.eval</span> <span class="n">arithFnInterp</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">z</span> <span class="bp">↦</span> <span class="mi">7</span><span class="o">}),</span>
           <span class="n">y</span> <span class="bp">↦</span> <span class="o">(</span><span class="n">arith_ex3.eval</span> <span class="n">arithFnInterp</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">z</span> <span class="bp">↦</span> <span class="mi">7</span><span class="o">})</span> <span class="o">}</span>
</pre></div>
</div>
<p>And here is another crazy idea: we can view substitution as the result
of evaluating a term in a model where the universe consists of terms,
and where each function symbol <cite>f</cite> is interpreted
as the function “build a term by applying <cite>f</cite>.”</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">TermFnInterp</span> <span class="o">:</span> <span class="n">FnInterp</span> <span class="n">FOTerm</span> <span class="o">:=</span> <span class="n">FOTerm.app</span>

<span class="kd">def</span> <span class="n">FOTerm.subst&#39;</span> <span class="o">:=</span> <span class="n">eval</span> <span class="n">TermFnInterp</span>

<span class="c1">-- the same!</span>
<span class="k">#eval</span> <span class="n">arith_ex1.subst</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span> <span class="n">x</span> <span class="bp">↦</span> <span class="n">arith_ex2</span><span class="o">,</span> <span class="n">y</span> <span class="bp">↦</span> <span class="n">arith_ex3</span> <span class="o">}</span>
<span class="k">#eval</span> <span class="n">arith_ex1.subst&#39;</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span> <span class="n">x</span> <span class="bp">↦</span> <span class="n">arith_ex2</span><span class="o">,</span> <span class="n">y</span> <span class="bp">↦</span> <span class="n">arith_ex3</span>  <span class="o">}</span>
</pre></div>
</div>
<p>You should think about what is going on here. Such a model is known as a
<em>term model</em>.</p>
</section>
<section id="formulas">
<h2><span class="section-number">11.3. </span>Formulas<a class="headerlink" href="#formulas" title="Link to this heading"></a></h2>
<p>Since the universe of a first-order model may be infinite, we would not
expect to be able to evaluate arbitrary first-order formulas in
an arbitrary model.
Evaluating quantifiers in our model of arithmetic would require
testing instantiations to all the natural numbers.
If we could do that, we could easily settle the truth of the sentence</p>
<div class="math notranslate nohighlight">
\[\fa x \ex y y &gt; x \land \fn{prime}(y) \land \fn{prime}(y + 2),\]</div>
<p>which says that there are infinitely many values <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(y\)</span>
and <span class="math notranslate nohighlight">\(y + 2\)</span> are both prime.
This is known as the <em>twin primes conjecture</em>, and it is a major open question
in number theory.</p>
<p>We can, however, evaluate quantifiers over finite universes. In the definition
of a first-order model below,
we assume that the universe is given by a finite list of values.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="sd">/-- an interpretation of relation symbols -/</span>
<span class="kd">def</span> <span class="n">RelInterp</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">FOAssignment</span> <span class="o">(</span><span class="n">List</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Bool</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">FOModel</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="n">where</span>
  <span class="o">(</span><span class="n">univ</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">fn</span> <span class="o">:</span> <span class="n">FnInterp</span> <span class="n">α</span><span class="o">)</span>
  <span class="o">(</span><span class="n">rel</span> <span class="o">:</span> <span class="n">RelInterp</span> <span class="n">α</span><span class="o">)</span>
</pre></div>
</div>
<p>In our quick-and-dirty implementation, we don’t require that
the universe <cite>univ</cite> is closed under the functions. In other words,
it’s possible that we can apply a function to some elements on the list <cite>univ</cite>
and get something that isn’t in the list.
It wouldn’t be hard to write a procedure that checks that, given a finite
list of functions and their intended arities.
(A more efficient way of handling this is instead to <em>prove</em> that the
functions all return values in universe,
using Lean’s theorem proving capabilities.)
In the examples in this section, we won’t use function symbols at all,
except for some constants that are clearly o.k.</p>
<p>To handle the quantifiers, we need a procedure that takes an assignment
<span class="math notranslate nohighlight">\(\sigma\)</span> and produces an updated assignment <span class="math notranslate nohighlight">\(\sigma[x \mapsto v]\)</span>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">FOAssignment.update</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">FOAssignment</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">FOAssignment</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="n">y</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">y</span> <span class="bp">==</span> <span class="n">x</span> <span class="k">then</span> <span class="n">v</span> <span class="k">else</span> <span class="n">σ</span> <span class="n">y</span>
</pre></div>
</div>
<p>With that in hand, the evaluation function is entirely straightforward.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">FOForm.eval</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">[</span><span class="n">Inhabited</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">BEq</span> <span class="n">α</span><span class="o">]</span>
    <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">FOModel</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">σ</span> <span class="o">:</span> <span class="n">FOAssignment</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">FOForm</span> <span class="bp">→</span> <span class="n">Bool</span>
  <span class="bp">|</span> <span class="n">eq</span> <span class="n">t1</span> <span class="n">t2</span> <span class="bp">=&gt;</span> <span class="n">t1.eval</span> <span class="n">M.fn</span> <span class="n">σ</span> <span class="bp">==</span> <span class="n">t2.eval</span> <span class="n">M.fn</span> <span class="n">σ</span>
  <span class="bp">|</span> <span class="n">rel</span> <span class="n">r</span> <span class="n">ts</span> <span class="bp">=&gt;</span>  <span class="n">M.rel</span> <span class="n">r</span> <span class="o">(</span><span class="n">ts.map</span> <span class="bp">&lt;|</span> <span class="n">FOTerm.eval</span> <span class="n">M.fn</span> <span class="n">σ</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">tr</span> <span class="bp">=&gt;</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="n">fls</span> <span class="bp">=&gt;</span> <span class="n">false</span>
  <span class="bp">|</span> <span class="n">neg</span> <span class="n">A</span> <span class="bp">=&gt;</span> <span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">M</span> <span class="n">σ</span> <span class="n">A</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">conj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">eval</span> <span class="n">M</span> <span class="n">σ</span> <span class="n">A</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">eval</span> <span class="n">M</span> <span class="n">σ</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">disj</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">eval</span> <span class="n">M</span> <span class="n">σ</span> <span class="n">A</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">M</span> <span class="n">σ</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">impl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">M</span> <span class="n">σ</span> <span class="n">A</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">M</span> <span class="n">σ</span> <span class="n">B</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">biImpl</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">M</span> <span class="n">σ</span> <span class="n">A</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">M</span> <span class="n">σ</span> <span class="n">B</span><span class="o">))</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="bp">!</span><span class="o">(</span><span class="n">eval</span> <span class="n">M</span> <span class="n">σ</span> <span class="n">B</span><span class="o">)</span> <span class="bp">||</span> <span class="o">(</span><span class="n">eval</span> <span class="n">M</span> <span class="n">σ</span> <span class="n">A</span><span class="o">))</span>
  <span class="bp">|</span> <span class="n">ex</span> <span class="n">x</span> <span class="n">A</span> <span class="bp">=&gt;</span> <span class="n">M.univ.any</span> <span class="k">fun</span> <span class="n">val</span> <span class="bp">=&gt;</span> <span class="n">eval</span> <span class="n">M</span> <span class="o">(</span><span class="n">σ.update</span> <span class="n">x</span> <span class="n">val</span><span class="o">)</span> <span class="n">A</span>
  <span class="bp">|</span> <span class="n">all</span> <span class="n">x</span> <span class="n">A</span> <span class="bp">=&gt;</span> <span class="n">M.univ.all</span> <span class="k">fun</span> <span class="n">val</span> <span class="bp">=&gt;</span> <span class="n">eval</span> <span class="n">M</span> <span class="o">(</span><span class="n">σ.update</span> <span class="n">x</span> <span class="n">val</span><span class="o">)</span> <span class="n">A</span>
</pre></div>
</div>
<p>Let’s try it out on a baby model of arithmetic that only has the numbers
0 to 9 in the universe.
We reuse the function interpretation <cite>arithFnInterp</cite> from before, so that we
have the constants <cite>zero</cite>, <cite>one</cite>, <cite>two</cite>, and <cite>three</cite>.
The interpretation also gives us addition and multiplication, but we won’t use those.
As far as relations, we interpret two: the binary less-than relation <cite>lt</cite>
and the predicate <cite>even</cite>.
We also define the trivial assignment which assigns 0 to all the variables.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">babyArithMdl</span> <span class="o">:</span> <span class="n">FOModel</span> <span class="n">Nat</span> <span class="n">where</span>
  <span class="n">univ</span> <span class="o">:=</span> <span class="n">List.range</span> <span class="mi">10</span>  <span class="c">/-</span><span class="cm"> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 -/</span>
  <span class="n">fn</span>   <span class="o">:=</span> <span class="n">arithFnInterp</span>
  <span class="n">rel</span>  <span class="o">:=</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span>
            <span class="n">lt</span> <span class="bp">↦</span> <span class="k">fun</span> <span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">l.getA</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">l.getA</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">true</span> <span class="k">else</span> <span class="n">false</span><span class="o">,</span>
            <span class="n">even</span> <span class="bp">↦</span> <span class="k">fun</span> <span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">=&gt;</span> <span class="n">l.getA</span> <span class="mi">0</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">==</span> <span class="mi">0</span> <span class="o">}</span>

<span class="kd">def</span> <span class="n">trivAssignment</span> <span class="o">:</span> <span class="n">FOAssignment</span> <span class="n">Nat</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>We can try it out:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)}</span><span class="bp">.</span><span class="n">eval</span> <span class="n">babyArithMdl</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">x</span> <span class="bp">↦</span> <span class="mi">5</span><span class="o">}</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)}</span><span class="bp">.</span><span class="n">eval</span> <span class="n">babyArithMdl</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">x</span> <span class="bp">↦</span> <span class="mi">6</span><span class="o">}</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∃</span> <span class="n">y.</span> <span class="n">lt</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">)}</span><span class="bp">.</span><span class="n">eval</span> <span class="n">babyArithMdl</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">x</span> <span class="bp">↦</span> <span class="mi">8</span><span class="o">}</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∃</span> <span class="n">y.</span> <span class="n">lt</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">)}</span><span class="bp">.</span><span class="n">eval</span> <span class="n">babyArithMdl</span> <span class="n">assign</span><span class="bp">!</span><span class="o">{</span><span class="n">x</span> <span class="bp">↦</span> <span class="mi">9</span><span class="o">}</span>
</pre></div>
</div>
<p>It’s an unpleasant feature of our syntax that we have to put a percent sign
in front of variables in order to distinguish them from constants,
while we do not use the percent sign with the quantifiers.
To facilitate testing sentences, we write a simple function <cite>testeval</cite>
that evaluates any formula in our model with respect to the trivial variable assignment.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">FOForm.testeval</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">FOForm</span><span class="o">)</span> <span class="o">:</span> <span class="n">Bool</span> <span class="o">:=</span> <span class="n">A.eval</span> <span class="n">babyArithMdl</span> <span class="n">trivAssignment</span>

<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="n">even</span><span class="o">(</span><span class="n">two</span><span class="o">)}</span><span class="bp">.</span><span class="n">testeval</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="n">even</span><span class="o">(</span><span class="n">three</span><span class="o">)}</span><span class="bp">.</span><span class="n">testeval</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∃</span> <span class="n">x.</span> <span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)}</span><span class="bp">.</span><span class="n">testeval</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∀</span> <span class="n">x.</span> <span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)}</span><span class="bp">.</span><span class="n">testeval</span>

<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∃</span> <span class="n">x.</span> <span class="n">lt</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="n">two</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)}</span><span class="bp">.</span><span class="n">testeval</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∃</span> <span class="n">x.</span> <span class="bp">∃</span> <span class="n">y.</span> <span class="n">lt</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">lt</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">,</span> <span class="n">two</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">)}</span><span class="bp">.</span><span class="n">testeval</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∀</span> <span class="n">x.</span> <span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">lt</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span><span class="n">two</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">%</span><span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span><span class="o">}</span><span class="bp">.</span><span class="n">testeval</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∀</span> <span class="n">x.</span> <span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">lt</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span><span class="n">three</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">%</span><span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span><span class="o">}</span><span class="bp">.</span><span class="n">testeval</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∀</span> <span class="n">x.</span> <span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">lt</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span><span class="n">three</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">%</span><span class="n">x</span> <span class="bp">=</span> <span class="n">zero</span> <span class="bp">∨</span> <span class="bp">%</span><span class="n">x</span> <span class="bp">=</span> <span class="n">two</span><span class="o">}</span><span class="bp">.</span><span class="n">testeval</span>

<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∀</span> <span class="n">x.</span> <span class="bp">∃</span> <span class="n">y.</span> <span class="n">lt</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">)}</span><span class="bp">.</span><span class="n">testeval</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∀</span> <span class="n">x.</span> <span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y.</span> <span class="n">lt</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">)}</span><span class="bp">.</span><span class="n">testeval</span>
<span class="k">#eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∀</span> <span class="n">x.</span> <span class="bp">¬</span> <span class="n">even</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y.</span> <span class="n">lt</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">)}</span><span class="bp">.</span><span class="n">testeval</span>
</pre></div>
</div>
<p>A software package called <em>Tarski’s World</em> by Jon Barwise and John Etchemendy offers
a fun way of experimenting with first-order logic. It allows users to lay down blocks
on an <span class="math notranslate nohighlight">\(8 \times 8\)</span> grid and evaluate sentences about them. Each block is either
a tetrahedron, a cube, or a dodecahedron, and each is either small, medium, or large.
The language includes predicates for these, as well as relations like <cite>FrontOf(x, y)</cite>
and <cite>Between(x, y, z)</cite>. The second one of these holds if and only if <cite>x</cite>, <cite>y</cite>, and <cite>z</cite>
are either in the same row, in the same column, or on the same diagonal, and <cite>x</cite>
is between <cite>y</cite> and <cite>z</cite>.</p>
<p>The file <cite>TarskisWorld</cite> in the <cite>Examples</cite> folder includes a simple implementation in Lean.
You can define a world and display it:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">myWorld</span> <span class="o">:</span> <span class="n">World</span> <span class="o">:=</span> <span class="o">[</span>
  <span class="o">⟨</span><span class="n">tet</span><span class="o">,</span> <span class="n">medium</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">⟩,</span>
  <span class="o">⟨</span><span class="n">tet</span><span class="o">,</span> <span class="n">small</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">⟩,</span>
  <span class="o">⟨</span><span class="n">cube</span><span class="o">,</span> <span class="n">small</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">⟩,</span>
  <span class="o">⟨</span><span class="n">cube</span><span class="o">,</span> <span class="n">medium</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">⟩,</span>
  <span class="o">⟨</span><span class="n">dodec</span><span class="o">,</span> <span class="n">small</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">0</span><span class="o">⟩,</span>
  <span class="o">⟨</span><span class="n">dodec</span><span class="o">,</span> <span class="n">large</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">⟩</span> <span class="o">]</span>

<span class="k">#eval</span> <span class="n">myWorld.show</span>

<span class="c">/-</span>
<span class="cm">-----------------------------------------</span>
<span class="cm">| D- |    |    |    | D+ |    |    |    |</span>
<span class="cm">-----------------------------------------</span>
<span class="cm">|    |    |    |    |    |    |    |    |</span>
<span class="cm">-----------------------------------------</span>
<span class="cm">|    |    |    |    |    |    | C  |    |</span>
<span class="cm">-----------------------------------------</span>
<span class="cm">|    |    |    |    | C- |    |    |    |</span>
<span class="cm">-----------------------------------------</span>
<span class="cm">|    |    |    |    |    |    |    |    |</span>
<span class="cm">-----------------------------------------</span>
<span class="cm">|    |    |    |    |    |    |    |    |</span>
<span class="cm">-----------------------------------------</span>
<span class="cm">|    |    |    |    |    |    |    |    |</span>
<span class="cm">-----------------------------------------</span>
<span class="cm">|    |    | T  |    | T- |    |    |    |</span>
<span class="cm">-----------------------------------------</span>
<span class="cm">-/</span>
</pre></div>
</div>
<p>Here a plus symbol means that the object is large, a minus symbol means that it is small,
and no symbol means that it is of medium size.
You can then evaluate statements about the world:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">myWorld.eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∃</span> <span class="n">x.</span> <span class="bp">∃</span> <span class="n">y.</span> <span class="bp">∃</span> <span class="n">z.</span> <span class="n">Between</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">,</span> <span class="bp">%</span><span class="n">z</span><span class="o">)}</span>
<span class="k">#eval</span> <span class="n">myWorld.eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∃</span> <span class="n">x.</span> <span class="bp">∃</span> <span class="n">y.</span> <span class="bp">∃</span> <span class="n">z.</span> <span class="n">Cube</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">Between</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">,</span> <span class="bp">%</span><span class="n">z</span><span class="o">)}</span>
<span class="k">#eval</span> <span class="n">myWorld.eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∃</span> <span class="n">x.</span> <span class="bp">∃</span> <span class="n">y.</span> <span class="bp">∃</span> <span class="n">z.</span> <span class="n">Dodec</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">Between</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">,</span> <span class="bp">%</span><span class="n">z</span><span class="o">)}</span>
<span class="k">#eval</span> <span class="n">myWorld.eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∃</span> <span class="n">x.</span> <span class="n">Small</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)}</span>
<span class="k">#eval</span> <span class="n">myWorld.eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∃</span> <span class="n">x.</span> <span class="n">Small</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">Cube</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="k">#eval</span> <span class="n">myWorld.eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∀</span> <span class="n">x.</span> <span class="bp">∀</span> <span class="n">y.</span> <span class="n">Cube</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">Tet</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">FrontOf</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">)}</span>
<span class="k">#eval</span> <span class="n">myWorld.eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∀</span> <span class="n">x.</span> <span class="bp">∀</span> <span class="n">y.</span> <span class="n">Cube</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">Dodec</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">FrontOf</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">)}</span>
<span class="k">#eval</span> <span class="n">myWorld.eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∀</span> <span class="n">x.</span> <span class="n">Tet</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y.</span> <span class="n">Cube</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">RightOf</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">,</span> <span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="k">#eval</span> <span class="n">myWorld.eval</span> <span class="n">fo</span><span class="bp">!</span><span class="o">{</span><span class="bp">∀</span> <span class="n">x.</span> <span class="n">Dodec</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">y.</span> <span class="n">Tet</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">RightOf</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">,</span> <span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span>
</pre></div>
</div>
<p>The file <cite>TWExamples</cite> provides two puzzles, taken from <em>Tarski’s World</em>, for you to try.</p>
</section>
<section id="unification">
<span id="section-unification"></span><h2><span class="section-number">11.4. </span>Unification<a class="headerlink" href="#unification" title="Link to this heading"></a></h2>
<p>Suppose we are working with a language that is meant to describe the real
numbers and we have either proved or assumed the following sentence:</p>
<div class="math notranslate nohighlight">
\[\fa {x, y, z} x &lt; y \to x + z &lt; y + z.\]</div>
<p>Suppose also that we are trying to prove</p>
<div class="math notranslate nohighlight">
\[ab + 7 &lt; c + 7.\]</div>
<p>Even though we haven’t talked about proof systems for first-order logic
yet, it should be clear that we want to instantiate the universal quantifiers
in the sentence by substituting <span class="math notranslate nohighlight">\(ab\)</span> for <span class="math notranslate nohighlight">\(x\)</span>,
<span class="math notranslate nohighlight">\(c\)</span> for <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(7\)</span> for <span class="math notranslate nohighlight">\(z\)</span>, so that the
conclusion matches the goal.</p>
<p>You probably did not have to think about this much.
You identified the problem as that
of finding a substitution for <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span> that
has the effect of making the expression <span class="math notranslate nohighlight">\(x + z &lt; y + z\)</span> the same as
<span class="math notranslate nohighlight">\(ab + 7 &lt; c + 7\)</span>. This is what is known as a <em>matching</em> problem
for first-order terms. This kind of pattern matching is fundamental to reasoning,
and hence also fundamental to logic.
The general formulation of the problem is as follows:
we are given pairs of terms <span class="math notranslate nohighlight">\((s_1, t_1), (s_2, t_2), \ldots, (s_n, t_n)\)</span>
and we are looking for a substitution <span class="math notranslate nohighlight">\(\sigma\)</span>
with the property that for every <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(\sigma \, s_i = t_i\)</span>.</p>
<p>The generalization of the matching problem in which we are allowed to substitute
for the variables in the terms <span class="math notranslate nohighlight">\(t_i\)</span> as well as the terms <span class="math notranslate nohighlight">\(s_i\)</span> is known as
<em>unification</em>.
In other words, the input to a unification problem is the same as before,
but now we are looking for a substitution <span class="math notranslate nohighlight">\(\sigma\)</span>
with the property that for every <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(\sigma \, s_i = \sigma \, t_i\)</span>.
For example, consider the following two expressions:</p>
<div class="math notranslate nohighlight">
\[f(x, f(x, a)) &lt; z \quad\quad f(b, y) &lt; c\]</div>
<p>If we substitute <span class="math notranslate nohighlight">\(b\)</span> for <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(f(b, a)\)</span> for <span class="math notranslate nohighlight">\(y\)</span>, and
<span class="math notranslate nohighlight">\(c\)</span> for <span class="math notranslate nohighlight">\(z\)</span>, both expressions become <span class="math notranslate nohighlight">\(f(b, f(b, a)) &lt; c\)</span>.
When we discuss resolution proofs for first-order logic, we will see that
such unification problems come up in a context where are are trying
to prove a contradiction and we have derived something like
<span class="math notranslate nohighlight">\(\fa {x, z} f(x, f(x, a)) &lt; z\)</span>
and <span class="math notranslate nohighlight">\(\fa y f(b, y) \not&lt; c\)</span>. The unification problem tells us how to
instantiate the universal quantifiers in order to prove a contradiction.</p>
<p>To prevent confusion in the future, we would like to point out that what counts as a
variable or a constant depends on the context. For example, we can ask for
an assignment to <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> that unifies <span class="math notranslate nohighlight">\(f(x, z)\)</span> and <span class="math notranslate nohighlight">\(f(z, y)\)</span> without assigning anything to <span class="math notranslate nohighlight">\(z\)</span>.
In that case, we are treating <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> as variables and <span class="math notranslate nohighlight">\(z\)</span>
as a constant.
In Lean, the variables <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> that can be assigned in a unification
problem are sometimes called <em>metavariables</em> and written as <span class="math notranslate nohighlight">\(?x\)</span> and <span class="math notranslate nohighlight">\(?y\)</span>.
For simplicity, we will continue to use letters like <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span>
for variables and letters like <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, and <span class="math notranslate nohighlight">\(c\)</span> as constants.
What is important when specifying a unification problem is simply that it is clear which symbols play the role of variables and which have to remain fixed.</p>
<p>There is a linear-time algorithm that solves any unification problem
or determines that there is no solution, and, in fact produces a <em>most general unifier</em>,
or <em>mgu</em>. A most general unifier <span class="math notranslate nohighlight">\(\sigma\)</span> for a problem is a substitution that unifies each
pair in the list and has the property that if <span class="math notranslate nohighlight">\(\tau\)</span> is <em>any</em> unifier for the problem,
then <span class="math notranslate nohighlight">\(\tau\)</span> can be expressed as the result of following <span class="math notranslate nohighlight">\(\sigma\)</span> by
another substitution.
Here we will describe such an algorithm, but we will not go so far as
to prove its correctness or show that it produces a most general unifier.
Our implementation is adapted from one by John Harrison in his <em>Handbook of Practical
Logic and Automated Reasoning</em>, which is an excellent reference for most of the topics
we cover in this book, and a lot more.
In particular, it proves that the algorithm we describe below always terminates with
a most general unifier if the pairs can be unified at all,
and fails with <cite>none</cite> otherwise.
There is also a nice presentation of
unification in the book <em>Term Rewriting and All that</em> by Franz Baader and Tobias Nipkow.</p>
<p>Some unification problems are easy. To unify <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(f(a, z)\)</span>, we simply
assign <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(f(a, z)\)</span>. To be a most general unifier,
it is important that
the resulting term, <span class="math notranslate nohighlight">\(f(a, z)\)</span> has the variable <cite>z</cite>. We can also solve the problem
by assigning <span class="math notranslate nohighlight">\(f(a, a)\)</span> to <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(a\)</span> to <span class="math notranslate nohighlight">\(z\)</span>, but that is less
general. It can be seen as the result of mapping <span class="math notranslate nohighlight">\(x\)</span> to
<span class="math notranslate nohighlight">\(f(a, z)\)</span> and then applying another substitution that maps <span class="math notranslate nohighlight">\(z\)</span> to <span class="math notranslate nohighlight">\(a\)</span>.</p>
<p>For another easy example, we can unify <span class="math notranslate nohighlight">\(f(x, b)\)</span> and <span class="math notranslate nohighlight">\(f(g(c), b)\)</span> by
mapping <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(g(c)\)</span>. Since both expressions are of the form
<span class="math notranslate nohighlight">\(f(\cdot, \cdot)\)</span>, to unify the expressions it is clearly necessary and
sufficient to unify the arguments.
For the same reason, it is clear that <span class="math notranslate nohighlight">\(f(x, b)\)</span> and <span class="math notranslate nohighlight">\(g(c)\)</span>
can’t be unified.</p>
<p>An interesting phenomenon arises with the unification problem <span class="math notranslate nohighlight">\((x, f(y)), (y, g(x))\)</span>.
The first pair tells us we have to map <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(f(y)\)</span>, and
the second pair tells us we have to map <span class="math notranslate nohighlight">\(y\)</span> to <span class="math notranslate nohighlight">\(g(x)\)</span>.
Applying this substitution to each pair yields
<span class="math notranslate nohighlight">\((f(y), f(g(x)))\)</span> in the first pair and <span class="math notranslate nohighlight">\((g(x), g(f(y)))\)</span>
in the second, which doesn’t solve the problem.
Repeating the substitution doesn’t help.
The problem is that when we start with <span class="math notranslate nohighlight">\(x\)</span>, we find a chain of assignments
to variables in the terms on the right-hand side that ultimately
leads to a term that involves <span class="math notranslate nohighlight">\(x\)</span>.
In others words, the list of associations contains a <em>cycle</em>.
If we ever reach a point where we are forced to admit a cycle of
associations, the algorithm should fail. This is known as the <em>occurs check</em>.</p>
<p>The algorithm below maintains an <em>association list</em> of pairs <span class="math notranslate nohighlight">\((x, t)\)</span>
indicating that the variable <span class="math notranslate nohighlight">\(x\)</span> should be unified with the term <span class="math notranslate nohighlight">\(t\)</span>.
(An association list is essentially just a list of pairs, but for efficiency
it uses a constructor with three arguments to cons a pair onto the list.)
Each variable <span class="math notranslate nohighlight">\(x\)</span> occurs only once on the left side of a pair.
We allow the list to contain pairs like <span class="math notranslate nohighlight">\((x, y)\)</span>, <span class="math notranslate nohighlight">\((y, z)\)</span>,
and <span class="math notranslate nohighlight">\((z, w)\)</span>, since we can clean that up later, say, by assigning
all the variables to <span class="math notranslate nohighlight">\(w\)</span>.</p>
<p>Suppose we have an association list <span class="math notranslate nohighlight">\(\fn{env}\)</span> and we are considering adding
the pair <span class="math notranslate nohighlight">\((x, t)\)</span>. The following function returns <cite>some true</cite> if the assignment
is trivial, which is to say, <span class="math notranslate nohighlight">\(t\)</span> is <span class="math notranslate nohighlight">\(x\)</span> or there is a chain of variable associations
that amounts to assigning <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(x\)</span>. In that case, we can ignore the pair.
The function returns <cite>some false</cite> for any nontrivial assignment, unless
it detects a cycle, in which case it returns <cite>none</cite> to indicate failure.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">partial</span> <span class="kd">def</span> <span class="n">isTriv</span><span class="bp">?</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">AssocList</span> <span class="n">String</span> <span class="n">FOTerm</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">FOTerm</span> <span class="bp">→</span> <span class="n">Option</span> <span class="n">Bool</span>
  <span class="bp">|</span> <span class="n">var</span> <span class="n">y</span>      <span class="bp">=&gt;</span> <span class="k">if</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">x</span> <span class="k">then</span> <span class="n">true</span>
                   <span class="k">else</span> <span class="k">if</span> <span class="bp">!</span><span class="n">env.contains</span> <span class="n">y</span> <span class="k">then</span> <span class="n">false</span>
                   <span class="k">else</span> <span class="n">isTriv</span><span class="bp">?</span> <span class="n">env</span> <span class="n">x</span> <span class="o">(</span><span class="n">env.getA</span> <span class="n">y</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">app</span> <span class="n">_</span> <span class="n">l</span>    <span class="bp">=&gt;</span> <span class="n">loop</span> <span class="n">l</span>
<span class="n">where</span>
  <span class="n">loop</span> <span class="o">:</span> <span class="n">List</span> <span class="n">FOTerm</span> <span class="bp">→</span> <span class="n">Option</span> <span class="n">Bool</span>
    <span class="bp">|</span> <span class="o">[]</span>    <span class="bp">=&gt;</span> <span class="n">false</span>
    <span class="bp">|</span> <span class="n">a</span><span class="o">::</span><span class="n">as</span> <span class="bp">=&gt;</span> <span class="k">match</span> <span class="n">isTriv</span><span class="bp">?</span> <span class="n">env</span> <span class="n">x</span> <span class="n">a</span> <span class="k">with</span>
                  <span class="bp">|</span> <span class="n">true</span>  <span class="bp">=&gt;</span> <span class="n">none</span>
                  <span class="bp">|</span> <span class="n">false</span> <span class="bp">=&gt;</span> <span class="n">loop</span> <span class="n">as</span>
                  <span class="bp">|</span> <span class="n">none</span>  <span class="bp">=&gt;</span> <span class="n">none</span>
</pre></div>
</div>
<p>With that in place, the following function takes an association list, <cite>env</cite>,
and a list of pairs to unify, and it returns an association list.
The clauses are as follows:</p>
<ul class="simple">
<li><p>If the list of pairs is empty, there is nothing to do.</p></li>
<li><p>If the first pair on the list is a pair of function applications, then</p>
<ul>
<li><p>if the pair is of the form <span class="math notranslate nohighlight">\(f(t_1, \ldots, t_n)\)</span> and <span class="math notranslate nohighlight">\(f(s_1, \ldots, s_n)\)</span>,
add the pairs <span class="math notranslate nohighlight">\((s_1, t_1) \ldots (s_n, t_n)\)</span> to the list of pairs to unify
and continue recursively, and</p></li>
<li><p>if the function symbols don’t match or the number of arguments
is not the same, fail.</p></li>
</ul>
</li>
<li><p>If the pair is of the form <span class="math notranslate nohighlight">\((x, t)\)</span>, then</p>
<ul>
<li><p>if there is a pair <span class="math notranslate nohighlight">\((x, s)\)</span> already in <span class="math notranslate nohighlight">\(\fn{env}\)</span>,
add <span class="math notranslate nohighlight">\((s, t)\)</span> to the list of pairs to unify
and continue recursively, and</p></li>
<li><p>otherwise add <span class="math notranslate nohighlight">\((x, t)\)</span> to <span class="math notranslate nohighlight">\(\fn{env}\)</span> unless it is a trivial assignment,
and continue recursively with the remaining pairs.</p></li>
</ul>
</li>
<li><p>If the pair is of the form <span class="math notranslate nohighlight">\((t, x)\)</span>, then turn it around and recursively
use the previous case.</p></li>
</ul>
<p>The algorithm is implemented as follows.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">partial</span> <span class="kd">def</span> <span class="n">unify</span><span class="bp">?</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">AssocList</span> <span class="n">String</span> <span class="n">FOTerm</span><span class="o">)</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">FOTerm</span> <span class="bp">×</span> <span class="n">FOTerm</span><span class="o">)</span> <span class="bp">→</span>
                                                      <span class="n">Option</span> <span class="o">(</span><span class="n">AssocList</span> <span class="n">String</span> <span class="n">FOTerm</span><span class="o">)</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="bp">=&gt;</span> <span class="n">some</span> <span class="n">env</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">app</span> <span class="n">f1</span> <span class="n">l1</span><span class="o">,</span> <span class="n">app</span> <span class="n">f2</span> <span class="n">l2</span><span class="o">)</span> <span class="o">::</span> <span class="n">eqs</span> <span class="bp">=&gt;</span>
      <span class="k">if</span> <span class="n">f1</span> <span class="bp">=</span> <span class="n">f2</span> <span class="bp">∧</span> <span class="n">l1.length</span> <span class="bp">=</span> <span class="n">l2.length</span> <span class="k">then</span>
        <span class="n">unify</span><span class="bp">?</span> <span class="n">env</span> <span class="o">((</span><span class="n">l1.zip</span> <span class="n">l2</span><span class="o">)</span> <span class="bp">++</span> <span class="n">eqs</span><span class="o">)</span>
      <span class="k">else</span> <span class="n">none</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="o">::</span> <span class="n">eqs</span> <span class="bp">=&gt;</span>
      <span class="k">if</span> <span class="n">env.contains</span> <span class="n">x</span> <span class="k">then</span> <span class="n">unify</span><span class="bp">?</span> <span class="n">env</span> <span class="o">(</span><span class="n">eqs.cons</span> <span class="o">(</span><span class="n">env.getA</span> <span class="n">x</span><span class="o">,</span> <span class="n">t</span><span class="o">))</span>
      <span class="k">else</span> <span class="k">match</span> <span class="n">isTriv</span><span class="bp">?</span> <span class="n">env</span> <span class="n">x</span> <span class="n">t</span> <span class="k">with</span>
        <span class="bp">|</span> <span class="n">true</span>  <span class="bp">=&gt;</span> <span class="n">unify</span><span class="bp">?</span> <span class="n">env</span> <span class="n">eqs</span>
        <span class="bp">|</span> <span class="n">false</span> <span class="bp">=&gt;</span> <span class="n">unify</span><span class="bp">?</span> <span class="o">(</span><span class="n">env.cons</span> <span class="n">x</span> <span class="n">t</span><span class="o">)</span> <span class="n">eqs</span>
        <span class="bp">|</span> <span class="n">none</span>  <span class="bp">=&gt;</span> <span class="n">none</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">::</span> <span class="n">eqs</span> <span class="bp">=&gt;</span> <span class="n">unify</span><span class="bp">?</span> <span class="n">env</span> <span class="o">((</span><span class="n">var</span> <span class="n">x</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="o">::</span> <span class="n">eqs</span><span class="o">)</span>
</pre></div>
</div>
<p>The final association list might contain pairs <span class="math notranslate nohighlight">\((x, t)\)</span> and <span class="math notranslate nohighlight">\((y, s)\)</span>
where <span class="math notranslate nohighlight">\(s\)</span> contains the variable <span class="math notranslate nohighlight">\(x\)</span>. This means that the variable
<span class="math notranslate nohighlight">\(x\)</span> has to unify with <span class="math notranslate nohighlight">\(t\)</span>, which we can achieve by mapping
<span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(t\)</span>. But the resulting substitution will also replace
<span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(s\)</span>, so we had better carry out the substitution for <span class="math notranslate nohighlight">\(x\)</span>
there too.
The following function, <cite>usolve</cite>, cleans up the list of pairs by iteratively
substituting the terms on the right for the variables on the left,
until the association list no longer changes.
The fact that we have avoided cycles guarantees that it terminates.
The function after that, <cite>fullUnify</cite>, puts it all together:
given a list of pairs of terms to unify,
it computes the association list and uses <cite>usolve</cite> to turn it into a
substitution.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">partial</span> <span class="kd">def</span> <span class="n">usolve</span> <span class="o">(</span><span class="n">env</span> <span class="o">:</span> <span class="n">AssocList</span> <span class="n">String</span> <span class="n">FOTerm</span><span class="o">)</span> <span class="o">:</span> <span class="n">AssocList</span> <span class="n">String</span> <span class="n">FOTerm</span> <span class="o">:=</span> <span class="n">Id.run</span> <span class="k">do</span>
  <span class="k">let</span> <span class="n">env&#39;</span> <span class="o">:=</span> <span class="n">env.mapVal</span> <span class="o">(</span><span class="n">subst</span> <span class="n">env</span><span class="o">)</span>
  <span class="k">if</span> <span class="n">env&#39;</span> <span class="bp">==</span> <span class="n">env</span> <span class="k">then</span> <span class="n">env</span> <span class="k">else</span> <span class="n">usolve</span> <span class="n">env&#39;</span>

<span class="n">partial</span> <span class="kd">def</span> <span class="n">fullUnify</span> <span class="o">(</span><span class="n">eqs</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">FOTerm</span> <span class="bp">×</span> <span class="n">FOTerm</span><span class="o">))</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">AssocList</span> <span class="n">String</span> <span class="n">FOTerm</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">unify</span><span class="bp">?</span> <span class="n">AssocList.nil</span> <span class="n">eqs</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="n">usolve</span> <span class="n">l</span>
    <span class="bp">|</span> <span class="n">none</span>   <span class="bp">=&gt;</span> <span class="n">none</span>
</pre></div>
</div>
<p>Below we try the procedure out by computing some unifiers and applying them
to the original pairs to make sure that the pairs are indeed unified.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">partial</span> <span class="kd">def</span> <span class="n">unifyAndApply</span> <span class="o">(</span><span class="n">eqs</span> <span class="o">:</span> <span class="n">List</span> <span class="o">(</span><span class="n">FOTerm</span> <span class="bp">×</span> <span class="n">FOTerm</span><span class="o">))</span> <span class="o">:</span> <span class="n">Option</span> <span class="o">(</span><span class="n">List</span> <span class="o">(</span><span class="n">FOTerm</span> <span class="bp">×</span> <span class="n">FOTerm</span><span class="o">))</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">fullUnify</span> <span class="n">eqs</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="n">l</span> <span class="bp">=&gt;</span> <span class="k">let</span> <span class="n">σ</span> <span class="o">:</span> <span class="n">FOAssignment</span> <span class="n">FOTerm</span> <span class="o">:=</span> <span class="n">l</span>
                <span class="n">eqs.map</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">subst</span> <span class="n">σ</span> <span class="n">s</span><span class="o">,</span> <span class="n">subst</span> <span class="n">σ</span> <span class="n">t</span><span class="o">))</span>
    <span class="bp">|</span> <span class="n">none</span>   <span class="bp">=&gt;</span> <span class="n">none</span>

<span class="kd">def</span> <span class="n">unify_ex1</span> <span class="o">:=</span> <span class="o">[</span> <span class="o">(</span><span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="n">g</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">))},</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="bp">%</span><span class="n">z</span><span class="o">),</span> <span class="bp">%</span><span class="n">w</span><span class="o">)</span> <span class="o">})</span> <span class="o">]</span>

<span class="k">#eval</span> <span class="n">toString</span> <span class="bp">&lt;|</span> <span class="n">fullUnify</span> <span class="n">unify_ex1</span>
<span class="k">#eval</span> <span class="n">toString</span> <span class="bp">&lt;|</span> <span class="n">unifyAndApply</span> <span class="n">unify_ex1</span>

<span class="kd">def</span> <span class="n">unify_ex2</span> <span class="o">:=</span> <span class="o">[</span> <span class="o">(</span><span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="bp">%</span><span class="n">y</span><span class="o">)</span> <span class="o">},</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">,</span> <span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="o">})</span> <span class="o">]</span>

<span class="k">#eval</span> <span class="n">toString</span> <span class="bp">&lt;|</span> <span class="n">fullUnify</span> <span class="n">unify_ex2</span>
<span class="k">#eval</span> <span class="n">toString</span> <span class="bp">&lt;|</span> <span class="n">unifyAndApply</span> <span class="n">unify_ex2</span>

<span class="kd">def</span> <span class="n">unify_ex3</span> <span class="o">:=</span> <span class="o">[</span> <span class="o">(</span><span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="bp">%</span><span class="n">x</span><span class="o">,</span> <span class="n">g</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">))</span> <span class="o">},</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="bp">%</span><span class="n">y</span><span class="o">,</span> <span class="bp">%</span><span class="n">x</span><span class="o">)</span> <span class="o">})</span> <span class="o">]</span>

<span class="k">#eval</span> <span class="n">toString</span> <span class="bp">&lt;|</span> <span class="n">fullUnify</span> <span class="n">unify_ex3</span>

<span class="kd">def</span> <span class="n">unify_ex4</span> <span class="o">:=</span> <span class="o">[</span> <span class="o">(</span><span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="bp">%</span><span class="n">x0</span> <span class="o">},</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="bp">%</span><span class="n">x1</span><span class="o">,</span> <span class="bp">%</span><span class="n">x1</span><span class="o">)</span> <span class="o">}</span> <span class="o">),</span>
                   <span class="o">(</span><span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="bp">%</span><span class="n">x1</span> <span class="o">},</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="bp">%</span><span class="n">x2</span><span class="o">,</span> <span class="bp">%</span><span class="n">x2</span><span class="o">)</span> <span class="o">}</span> <span class="o">),</span>
                   <span class="o">(</span><span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="bp">%</span><span class="n">x2</span> <span class="o">},</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="bp">%</span><span class="n">x3</span><span class="o">,</span> <span class="bp">%</span><span class="n">x3</span><span class="o">)</span> <span class="o">}</span> <span class="o">),</span>
                   <span class="o">(</span><span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="bp">%</span><span class="n">x3</span> <span class="o">},</span> <span class="n">term</span><span class="bp">!</span><span class="o">{</span> <span class="n">f</span><span class="o">(</span><span class="bp">%</span><span class="n">x4</span><span class="o">,</span> <span class="bp">%</span><span class="n">x4</span><span class="o">)</span> <span class="o">}</span> <span class="o">)]</span>

<span class="k">#eval</span> <span class="n">toString</span> <span class="bp">&lt;|</span> <span class="n">fullUnify</span> <span class="n">unify_ex4</span>
<span class="k">#eval</span> <span class="n">toString</span> <span class="bp">&lt;|</span> <span class="n">unifyAndApply</span> <span class="n">unify_ex4</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="first_order_logic.html" class="btn btn-neutral float-left" title="10. First-Order Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="decision_procedures_for_first_order_logic.html" class="btn btn-neutral float-right" title="12. Decision Procedures for First-Order Logic" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>