<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>9. Using Lean as a Proof Assistant &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=0731ccc3" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=2709fde1"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10. First-Order Logic" href="first_order_logic.html" />
    <link rel="prev" title="8. Proof Systems for Propositional Logic" href="proof_systems_for_propositional_logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Logic and Mechanized Reasoning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_propositional_logic.html">8. Proof Systems for Propositional Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. Using Lean as a Proof Assistant</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#propositional-logic">9.1. Propositional logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#proof-terms">9.2. Proof terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#structured-proofs">9.3. Structured proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">9.4. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">11. Implementing First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_equality.html">12. Decision Procedures for Equality</a></li>
<li class="toctree-l1"><a class="reference internal" href="equality_and_induction_in_lean.html">13. Equality and Induction in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_arithmetic.html">14. Decision Procedures for Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">15. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_first_order_logic.html">16. Proof Systems for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">17. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="beyond_first_order_logic.html">18. Beyond First-Order Logic</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">9. </span>Using Lean as a Proof Assistant</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/using_lean_as_a_proof_assistant.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="using-lean-as-a-proof-assistant">
<span id="chapter-using-lean-as-a-proof-assistant"></span><h1><span class="section-number">9. </span>Using Lean as a Proof Assistant<a class="headerlink" href="#using-lean-as-a-proof-assistant" title="Link to this heading"></a></h1>
<p>This chapter marks three shifts in the way we are using Lean.
First, up to this point we have been using Lean as a programming language, whereas here
we will begin to use Lean as a <em>proof assistant</em>.
In the theory-implementation-application trichotomy that we used to describe this course,
this marks a shift from using Lean to implement logical tools
to using Lean as an important application of logic,
one that is used to verify hardware, software, and
complex systems as well as mathematical theorems.
Finally, whereas up to now our focus has been on representing logical languages in Lean,
now we are using Lean as a logical language itself. This can be viewed as a shift from treating
logic as an <em>object language</em> to treating logic as a <em>metalanguage</em>, a distinction
we will now explain.</p>
<p>Imagine implementing one programming language, such as Lisp, in
another programming language, like C++.
In this scenario, we can characterize Lisp as being the object language, that is, the
one that is being implemented, and C++ as the metalanguage, the one that is carrying out
the implementation.
What we did in <a class="reference internal" href="implementing_propositional_logic.html#chapter-implementing-propositional-logic"><span class="std std-numref">Chapter 5</span></a> is similar:
we are used one logical system, Lean, to
implement another one, propositional logic.
Whether we care about logical languages or programming languages (or a combination of both),
it’s often the case that we use one language to implement or describe another.
If we use Lean to implement a decision procedure for propositional logic,
propositional logic is the object language, the target of our implementation.
If we use propositional connectives (and more) to prove the correctness of that procedure in Lean,
then in that case we are using propositional logic as part of the metalanguage,
the thing we are using to achieve our goal.</p>
<p>One goal of this chapter is to clarify the sense in which Lean itself is a logical system,
which is to say, its language can be used to state mathematical theorems and prove them.
Using a logical foundation like Lean’s as both a programming language and a mathematical language
brings a number of benefits:</p>
<ul class="simple">
<li><p>It allows us to specify the behavior of computer programs in the same language that we write them.</p></li>
<li><p>It allows us to prove, rigorously, that our computer programs are correct, which is to say,
that they meet their specifications.</p></li>
<li><p>It allows us to enforce preconditions on our programs. For example, we can write functions
whose input is required to be a positive integer, a requirement that is enforced
statically, at compile time. Compiler optimizations can make use of this knowledge.</p></li>
<li><p>It allows us to compute with objects in our mathematical libraries.</p></li>
<li><p>It gives us ways of using computation reliably in mathematical proofs.</p></li>
</ul>
<p>Although we will not discuss it in this course, Lean also serves as its own <em>metaprogramming
language</em>, which means that we can use Lean to develop automation that can help us construct
programs and proofs.
In that way, Lean becomes a self-extending system, meaning that we can
improve its support for programming and theorem proving using the system itself.</p>
<p>Lean’s logical foundation is powerful and expressive enough to carry out any mathematical argument,
and proof assistants are now commonly used for hardware and software verification.
This chapter, we introduce the basics of using Lean as a proof assistant by focusing on the
treatment of propositional logic. <a class="reference internal" href="equality_and_induction_in_lean.html#chapter-equality-and-induction-in-lean"><span class="std std-numref">Chapter 13</span></a> will extend
this to equational reasoning and proof by induction, but even that only
scratches the surface.
You can learn more about the use of Lean as a proof assistant in either
<a class="reference external" href="https://leanprover-community.github.io/mathematics_in_lean/">Mathematics in Lean</a> or
<a class="reference external" href="https://leanprover.github.io/theorem_proving_in_lean4/">Theorem Proving in Lean 4</a>.
You may also enjoy interactive tutorials, like the Natural Number Game, found on the
<a class="reference external" href="https://adam.math.hhu.de/">Lean Game Server</a>.</p>
<p>For the examples in this chapter, we use the following imports:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">Mathlib.Data.Real.Basic</span>
<span class="kn">import</span> <span class="n">Mathlib.Tactic</span>
</pre></div>
</div>
<p>Since importing a file also imports everything it depends on, these serve to make
available to us a modest portion of Lean’s mathematical library, Mathlib.</p>
<section id="propositional-logic">
<span id="section-propositional-logic"></span><h2><span class="section-number">9.1. </span>Propositional logic<a class="headerlink" href="#propositional-logic" title="Link to this heading"></a></h2>
<p>In Lean, we can declare variables that range over propositions and then
use them to build more complicated propositions.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variable</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">True</span>
<span class="k">#check</span> <span class="n">False</span>
<span class="k">#check</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span>
<span class="k">#check</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span>
<span class="k">#check</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span>
<span class="k">#check</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">Q</span>
<span class="k">#check</span> <span class="bp">¬</span> <span class="n">P</span>
</pre></div>
</div>
<p>Hovering over the symbols will give you options for typing them. Using <code class="docutils literal notranslate"><span class="pre">\and</span></code>, <code class="docutils literal notranslate"><span class="pre">\or</span></code>, <code class="docutils literal notranslate"><span class="pre">\to</span></code>,
<code class="docutils literal notranslate"><span class="pre">\iff</span></code>, and <code class="docutils literal notranslate"><span class="pre">\not</span></code> will work.
In Lean, you state a theorem with the keyword <code class="docutils literal notranslate"><span class="pre">theorem</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">easy</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">apply</span> <span class="n">h</span>
</pre></div>
</div>
<p>What follows the keyword <code class="docutils literal notranslate"><span class="pre">by</span></code> is what is known as a <em>tactic proof</em>, that is,
a list of commands that tells Lean how to construct a proof of the theorem.
In the next section, we will say more about how proofs are represented in Lean
and what tactics do underneath the hood.
Here, instead, we will focus on how to use them.
Stating a theorem creates a <em>goal</em>, namely, the theorem to be proved.
If you put your cursor at the beginning of the line <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">h</span></code>,
the infoview window shows the following goal:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>P Q R S: Prop
⊢ P → P
</pre></div>
</div>
<p>If you put your cursor at the end of the line, you will see that the goal
has changed to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>P Q R S: Prop
h : P
⊢ P
</pre></div>
</div>
<p>When the cursor is at the beginning of the line <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">h</span></code>,
the highlighting in the infoview window helpfully shows what is about to change,
and when you move the cursor to the end of the line,
the highlighting shows what has just changed.
The notation should remind you of a sequent in natural deduction: the second goal says that we
are given propositions <code class="docutils literal notranslate"><span class="pre">P</span></code>, <code class="docutils literal notranslate"><span class="pre">Q</span></code>, <code class="docutils literal notranslate"><span class="pre">R</span></code>, and <code class="docutils literal notranslate"><span class="pre">S</span></code> together with the assumption
that <code class="docutils literal notranslate"><span class="pre">P</span></code> holds, labelled as <code class="docutils literal notranslate"><span class="pre">h</span></code>, and we are to prove <code class="docutils literal notranslate"><span class="pre">P</span></code>.
The command <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">P</span></code> finishes it off, leaving you with the happy message, “no goals.”
The label <code class="docutils literal notranslate"><span class="pre">h</span></code> is arbitrary, and you can use any valid identifier instead.
It’s conventional to use the letter <code class="docutils literal notranslate"><span class="pre">h</span></code> for hypotheses.
The information before the turnstile is called the <em>context</em>.
The right side of the sequent is also sometimes confusingly called the goal, but
we will call it the <em>conclusion</em> of the sequent and reserve the term “goal”
for the entire sequent.</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">example</span></code> keyword to prove a theorem without naming it:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">apply</span> <span class="n">h</span>
</pre></div>
</div>
<p>When an <code class="docutils literal notranslate"><span class="pre">apply</span></code> command finishes off the goal exactly, it is conventional to use the
<code class="docutils literal notranslate"><span class="pre">exact</span></code> tactic instead:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">exact</span> <span class="n">h</span>
</pre></div>
</div>
<p>You can also end a proof with the <code class="docutils literal notranslate"><span class="pre">done</span></code> tactic,
which does nothing but declare that there are no more goals.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">exact</span> <span class="n">h</span>
  <span class="n">done</span>
</pre></div>
</div>
<p>It is often useful to put a <code class="docutils literal notranslate"><span class="pre">done</span></code> at the end of a proof while you are still
writing it.
Lean gives you an error message if the proof isn’t over, and the error message tells you
the goals that remain to be proved.
It can be convenient to force Lean to put the error message on the <code class="docutils literal notranslate"><span class="pre">done</span></code>
command rather than somewhere lower down in the file. You can then delete the <code class="docutils literal notranslate"><span class="pre">done</span></code>
when you are finished with the proof.
Notice, by the way, that you can learn more about a tactic by hovering over it in  VS Code.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic can also be used to apply an implication.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">apply</span> <span class="n">h1</span>
  <span class="n">exact</span> <span class="n">h2</span>
</pre></div>
</div>
<p>In this example, applying the assumption <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">→</span> <span class="pre">Q</span></code> to the goal reduces the task of
proving <code class="docutils literal notranslate"><span class="pre">Q</span></code> to the task of proving <code class="docutils literal notranslate"><span class="pre">P</span></code>.
To prove a conjunction, we can use the <code class="docutils literal notranslate"><span class="pre">constructor</span></code> tactic:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hP</span> <span class="n">hQ</span>
  <span class="n">constructor</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">hP</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">hQ</span>
</pre></div>
</div>
<p>The command <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">hP</span> <span class="pre">hQ</span></code> is shorthand for writing <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">hP</span></code> followed by <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">hQ</span></code>.
The <code class="docutils literal notranslate"><span class="pre">constructor</span></code> tactic tells Lean we intend to prove <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code> by proving
each conjunct in turn.
As a result, after that line, there are <em>two</em> goals to prove, one for each conjunct.
The first period focuses on the first goal, which is solved using <code class="docutils literal notranslate"><span class="pre">hP</span></code>,
and the second period focuses on the second goal, which is using <code class="docutils literal notranslate"><span class="pre">hQ</span></code>.
Lean is whitespace sensitive, and once you focus on a goal, Lean expects you to maintain
the indentation until the goal is solved.
You can check that the proof still works if you delete the periods.
Structuring a proof in this way, however, tends to make it more readable and robust.</p>
<p>At this point, there is a trick that is worth mentioning.
At any point in a proof, you can solve the current goal with the <code class="docutils literal notranslate"><span class="pre">sorry</span></code> tactic.
You can prove any theorem at all using <code class="docutils literal notranslate"><span class="pre">sorry</span></code>.
It’s cheating, and the squiggly line the editor puts underneath the name of the theorem tells
you as much.
But it is often a useful device when writing proofs, because it means you can temporarily
close a goal to work on others, and then come back to it.</p>
<p>The natural way to <em>use</em> a conjunction <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code> in a hypothesis is to split it
to the hypotheses <code class="docutils literal notranslate"><span class="pre">hP</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">hQ</span> <span class="pre">:</span> <span class="pre">Q</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">hP</span><span class="o">,</span> <span class="n">hQ</span><span class="o">⟩</span>
  <span class="n">constructor</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">hQ</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">hP</span>
</pre></div>
</div>
<p>Here the angle brackets denote a conjunctive pattern for Lean to match <code class="docutils literal notranslate"><span class="pre">h</span></code>
against, and the <code class="docutils literal notranslate"><span class="pre">rcases</span></code> tactic does the matching, removing <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code>
and replacing it with <code class="docutils literal notranslate"><span class="pre">hP</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">hQ</span> <span class="pre">:</span> <span class="pre">Q</span></code>.</p>
<p>The corresponding proof for disjunction is dual:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">∨</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hP</span> <span class="bp">|</span> <span class="n">hQ</span>
  <span class="bp">.</span> <span class="n">right</span>
    <span class="n">exact</span> <span class="n">hP</span>
  <span class="bp">.</span> <span class="n">left</span>
    <span class="n">exact</span> <span class="n">hQ</span>
</pre></div>
</div>
<p>Here we use a vertical bar with <code class="docutils literal notranslate"><span class="pre">rcases</span> <span class="pre">h</span></code> because the split is disjunctive,
resulting in two goals: one in which we have <code class="docutils literal notranslate"><span class="pre">hP</span> <span class="pre">:</span> <span class="pre">P</span></code> in the context and one
in which we have <code class="docutils literal notranslate"><span class="pre">hQ</span> <span class="pre">:</span> <span class="pre">Q</span></code>. The <code class="docutils literal notranslate"><span class="pre">right</span></code> tactic tells Lean that we want to prove
<code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">∨</span> <span class="pre">P</span></code> by proving <code class="docutils literal notranslate"><span class="pre">P</span></code>, and the <code class="docutils literal notranslate"><span class="pre">left</span></code> tactic tells Lean that we want to prove
<code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">∨</span> <span class="pre">P</span></code> by proving <code class="docutils literal notranslate"><span class="pre">Q</span></code>.
Notice that in contrast to casing on a conjunction, which results in one new goal and
two new hypotheses,
casing on a disjunction results in two new goals, each with one new hypothesis.</p>
<p>Recall from <a class="reference internal" href="proof_systems_for_propositional_logic.html#section-natural-deduction"><span class="std std-numref">Section 8.6</span></a> that in the natural deduction
proof system, rules for the connectives can be categorized as either introduction
rules or elimination rules.
Even though we have not yet clarified the relationship between natural deduction
and Lean’s internal logic, you should notice that the tactics we have given so far
follow a similar pattern:</p>
<ul class="simple">
<li><p>Given a goal of the form <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">→</span> <span class="pre">Q</span></code>, we can use the <code class="docutils literal notranslate"><span class="pre">intro</span></code> tactic to prove it.</p></li>
<li><p>Given a hypothesis of the form <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">→</span> <span class="pre">Q</span></code>, we can use the <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic to use it.</p></li>
<li><p>Given a goal of the form <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code>, we can use the <code class="docutils literal notranslate"><span class="pre">constructor</span></code> tactic to prove it.</p></li>
<li><p>Given a hypothesis of the form <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code>, we can use the <code class="docutils literal notranslate"><span class="pre">rcases</span></code> tactic to use it.</p></li>
<li><p>Given a goal of the form <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">∨</span> <span class="pre">Q</span></code>, we can use the <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> tactics to prove it.</p></li>
<li><p>Given a hypothesis of the form <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">∨</span> <span class="pre">Q</span></code>, we can use the <code class="docutils literal notranslate"><span class="pre">rcases</span></code> tactic to use it.</p></li>
</ul>
<p>In Lean, negation <code class="docutils literal notranslate"><span class="pre">¬</span> <span class="pre">P</span></code> is defined to be <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">→</span> <span class="pre">False</span></code>.
For most purposes, the two expressions are interchangeable.
This means that you can prove <code class="docutils literal notranslate"><span class="pre">¬</span> <span class="pre">P</span></code>
by assuming <code class="docutils literal notranslate"><span class="pre">P</span></code> and deriving <code class="docutils literal notranslate"><span class="pre">False</span></code>, and if you have <code class="docutils literal notranslate"><span class="pre">hnp</span> <span class="pre">:</span> <span class="pre">¬</span> <span class="pre">P</span></code>,
you an reduce the task of proving <code class="docutils literal notranslate"><span class="pre">False</span></code> to the task of proving <code class="docutils literal notranslate"><span class="pre">P</span></code>.
In the next example, the <code class="docutils literal notranslate"><span class="pre">intro</span></code> tactic implements the first strategy,
and the <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic implements the second.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">Q</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hnQ</span>
  <span class="n">intro</span> <span class="n">hP</span>
  <span class="n">apply</span> <span class="n">hnQ</span>
  <span class="n">apply</span> <span class="n">h</span>
  <span class="n">exact</span> <span class="n">hP</span>
</pre></div>
</div>
<p>After the second <code class="docutils literal notranslate"><span class="pre">intro</span></code>, we have <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">→</span> <span class="pre">Q</span></code>, <code class="docutils literal notranslate"><span class="pre">hnQ</span> <span class="pre">:</span> <span class="pre">¬</span> <span class="pre">Q</span></code>, and <code class="docutils literal notranslate"><span class="pre">hP</span> <span class="pre">:</span> <span class="pre">P</span></code>
in the context and <code class="docutils literal notranslate"><span class="pre">False</span></code> as the desired conclusion. Applying <code class="docutils literal notranslate"><span class="pre">hnQ</span></code> leaves
us the goal of proving <code class="docutils literal notranslate"><span class="pre">Q</span></code>, which we do using <code class="docutils literal notranslate"><span class="pre">h</span></code> and <code class="docutils literal notranslate"><span class="pre">hP</span></code>.</p>
<p>There is no introduction rule for falsity; there is no canonical way to prove <code class="docutils literal notranslate"><span class="pre">False</span></code>!
If we assume <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">False</span></code>, we can reach any conclusion we want,
using either <code class="docutils literal notranslate"><span class="pre">contradiction</span></code> or <code class="docutils literal notranslate"><span class="pre">rcases</span> <span class="pre">h</span></code>.
Intuitively, there is no proof of <code class="docutils literal notranslate"><span class="pre">False</span></code>, so if we have <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">False</span></code>,
there are no cases to consider.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">False</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">contradiction</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">False</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rcases</span> <span class="n">h</span>
</pre></div>
</div>
<p>As a convenience, if you have <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">hnP</span> <span class="pre">:</span> <span class="pre">¬</span> <span class="pre">P</span></code> in the context,
the contradiction tactic solves the goal automatically.</p>
<p>The principles we have used before all fall within what is known as
<em>intuitionistic</em> logic. Many mathematical arguments require <em>classical</em> logic,
which is embodied in the <em>law of the excluded middle</em>, <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">∨</span> <span class="pre">¬</span> <span class="pre">P</span></code>.
This is embodied in the <code class="docutils literal notranslate"><span class="pre">by_cases</span></code> tactic, which lets us split on cases.
In the proof below, we have <code class="docutils literal notranslate"><span class="pre">hP</span> <span class="pre">:</span> <span class="pre">P</span></code> in the first case and <code class="docutils literal notranslate"><span class="pre">hnP</span> <span class="pre">:</span> <span class="pre">¬</span> <span class="pre">P</span></code> in the second.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">by_cases</span> <span class="n">hP</span> <span class="o">:</span> <span class="n">P</span>
  <span class="bp">.</span> <span class="n">right</span>
    <span class="n">apply</span> <span class="n">h1</span>
    <span class="n">exact</span> <span class="n">hP</span>
  <span class="bp">.</span> <span class="n">left</span>
    <span class="n">exact</span> <span class="n">hP</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hnnP</span>
  <span class="n">by_cases</span> <span class="n">hP</span> <span class="o">:</span> <span class="n">P</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">hP</span>
  <span class="bp">.</span> <span class="n">contradiction</span>
</pre></div>
</div>
<p>Classical reasoning is also embodied in the <code class="docutils literal notranslate"><span class="pre">by_contra</span></code> tactic, which allows
us to do proof by contradiction.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">hnnP</span>
  <span class="n">by_contra</span> <span class="n">hnP</span>
  <span class="n">apply</span> <span class="n">hnnP</span>
  <span class="n">exact</span> <span class="n">hnP</span>
</pre></div>
</div>
<p>Applying <code class="docutils literal notranslate"><span class="pre">by_contra</span> <span class="pre">hnP</span></code> to a goal with conclusion <code class="docutils literal notranslate"><span class="pre">P</span></code> adds <code class="docutils literal notranslate"><span class="pre">hnP</span> <span class="pre">:</span> <span class="pre">¬</span> <span class="pre">P</span></code> to the context
and asks us to prove <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>You can think of <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">↔</span> <span class="pre">Q</span></code> as an abbreviation for <code class="docutils literal notranslate"><span class="pre">(P</span> <span class="pre">→</span> <span class="pre">Q)</span> <span class="pre">∧</span> <span class="pre">(Q</span> <span class="pre">→</span> <span class="pre">P)</span></code>.
It is not implemented exactly that way in Lean, but like a conjunction,
the task of proving such a statement can be split into the forward
and backward directions.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rcases</span> <span class="n">h1</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">hpq</span><span class="o">,</span> <span class="n">_</span><span class="o">⟩</span>
  <span class="n">apply</span> <span class="n">hpq</span>
  <span class="n">exact</span> <span class="n">h2</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">↔</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">↔</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rcases</span> <span class="n">h1</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">h2</span><span class="o">,</span> <span class="n">h3</span><span class="o">⟩</span>
  <span class="n">constructor</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">h3</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">h2</span>
</pre></div>
</div>
<p>In the first example, the underscore omits a label for the hypothesis, since we don’t
needed it. If you use a label, Lean’s built in linter will warn you that the label is unused.
The hypothesis still appears in the context with an inaccessible name, and can be used
by automation. If you replace the underscore with a dash (<code class="docutils literal notranslate"><span class="pre">-</span></code>), the <code class="docutils literal notranslate"><span class="pre">rcases</span></code> tactic
clears it entirely from the context.</p>
<p>The methods in this section are <em>complete</em> for classical propositional logic,
which is to say, any proof in classical propositional logic can be carried out
using these methods.
That is not to say that these methods are the most <em>efficient</em>; Lean
offers both automation and syntax for writing proofs more compactly.
As far as automation is concerned, all the proofs in this section
can be carried out using the <code class="docutils literal notranslate"><span class="pre">tauto</span></code> tactic, which stands for “tautology.”</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">tauto</span>
</pre></div>
</div>
<p>But writing propositional proofs by hand is a good way to learn how propositional logic
works in Lean, and in more complicated proofs we often need to carry out simple logical
manipulations by hand.</p>
</section>
<section id="proof-terms">
<span id="section-proof-terms"></span><h2><span class="section-number">9.2. </span>Proof terms<a class="headerlink" href="#proof-terms" title="Link to this heading"></a></h2>
<p>Remember that, in Lean’s foundation, everything is expression.
In particular, if an expression <code class="docutils literal notranslate"><span class="pre">P</span></code> has type <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, then a term <code class="docutils literal notranslate"><span class="pre">p</span></code>
of type <code class="docutils literal notranslate"><span class="pre">P</span></code> is interpreted as a proof of <code class="docutils literal notranslate"><span class="pre">P</span></code>.
Lean’s proof language is therefore essentially the same as its programming language,
which means that we can write proofs the same way we write programs.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">prod_swap</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">×</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">p</span> <span class="bp">=&gt;</span> <span class="n">Prod.mk</span> <span class="o">(</span><span class="n">Prod.snd</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">Prod.fst</span> <span class="n">p</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">and_swap</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">P</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">And.intro</span> <span class="o">(</span><span class="n">And.right</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">And.left</span> <span class="n">h</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">sum_swap</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="n">Sum</span> <span class="n">α</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">Sum</span> <span class="n">β</span> <span class="n">α</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">Sum.inl</span> <span class="n">a</span> <span class="bp">=&gt;</span> <span class="n">Sum.inr</span> <span class="n">a</span>
    <span class="bp">|</span> <span class="n">Sum.inr</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">Sum.inl</span> <span class="n">b</span>

<span class="kd">theorem</span> <span class="n">or_swap</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">∨</span> <span class="n">P</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="k">match</span> <span class="n">h</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">Or.inl</span> <span class="n">hp</span> <span class="bp">=&gt;</span> <span class="n">Or.inr</span> <span class="n">hp</span>
    <span class="bp">|</span> <span class="n">Or.inr</span> <span class="n">hq</span> <span class="bp">=&gt;</span> <span class="n">Or.inl</span> <span class="n">hq</span>
</pre></div>
</div>
<p>Instead of using the identifier <code class="docutils literal notranslate"><span class="pre">def</span></code>, it is conventional to use the word <code class="docutils literal notranslate"><span class="pre">theorem</span></code>
to name the proof of a proposition.
Each keyword serves to assign an expression to an identifier; the main difference
is that theorems are marked <em>opaque</em>, which means that they are generally
not unfolded. A proof written this way is called a <em>proof term</em>.
The tactic proofs described in the previous section are nothing more than instructions
that tell the system how to construct such an expression.</p>
<p>The syntax for proof terms, in turn, is closely related to natural deduction.
The <code class="docutils literal notranslate"><span class="pre">#explode</span></code> command prints proof terms in a format that is closer to the presentation of
natural deduction in <a class="reference internal" href="proof_systems_for_propositional_logic.html#section-natural-deduction"><span class="std std-numref">Section 8.6</span></a>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="bp">#</span><span class="n">explode</span> <span class="n">and_swap</span>
<span class="bp">#</span><span class="n">explode</span> <span class="n">or_swap</span>
</pre></div>
</div>
<p>Don’t look too hard for an exact correspondence, because the details differ.
But Lean’s foundation can be seen as a vast generalization of natural deduction,
giving rise to its uniform treatment of proofs and programs.
The analogy between the two is known as the Curry-Howard correspondence, and it explains
the fact that the introduction and elimination rules for the connectives
look a lot like the constructors and destructors for the corresponding data types.
The examples above show that the introduction and elimination rules for conjunction
parallel the constructors and destructors for the pair data type,
and the introduction and elimination rules for disjunction parallel the constructors
and destructors for the sum data type. In Lean’s foundation, the introduction and elimination rules for implication
are exactly lambda abstraction and function application, respectively.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">P</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="n">And.intro</span> <span class="n">h</span> <span class="n">h</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">Q</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">h2</span>
</pre></div>
</div>
<p>In Lean, <code class="docutils literal notranslate"><span class="pre">¬</span> <span class="pre">P</span></code> is defined to be <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">→</span> <span class="pre">False</span></code>. The following proof assumes <code class="docutils literal notranslate"><span class="pre">P</span></code> and
<code class="docutils literal notranslate"><span class="pre">¬</span> <span class="pre">P</span></code>, concludes <code class="docutils literal notranslate"><span class="pre">⊥</span></code>, and then uses the <em>ex falso</em> principle to conclude <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">h1</span> <span class="n">h2</span> <span class="bp">=&gt;</span> <span class="n">False.elim</span> <span class="o">(</span><span class="n">h2</span> <span class="n">h1</span><span class="o">)</span>
</pre></div>
</div>
<p>Lean allows the use of anonymous constructors and projections with proof terms just as with data:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">P</span> <span class="o">:=</span>
  <span class="k">fun</span> <span class="n">h</span> <span class="bp">=&gt;</span> <span class="o">⟨</span><span class="n">h.right</span><span class="o">,</span> <span class="n">h.left</span><span class="o">⟩</span>
</pre></div>
</div>
<p>You can use proof terms in a tactic proof:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">→</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">R</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h1</span> <span class="n">h2</span>
  <span class="n">exact</span> <span class="n">Or.inl</span> <span class="o">(</span><span class="n">And.intro</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span>
</pre></div>
</div>
<p>In fact, under the hood, a tactic proof is essentially a program that constructs the
relevant proof. Here are some more examples:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">and_swap&#39;</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩</span>
  <span class="n">constructor</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">h2</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">h1</span>

<span class="kd">theorem</span> <span class="n">or_swap&#39;</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">∨</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="bp">|</span>  <span class="n">h2</span>
  <span class="bp">.</span> <span class="n">right</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">h1</span>
  <span class="bp">.</span> <span class="n">left</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">h2</span>

<span class="k">#print</span> <span class="n">and_swap&#39;</span>
<span class="bp">#</span><span class="n">explode</span> <span class="n">and_swap&#39;</span>
<span class="k">#print</span> <span class="n">or_swap&#39;</span>
<span class="bp">#</span><span class="n">explode</span> <span class="n">or_swap&#39;</span>
</pre></div>
</div>
<p>Lean’s <code class="docutils literal notranslate"><span class="pre">show_term</span></code> tactic will show you the proof term that a tactic block produces,
and it will even given you the option of clicking to replace the tactic block by an explicit
use of that term.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">P</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">intro</span> <span class="n">h</span>
  <span class="n">show_term</span> <span class="o">{</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="o">⟩</span>
  <span class="n">constructor</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">h2</span>
  <span class="bp">.</span> <span class="n">exact</span> <span class="n">h1</span><span class="o">}</span>
</pre></div>
</div>
<p>You can read more about Lean expressions in
<a class="reference external" href="https://leanprover.github.io/theorem_proving_in_lean4/">Theorem Proving in Lean 4</a>.
For the most part, in this course, we will focus on tactic proofs,
but you should feel free to use a proof term with <code class="docutils literal notranslate"><span class="pre">apply</span></code> or <code class="docutils literal notranslate"><span class="pre">exact</span></code> when you feel like it.
More importantly,  you should keep in mind that at the end of the day, what you are doing is
constructing something like a natural deduction proof, represented as an expression in Lean’s
foundation.
You can therefore think of Lean as an engine for manipulating expressions that can represent
data types, statements, programs, and proofs.
Tactics are pieces of automation that are designed to help us construct these expressions.</p>
</section>
<section id="structured-proofs">
<span id="section-structured-proofs"></span><h2><span class="section-number">9.3. </span>Structured proofs<a class="headerlink" href="#structured-proofs" title="Link to this heading"></a></h2>
<p>Tactics allow us to work backward to prove a goal by reducing it to simpler ones.
Lean also provides a means of reasoning forward from hypotheses,
using the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">hQ</span> <span class="o">:</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
    <span class="n">apply</span> <span class="n">h1</span>
    <span class="n">exact</span> <span class="n">h3</span>
  <span class="n">apply</span> <span class="n">h2</span>
  <span class="n">exact</span> <span class="n">hQ</span>
</pre></div>
</div>
<p>Here the first line of the proof states an intermediate goal of proving <code class="docutils literal notranslate"><span class="pre">Q</span></code>.
The result is named <code class="docutils literal notranslate"><span class="pre">hQ</span></code>, which we are then free to use.
Using <code class="docutils literal notranslate"><span class="pre">have</span></code>  tends to make proofs more readable
because the text displays the stepping stones to the main goal.
It also tends to make proofs more robust,
in that errors are localized to small, compartmentalized parts of the proof.
If you omit the keyword <code class="docutils literal notranslate"><span class="pre">by</span></code>, you can use a proof term to fill an easy <code class="docutils literal notranslate"><span class="pre">have</span></code>:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">hQ</span> <span class="o">:</span> <span class="n">Q</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">h3</span>
  <span class="n">exact</span> <span class="n">h2</span> <span class="n">hQ</span>
</pre></div>
</div>
<p>You can even write <code class="docutils literal notranslate"><span class="pre">have</span> <span class="pre">hQ</span> <span class="pre">:=</span> <span class="pre">h1</span> <span class="pre">h3</span></code> in the second line of the first proof, omitting the type
ascription, because Lean can figure that out. Of course, this sacrifices readability somewhat.
You can generallly eliminate a <code class="docutils literal notranslate"><span class="pre">have</span></code> statement by inlining the result.
For example, replacing <code class="docutils literal notranslate"><span class="pre">hQ</span></code> by <code class="docutils literal notranslate"><span class="pre">h1</span> <span class="pre">h3</span></code> yields the first proof below:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">exact</span> <span class="n">h2</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h3</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">h2</span> <span class="o">(</span><span class="n">h1</span> <span class="n">h3</span><span class="o">)</span>
</pre></div>
</div>
<p>The proof <code class="docutils literal notranslate"><span class="pre">by</span> <span class="pre">exact</span> <span class="pre">h2</span> <span class="pre">(h1</span> <span class="pre">h3)</span></code> is equivalent to just presenting the proof term <code class="docutils literal notranslate"><span class="pre">h2</span> <span class="pre">(h1</span> <span class="pre">h3)</span></code>,
as we do in the second example.</p>
<p>Lean also has a <code class="docutils literal notranslate"><span class="pre">show</span></code> tactic, which declares the goal we are about to solve.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">h3</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="k">have</span> <span class="n">hQ</span> <span class="o">:</span> <span class="n">Q</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">h3</span>
  <span class="k">show</span> <span class="n">R</span>
  <span class="n">exact</span> <span class="n">h2</span> <span class="n">hQ</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">R</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rcases</span> <span class="n">h1</span> <span class="k">with</span> <span class="o">⟨</span><span class="n">hP</span><span class="o">,</span> <span class="n">hQ</span><span class="o">⟩</span>
  <span class="k">have</span> <span class="n">hR</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="n">h2</span> <span class="n">hQ</span>
  <span class="k">show</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">R</span>
  <span class="n">exact</span> <span class="o">⟨</span><span class="n">hP</span><span class="o">,</span> <span class="n">hR</span><span class="o">⟩</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">show</span></code> tactic mainly serves to make a proof more readable, though it does a little more work than
we are letting on here. For example, if there are multiple goals left to prove, <code class="docutils literal notranslate"><span class="pre">show</span></code> fill focus on the
first one that matches the given statement.</p>
</section>
<section id="exercises">
<h2><span class="section-number">9.4. </span>Exercises<a class="headerlink" href="#exercises" title="Link to this heading"></a></h2>
<p>Complete the following proofs in Lean.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">Mathlib.Data.Real.Basic</span>

<span class="kd">variable</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="n">S</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span> <span class="n">R</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="bp">→</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">r</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">r</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span><span class="o">))</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">))</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">P</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="bp">→</span> <span class="n">R</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">))</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="c1">-- this one requires classical logic!</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span><span class="o">))</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>

<span class="c1">-- this one too</span>
<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span> <span class="o">:=</span> <span class="kd">by</span>
<span class="gr">sorry</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="proof_systems_for_propositional_logic.html" class="btn btn-neutral float-left" title="8. Proof Systems for Propositional Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="first_order_logic.html" class="btn btn-neutral float-right" title="10. First-Order Logic" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>