

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>9. Using Lean as a Proof Assistant &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10. Terms and Formulas" href="terms_and_formulas.html" />
    <link rel="prev" title="8. Deduction for Propositional Logic" href="deduction_for_propositional_logic.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Logic and Mechanized Reasoning
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_programming_language.html">3. Using Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="deduction_for_propositional_logic.html">8. Deduction for Propositional Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. Using Lean as a Proof Assistant</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#propositional-logic-in-lean">9.1. Propositional Logic in Lean</a></li>
<li class="toctree-l2"><a class="reference internal" href="#equational-reasoning-in-lean">9.2. Equational Reasoning in Lean</a></li>
<li class="toctree-l2"><a class="reference internal" href="#structural-induction-in-lean">9.3. Structural Induction in Lean</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="terms_and_formulas.html">10. Terms and Formulas</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_terms_and_formulas.html">11. Implementing Terms and Formulas</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">12. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">13. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">14. Implementing First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">15. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="simple_type_theory.html">16. Simple Type Theory</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">9. </span>Using Lean as a Proof Assistant</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/using_lean_as_a_proof_assistant.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="using-lean-as-a-proof-assistant">
<span id="chapter-using-lean-as-a-proof-assistant-as-a-proof-assistant"></span><h1><span class="section-number">9. </span>Using Lean as a Proof Assistant<a class="headerlink" href="#using-lean-as-a-proof-assistant" title="Permalink to this headline">¶</a></h1>
<p>In <a class="reference internal" href="using_lean_as_a_programming_language.html#chapter-using-lean-as-a-programming-language"><span class="std std-numref">Chapter 3</span></a>,
we considered the use of Lean as a programming
language, and in <a class="reference internal" href="implementing_propositional_logic.html#chapter-implementing-propositional-logic"><span class="std std-numref">Chapter 5</span></a>
we saw that you can use Lean to define data types for things like propositional formulas
and truth assignments, and thereby implement algorithms that act on these objects.</p>
<p>In this chapter, we will show how it is possible to represent propositional formulas directly in
Lean’s underlying foundation. In this sense, we are using Lean’s foundation as an <em>object
language</em> rather than a <em>metalanguage</em> for logic.
To clarify the distinction, imagine implementing one programming language, such as Lisp, in
another programming language, like C++.
In this scenario, we can characterize Lisp as being the object language, that is, the
one that is being implemented, and C++ as the metalanguage, the one that is carrying out
the implementation.
Defining propositional logic in Lean is similar: we are using one logical system, Lean, to
implement another one, propositional logic.
Our goal in this chapter is to clarify the sense in which Lean itself is a logical system,
which is to say, its language can be used to state mathematical theorems and prove them.</p>
<div class="section" id="propositional-logic-in-lean">
<span id="section-propositional-logic-in-lean"></span><h2><span class="section-number">9.1. </span>Propositional Logic in Lean<a class="headerlink" href="#propositional-logic-in-lean" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="equational-reasoning-in-lean">
<span id="section-equational-reasoning-in-lean"></span><h2><span class="section-number">9.2. </span>Equational Reasoning in Lean<a class="headerlink" href="#equational-reasoning-in-lean" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="structural-induction-in-lean">
<span id="section-structural-induction-in-lean"></span><h2><span class="section-number">9.3. </span>Structural Induction in Lean<a class="headerlink" href="#structural-induction-in-lean" title="Permalink to this headline">¶</a></h2>
<p>A feature of working with a system like Lean,
which is based on a formal logical foundation,
is that you can not only define data types and functions
but also prove things about them.
The goal of this section is to give you a flavor of using Lean
as a proof assistant.
It isn’t easy: Lean syntax is finicky and its error messages are often
inscrutable.
In class, we’ll try to give you some pointers as to how to interact
with Lean to construct proofs.
The examples in this section will serve as a basis for discussion.</p>
<p>Remember that Lean’s core library defines the <cite>List</cite> data type
and notation for it.
In the example below, we import the library,
open the namespace, declare some variables, and try out the notation.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">Init</span>

<span class="kn">open</span> <span class="n">List</span>

<span class="kd">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">as</span> <span class="n">bs</span> <span class="n">cs</span> <span class="o">:</span> <span class="n">List</span> <span class="n">α</span><span class="o">)</span>
<span class="kd">variable</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">a</span> <span class="o">::</span> <span class="n">as</span>
<span class="k">#check</span> <span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">[]</span> <span class="bp">++</span> <span class="n">as</span> <span class="bp">=</span> <span class="n">as</span> <span class="o">:=</span> <span class="n">nil_append</span> <span class="n">as</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">as</span><span class="o">)</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">::</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cons_append</span> <span class="n">a</span> <span class="n">as</span> <span class="n">bs</span>
</pre></div>
</div>
<p>The <cite>variable</cite> command does not do anything substantive.
It tells Lean that when the corresponding identifiers are used
in definitions and theorems that follow,
they should be interpreted as arguments to those theorems and proofs,
with the indicated types.
The curly brackets around the declaration <cite>α : Type</cite> indicate that that
argument is meant to be <em>implicit</em>, which is to say,
users do not have to write it explicitly.
Rather, Lean is expected to infer it from the context.</p>
<p>The library proves the theorems <cite>[] ++ as</cite> and
<cite>(a :: as) ++ bs = a :: (as ++ bs)</cite> under the names <cite>nil_append</cite>
and <cite>cons_append</cite>, respectively.
You can see them by writing <cite>#check nil_append</cite> and <cite>#check cons_append</cite>.
Remember that we took these to be the defining equations for the
<cite>append</cite> function in <a class="reference internal" href="mathematical_background.html#section-generalized-induction-and-recursion"><span class="std std-numref">Section 2.3</span></a>.
Although Lean uses a different definition of the append function,
for illustrative purposes we will treat them as the defining equations
and base our subsequent proofs on that.</p>
<p>Lean’s library also proves <cite>as ++ []</cite> under the name <cite>append_nil</cite>,
but to illustrate how proofs like this go, we will prove it again
under the name <cite>append_nil’</cite>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">append_nil&#39;</span> <span class="o">:</span> <span class="n">as</span> <span class="bp">++</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">as</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">as</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nil_append</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">cons_append</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>
</pre></div>
</div>
<p>In class, we will help you make sense of this.
The <cite>by</cite> command tell Lean that we are going to write
a <em>tactic</em> proof.
In other words, instead of writing the proof as an expression,
we are going to give Lean a list of instructions
that tell it how to prove the theorem.
At the start of the tactic proof, the theorem in question
is our <em>goal</em>.
At each step, tactics act on one more more of the remaining goals;
when no more goals remain, the theorem is proved.</p>
<p>In this case, there are only two tactics that are needed.
The <cite>induction</cite> tactic, as the name suggests, sets up a proof
by induction, and the <cite>rw</cite> tactic <em>rewrites</em> the goal
using given equations.
Moving the cursor around in the editor windows shows you the
goals at the corresponding state of the proof.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">append_assoc&#39;</span> <span class="o">:</span> <span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="bp">=</span> <span class="n">as</span> <span class="bp">++</span> <span class="o">(</span><span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">as</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nil_append</span><span class="o">,</span> <span class="n">nil_append</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">cons_append</span><span class="o">,</span> <span class="n">cons_append</span><span class="o">,</span> <span class="n">ih</span><span class="o">,</span> <span class="bp">←</span><span class="n">cons_append</span><span class="o">]</span>
</pre></div>
</div>
<p>Here is a similar proof of the associativity of the <cite>append</cite> function.
Note that the left arrow in the expression <cite>←cons_append</cite>
tell Lean that we want to use the equation from right to left instead of
from left to right.</p>
<p>Now let us consider Lean’s definition of the <cite>reverse</cite> function:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">reverse_def</span> <span class="o">:</span> <span class="n">reverse</span> <span class="n">as</span> <span class="bp">=</span> <span class="n">reverseAux</span> <span class="n">as</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">reverseAux_nil</span> <span class="o">:</span> <span class="n">reverseAux</span> <span class="o">[]</span> <span class="n">as</span> <span class="bp">=</span> <span class="n">as</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">theorem</span> <span class="n">reverseAux_cons</span> <span class="o">:</span> <span class="n">reverseAux</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">as</span><span class="o">)</span> <span class="n">bs</span> <span class="bp">=</span> <span class="n">reverseAux</span> <span class="n">as</span> <span class="o">(</span><span class="n">a</span> <span class="o">::</span> <span class="n">bs</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
<p>We will use these identities in the proofs that follow.
Let’s think about what it would take to prove the identity
<cite>reverse (as ++ bs) = reverse bs ++ reverse as</cite>.
Since <cite>reverse</cite> is defined in terms of <cite>reverseAux</cite>,
we should expect to have to prove something about <cite>reverseAux</cite>.
And since the identity mentions the <cite>append</cite> function,
it is natural to try to characterize the way that
<cite>reverseAux</cite> interacts with <cite>append</cite>.
These are the two identities we need:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">reverseAux_append</span> <span class="o">:</span> <span class="n">reverseAux</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span><span class="o">)</span> <span class="n">cs</span> <span class="bp">=</span> <span class="n">reverseAux</span> <span class="n">bs</span> <span class="o">(</span><span class="n">reverseAux</span> <span class="n">as</span> <span class="n">cs</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">as</span> <span class="n">generalizing</span> <span class="n">cs</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nil_append</span><span class="o">,</span> <span class="n">reverseAux_nil</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">cons_append</span><span class="o">,</span> <span class="n">reverseAux_cons</span><span class="o">,</span> <span class="n">reverseAux_cons</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>

<span class="kd">theorem</span> <span class="n">reverseAux_append&#39;</span> <span class="o">:</span> <span class="n">reverseAux</span> <span class="n">as</span> <span class="o">(</span><span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span><span class="o">)</span> <span class="bp">=</span> <span class="n">reverseAux</span> <span class="n">as</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">cs</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">induction</span> <span class="n">as</span> <span class="n">generalizing</span> <span class="n">bs</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">reverseAux_nil</span><span class="o">,</span> <span class="n">reverseAux_nil</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">cons</span> <span class="n">a</span> <span class="n">as</span> <span class="n">ih</span> <span class="bp">=&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">reverseAux_cons</span><span class="o">,</span> <span class="n">reverseAux_cons</span><span class="o">,</span> <span class="bp">←</span><span class="n">cons_append</span><span class="o">,</span> <span class="n">ih</span><span class="o">]</span>
</pre></div>
</div>
<p>Note the <cite>generalizing</cite> clause in the induction. What it means is that
what we are proving by induction on <cite>as</cite> is that the identity holds
<em>for every choice of</em> <cite>bs</cite>.
This means that, when we apply the inductive hypothesis,
we can apply it to any choice of the parameter <cite>bs</cite>.
You should try deleting the <cite>generalizing</cite> clause to see what goes
wrong when we omit it.</p>
<p>With those facts in hand, we have the identity we are after:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">reverse_append</span> <span class="o">:</span> <span class="n">reverse</span> <span class="o">(</span><span class="n">as</span> <span class="bp">++</span> <span class="n">bs</span><span class="o">)</span> <span class="bp">=</span> <span class="n">reverse</span> <span class="n">bs</span> <span class="bp">++</span> <span class="n">reverse</span> <span class="n">as</span> <span class="o">:=</span> <span class="kd">by</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">reverse_def</span><span class="o">,</span> <span class="n">reverseAux_append</span><span class="o">,</span> <span class="n">reverse_def</span><span class="o">,</span> <span class="bp">←</span><span class="n">reverseAux_append&#39;</span><span class="o">,</span> <span class="n">nil_append</span><span class="o">,</span>
      <span class="n">reverse_def</span><span class="o">]</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="terms_and_formulas.html" class="btn btn-neutral float-right" title="10. Terms and Formulas" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="deduction_for_propositional_logic.html" class="btn btn-neutral float-left" title="8. Deduction for Propositional Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>