<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>12. Decision Procedures for First-Order Logic &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script>window.MathJax = {"loader": {"load": ["[tex]/bussproofs"]}, "tex": {"packages": {"[+]": ["bussproofs"]}, "macros": {"fn": ["\\mathit{#1}", 1], "fa": ["\\forall #1. \\,", 1], "ex": ["\\exists #1. \\,", 1], "bN": "{\\mathbb{N}}", "bZ": "{\\mathbb{Z}}", "bR": "{\\mathbb{R}}", "limplies": "\\to", "liff": "\\leftrightarrow", "proves": "\\vdash", "append": "\\mathbin{+\\mkern-10mu+}", "tval": ["[\\![#1]\\!]", 1], "fCenter": "\\proves", "mdl": ["\\mathfrak{#1}", 1]}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="13. Using SMT solvers" href="using_smt_solvers.html" />
    <link rel="prev" title="11. Implementing First-Order Logic" href="implementing_first_order_logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Logic and Mechanized Reasoning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_propositional_logic.html">8. Proof Systems for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_proof_assistant.html">9. Using Lean as a Proof Assistant</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">11. Implementing First-Order Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">12. Decision Procedures for First-Order Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#equality">12.1. Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementing-congruence-closure">12.2. Implementing congruence closure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#deciding-universal-sentences">12.3. Deciding universal sentences</a></li>
<li class="toctree-l2"><a class="reference internal" href="#linear-arithmetic">12.4. Linear arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementing-fourier-motzkin">12.5. Implementing Fourier-Motzkin</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-full-decision-procedure">12.6. A full decision procedure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#other-theories">12.7. Other theories</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">13. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_first_order_logic.html">14. Proof Systems for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">15. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="beyond_first_order_logic.html">16. Beyond First-Order Logic</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><span class="section-number">12. </span>Decision Procedures for First-Order Logic</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/decision_procedures_for_first_order_logic.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="decision-procedures-for-first-order-logic">
<span id="chapter-decision-procedures-for-first-order-logic"></span><h1><span class="section-number">12. </span>Decision Procedures for First-Order Logic<a class="headerlink" href="#decision-procedures-for-first-order-logic" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>In the terminology of logic and computer science, a <em>decision procedure</em> is an
algorithm that accepts a class of yes/no questions and answers them correctly. Fix a set of first-order sentences, <span class="math notranslate nohighlight">\(\Gamma\)</span>, which we can think of as a set of axioms of as a description of a
possible state of affairs. Here are some questions we can ask:</p>
<ul class="simple">
<li><p>Given  a first-order sentence <span class="math notranslate nohighlight">\(A\)</span>,
does <span class="math notranslate nohighlight">\(\Gamma\)</span> prove <span class="math notranslate nohighlight">\(A\)</span>, that is, <span class="math notranslate nohighlight">\(\Gamma \proves A\)</span>?</p></li>
<li><p>Given  a first-order sentence <span class="math notranslate nohighlight">\(A\)</span>,
does <span class="math notranslate nohighlight">\(\Gamma\)</span> entail <span class="math notranslate nohighlight">\(A\)</span>, that is, <span class="math notranslate nohighlight">\(\Gamma \models A\)</span>?</p></li>
<li><p>Given  a first-order sentence <span class="math notranslate nohighlight">\(A\)</span>,
is <span class="math notranslate nohighlight">\(\Gamma \cup \{ A \}\)</span> is satisfiable, that is, is there a model
<span class="math notranslate nohighlight">\(\mdl M\)</span> of <span class="math notranslate nohighlight">\(\Gamma\)</span> in which <span class="math notranslate nohighlight">\(A\)</span> is true?</p></li>
</ul>
<p>The first two questions are equivalent. We
have not yet presented deductive systems for first-order logic, but we will do so in
<a class="reference internal" href="proof_systems_for_first_order_logic.html#chapter-proof-systems-for-first-order-logic"><span class="std std-numref">Chapter 14</span></a>, and by the soundness and
completeness theorems for those systems, we will have that a sentence <span class="math notranslate nohighlight">\(A\)</span> is provable from
a set of hypotheses <span class="math notranslate nohighlight">\(\Gamma\)</span> if and only if it is entailed by <span class="math notranslate nohighlight">\(\Gamma\)</span>.
The third question is equivalent to the first two by translation: as with propositional logic,
we have that <span class="math notranslate nohighlight">\(\Gamma \models A\)</span> if and only if <span class="math notranslate nohighlight">\(\Gamma \cup \{ \lnot A \}\)</span> is
unsatisfiable. So questions about entailment are equivalent to questions about satisfiability,
negating the formula in question.</p>
<p>Whether or not a problem of the form above is decidable depends on <span class="math notranslate nohighlight">\(\Gamma\)</span>. For example,
if <span class="math notranslate nohighlight">\(\Gamma\)</span> is empty, the first question boils down to the question as to whether a sentence
<span class="math notranslate nohighlight">\(A\)</span> is provable in first-order logic. If the language in question has a binary relation symbol
or two unary function symbols, the question is undecidable. In the special case where the language
has only unary predicate symbols and a single function symbol, the question is decidable.
Neither of these facts are easy to prove.</p>
<p>Interestingly, adding axioms to <span class="math notranslate nohighlight">\(\Gamma\)</span> can make provability decidable. One way to think
of this is that doing so constrains the types of models that have to be considered.
Given a set of axioms <span class="math notranslate nohighlight">\(\Gamma\)</span>, deciding whether or not provability is decidable
of often hard, and, for that reason, generally interesting. To show that the answer is ‚Äúyes,‚Äù
one should describe an algorithm, and then there is the further question as to whether the
algorithm can be made to run efficiently on the specific questions we care about. A ‚Äúno‚Äù answer
usually proceeds to showing that a solution would lead to a solution to the halting problem,
or another problem that has been shown to be reducible to it.</p>
<p>The second type question above asks about the truth of a sentence <span class="math notranslate nohighlight">\(A\)</span> in all models of
<span class="math notranslate nohighlight">\(\Gamma\)</span>, and the third type of question above asks about the truth of a sentence
<span class="math notranslate nohighlight">\(A\)</span> in <em>some</em> model of <span class="math notranslate nohighlight">\(\Gamma\)</span>. There are other types of decision procedures we
might consider. Fixing a model <span class="math notranslate nohighlight">\(\mdl M\)</span>, we can ask:</p>
<ul class="simple">
<li><p>Given a first-order formula <span class="math notranslate nohighlight">\(A\)</span>, possibly with free variables,
is there a variable assignment <span class="math notranslate nohighlight">\(\sigma\)</span> such that <span class="math notranslate nohighlight">\(A\)</span> is true in <span class="math notranslate nohighlight">\(\mdl M\)</span>
under <span class="math notranslate nohighlight">\(\sigma\)</span>, that is, <span class="math notranslate nohighlight">\(\models_{\mdl M, \sigma} A\)</span>?</p></li>
<li><p>Given a first-order formula <span class="math notranslate nohighlight">\(A\)</span>, possibly with free variables,
is <span class="math notranslate nohighlight">\(A\)</span> is true in <span class="math notranslate nohighlight">\(\mdl M\)</span> under every assignment <span class="math notranslate nohighlight">\(\sigma\)</span>?</p></li>
</ul>
<p>In the first case, <span class="math notranslate nohighlight">\(A\)</span> is said to be <em>satisfiable</em> in <span class="math notranslate nohighlight">\(\mdl M\)</span>, and in the second case,
it is said to be <span class="math notranslate nohighlight">\(A\)</span> <em>valid</em> in <span class="math notranslate nohighlight">\(\mdl M\)</span>. But be careful: the words are being used
in a slightly different sense than before, when satisfiable meant ‚Äútrue in some model‚Äù rather than
‚Äútrue for some assignment‚Äù and valid meant ‚Äútrue in all models‚Äù rather than
‚Äútrue for all assignments.‚Äù</p>
<p>Remember that a sentence is a formula without free variables.
If <span class="math notranslate nohighlight">\(A\)</span> is a sentence, both questions boil down to the question as to
whether <span class="math notranslate nohighlight">\(A\)</span> is true in <span class="math notranslate nohighlight">\(\mdl M\)</span>. Notice that if <span class="math notranslate nohighlight">\(A\)</span> has free variables
<span class="math notranslate nohighlight">\(x_1, x_2, \ldots, x_n\)</span>, then the following are all equivalent:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A\)</span> is satisfiable in <span class="math notranslate nohighlight">\(\mdl M\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\ex {x_1, x_2, \ldots, x_n} A\)</span> is true in <span class="math notranslate nohighlight">\(\mdl M\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x_1, x_2, \ldots, x_n} \lnot A\)</span> is false in <span class="math notranslate nohighlight">\(\mdl M\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot A\)</span> is not valid in <span class="math notranslate nohighlight">\(\mdl M\)</span>.</p></li>
</ul>
<p>It is confusing that there are so many ways to ask the same question! But you have to get used
to it: logicians and computer scientists slip back and forth between the different ways of
thinking about a problem, sometimes even in the same sentence.</p>
<p>The relationship between the first group of questions, having to do with entailment and
satisfiability, and the second group of questions, having to do with truth in models, is
subtle. Sometimes, for a given model <span class="math notranslate nohighlight">\(\mdl M\)</span>, there is a natural set of axioms <span class="math notranslate nohighlight">\(\Gamma\)</span>
such that a sentence is true in <span class="math notranslate nohighlight">\(\mdl M\)</span> if and only if it is provable from <span class="math notranslate nohighlight">\(\Gamma\)</span>.
Sometimes, instead, one can show that there is <em>no</em> computable set of axioms that has this property.
Life is complicated! The set of all true sentences of a model <span class="math notranslate nohighlight">\(\mdl M\)</span>
is called ‚Äúthe theory of <span class="math notranslate nohighlight">\(\mdl M\)</span>, so we can express the last property
by saying that the theory of <span class="math notranslate nohighlight">\(\mdl M\)</span> is not computable.</p>
<p>To muddy the waters even further, instead of asking questions about all first-order formulas,
we can consider restricted problems where we are only allowed to ask about formulas of a certain
kind. A formula is said to be <em>quantifier-free</em> if it has no quantifiers, <em>universal</em> if it consists
of any number of universal quantifiers <span class="math notranslate nohighlight">\(\forall\)</span> (possibly none) followed by a
quantifier-free formula, and <em>existential</em> if it consists of any number of existential quantifiers
followed by a quantifier-free formula. In some cases, So we can ask, for a decision procedure for
the provability of universal formulas from a set of axioms or for the satisfiability of an
existential formula in a model, and in some cases, we may have a positive answer even though
the full problem is undecidable.</p>
<p>In this chapter, we will describe, in detail,
a decision procedure for the validity universal formulas in pure first-order logic, that is,
first-order logic without any axioms. We will also describe a decision procedure for the
satisfiability of quantifier-free formulas in the theory of linear equations and
inequalities in the real numbers. Finally, we will state some other important decidability and
undecidability results, to give you a fuller sense of the landscape.
In <a class="reference internal" href="using_smt_solvers.html#chapter-using-smt-solvers"><span class="std std-numref">Chapter 13</span></a>, we will consider SMT solvers,
whose main strength is that they are capable of combining decision procedures for the
quantifier-free parts of various theories and using them together effectively.</p>
<section id="equality">
<span id="section-equality"></span><h2><span class="section-number">12.1. </span>Equality<a class="headerlink" href="#equality" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Fix a language, <span class="math notranslate nohighlight">\(L\)</span>. We will consider equations <span class="math notranslate nohighlight">\(s = t\)</span> and <em>disequations</em>
<span class="math notranslate nohighlight">\(u \ne v\)</span> between closed terms.
The fact that we are considering closed terms mean that there are no variables to substitute
for; computer scientists sometimes call these <em>ground</em> terms.
(As with unification, in some contexts we may want to treat some variables as constant.
What is important here is not whether we call them variables or constants, but, rather,
the fact that we are not considering substitutions.)</p>
<p>The problem we are addressing here is this: given a set of equations and disequations, is
it satisfiable? Notice that here we are asking about satisfiability in <em>any</em> model. In particular,
the set</p>
<div class="math notranslate nohighlight">
\[\{ s_1 = t_1, \ldots, s_n = t_n, u_1 \ne v_1, \ldots, u_m \ne v_m \}\]</div>
<p>is <em>unsatisfiable</em> if and only if we have</p>
<div class="math notranslate nohighlight">
\[s_1 = t_1, \ldots, s_n = t_n \proves u_1 = v_1 \lor \cdots \lor u_m = v_m\]</div>
<p>So we can think of the problem in either way.</p>
<p>For example, consider the following set of sentences:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(f(a, a) = b\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(g(c, a) = c\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(g(c, f(a, a)) = f(g(c, a), g(c, a))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(f(c, c) \ne g(c, b)\)</span></p></li>
</ol>
<p>Is it satisfiable?</p>
<p>Before we answer that, let‚Äôs make some general observations. A set that only has equations and
no disequations is easily satisfiable, namely, in a model with a single element, where every
expression is equal to every other one. Similarly, a set that only has disequations is easily
satisfiable, unless one of the disequations is of the form <span class="math notranslate nohighlight">\(t \ne t\)</span>.
For that purpose, we can use the term model, where every term is interpreted as itself.
The interesting cases fall in between these two extremes, where the equations and disequations
balance one another.</p>
<p>Coming back to the question, the following considerations show that the answer is ‚Äúno.‚Äù
Each of the following is a consequence of the equations above:</p>
<ol class="arabic simple" start="5">
<li><p><span class="math notranslate nohighlight">\(g(c, f(a, a)) = g(c, b)\)</span> from 1</p></li>
<li><p><span class="math notranslate nohighlight">\(f(g(c, a), g(c, a)) = f(c, c)\)</span> from 2</p></li>
<li><p><span class="math notranslate nohighlight">\(f(c, c) = g(c, b)\)</span> from 3, 5, and 6.</p></li>
</ol>
<p>This contradicts the disequation 4 above. To understand what is going on, it is helpful
to think of <span class="math notranslate nohighlight">\(f\)</span> as addition, <span class="math notranslate nohighlight">\(g\)</span> as multiplication, <span class="math notranslate nohighlight">\(a\)</span> as the number 1,
and <span class="math notranslate nohighlight">\(b\)</span> as the number 2.
But the argument is fully abstract, and shows that the disequation cannot hold in any
model in which all the equations are satisfied.</p>
<p>These considerations encapsulate the main ideas behind the proof of the following theorem:</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>The question as to whether a finite set of ground equations and disequations is satisfiable
is decidable.</p>
</div>
<p>The idea behind the proof is to use a <em>saturation</em> argument: starting from the equations in
question, we derive new equations until no more equations are derivable.
If we manage to contradict one of the disequations, the original set is not satisfiable.
In the case where no contradiction is found, we will argue that the original set is satisfiable.</p>
<p>To make all this precise, we need a set of rules for deriving equations.</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$t = t$}
\end{prooftree}
\quad \quad
\begin{prooftree}
\AXC{$s = t$}
\UIC{$t = s$}
\end{prooftree}
\quad \quad
\begin{prooftree}
\AXC{$r = s$}
\AXC{$s = t$}
\BIC{$r = t$}
\end{prooftree}
\quad\quad
\begin{prooftree}
\AXC{$s_1 = t_1$}
\AXC{$\ldots$}
\AXC{$s_n = t_n$}
\TIC{$f(s_1, \ldots, s_n) = f(t_1, \ldots, t_n)$}
\end{prooftree}
\]</div></div></blockquote>
<p>The first three rules express the reflexivity, symmetry, and transitivity of equality,
respectively.
The last rule is called the <em>congruence</em> rule.
You should convince yourself that using these rules we can derive</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$r = s$}
\UIC{$t[r/x] = t[s/x]$}
\end{prooftree}
\]</div></div></blockquote>
<p>for any terms <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(s\)</span>, and <span class="math notranslate nohighlight">\(t\)</span> and variable <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>Returning to our proof plan, we want to show that if applying these rules successively
does not result in a contradiction, then there is a model in which the original equations
and disequations are all true.
But a problem arises: what if the original set contains an equation <span class="math notranslate nohighlight">\(a = f(a)\)</span>?
Then our algorithm falls into an infinite loop, deriving
<span class="math notranslate nohighlight">\(a = f(a) = f(f(a)) = f(f(f(a))) = \ldots\)</span>.
The solution is to restrict attention to <em>subterms</em> of terms appearing in the original
equations and disequations.
The theorem follows from the following lemma.</p>
<div class="admonition-lemma admonition">
<p class="admonition-title">Lemma</p>
<p>Let <span class="math notranslate nohighlight">\(\Gamma\)</span> consist of a set of equations and disequations.
Let <span class="math notranslate nohighlight">\(S\)</span> be the set of subterms of all the terms occurring in <span class="math notranslate nohighlight">\(\Gamma\)</span>.
Let <span class="math notranslate nohighlight">\(\Gamma'\)</span> be the set of all equations between elements of <span class="math notranslate nohighlight">\(S\)</span>
that can be derived from the equations in <span class="math notranslate nohighlight">\(\Gamma\)</span> using the rules above.
Then <span class="math notranslate nohighlight">\(\Gamma\)</span> is satisfiable if and only if no disequation in <span class="math notranslate nohighlight">\(\Gamma\)</span>
is the negation of an equation in <span class="math notranslate nohighlight">\(\Gamma'\)</span>.</p>
</div>
<p>The algorithm implicit in this lemma is called <em>congruence closure</em>.</p>
<div class="admonition-proof admonition">
<p class="admonition-title">Proof</p>
<p>One direction of the lemma is easy. Since the equational rules preserve truth in any
model, if we can derive a contradiction from the equations and disequations in <span class="math notranslate nohighlight">\(\Gamma\)</span>,
then <span class="math notranslate nohighlight">\(\Gamma\)</span> is unsatisfiable. The other direction is harder.
Since there are only finitely many pairs of terms in <span class="math notranslate nohighlight">\(S\)</span>, the algorithm necessarily
terminates.
We need to show that if it terminates without deriving a contradiction, then there is a model
that satisfies <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<p>Say two elements <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> are <em>equivalent</em>, written <span class="math notranslate nohighlight">\(s \equiv t\)</span>,
if they are proved equal from the
equations in <span class="math notranslate nohighlight">\(\Gamma\)</span>. The rules guarantee that this is an <em>equivalence relation</em>, which is
to say, it is reflexive, symmetric, and transitive. It is also a <em>congruence</em>, which means that
applying a function symbol to equivalent terms results in equivalent terms.</p>
<p>To each element <span class="math notranslate nohighlight">\(t\)</span>, we associate its <em>equivalence class</em> <span class="math notranslate nohighlight">\([t]\)</span>, defined by</p>
<div class="math notranslate nohighlight">
\[[t] = \{ s \in S \mid s \equiv t \}.\]</div>
<p>In words, <span class="math notranslate nohighlight">\([t]\)</span> is the set of terms equivalent to <span class="math notranslate nohighlight">\(t\)</span>.
Assuming the algorithm terminates without a contradiction, define a model <span class="math notranslate nohighlight">\(\mdl M\)</span>
whose universe consists of all the equivalence classes of elements of <span class="math notranslate nohighlight">\(S\)</span>
together with a new element, <span class="math notranslate nohighlight">\(\star\)</span>. For elements <span class="math notranslate nohighlight">\(t_1, \ldots t_n\)</span> in <span class="math notranslate nohighlight">\(S\)</span>,
interpret each <span class="math notranslate nohighlight">\(n\)</span>-ary function symbol <span class="math notranslate nohighlight">\(f\)</span> by the function</p>
<div class="math notranslate nohighlight">
\[\begin{split}f^{\mdl M}([t_1], \ldots, [t_n]) = \begin{cases}
  [f(t_1, \ldots, t_n)] &amp; \text{if $f(t_1, \ldots, t_n)$ is in $S$} \\
  \star &amp; \text{otherwise}
\end{cases}\end{split}\]</div>
<p>In other words, what <span class="math notranslate nohighlight">\(f^{\mdl M}\)</span> does to each equivalence class is determined by what
<span class="math notranslate nohighlight">\(f\)</span> does to each of the elements.
The fact that <span class="math notranslate nohighlight">\(\equiv\)</span> is a congruence ensures that this makes sense.
This is just a truncated version of the term model, in which provably equal terms
are all glued together.</p>
<p>It is not hard to show that for every term <span class="math notranslate nohighlight">\(t\)</span> in <span class="math notranslate nohighlight">\(S\)</span>,
<span class="math notranslate nohighlight">\(\tval{t}_{\mdl M}\)</span> is equal to  <span class="math notranslate nohighlight">\([t]\)</span>.
But this is what we need. For every equation <span class="math notranslate nohighlight">\(s = t\)</span> in <span class="math notranslate nohighlight">\(\Gamma\)</span>, <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> are in the
same equivalence class, so they are equal in the model.
And if <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> are not provably equal, then <span class="math notranslate nohighlight">\([s]\)</span> and <span class="math notranslate nohighlight">\([t]\)</span> are not the same, so
every disequation <span class="math notranslate nohighlight">\(s \ne t\)</span> in <span class="math notranslate nohighlight">\(\Gamma\)</span> is true in <span class="math notranslate nohighlight">\(\mdl M\)</span> as well.</p>
</div>
<p>For examples of the algorithm in action, first let us show that the set</p>
<div class="math notranslate nohighlight">
\[f^3(a) = a, \, f^5(a) = a, \, f(a) \ne a\]</div>
<p>is unsatisfiable, where <span class="math notranslate nohighlight">\(f^n(a)\)</span> abbreviates <span class="math notranslate nohighlight">\(n\)</span>-fold application <span class="math notranslate nohighlight">\(f(f(\cdots f(a)))\)</span>.
The set of all subterms is</p>
<div class="math notranslate nohighlight">
\[a, \, f(a), \, f^2(a), \, f^3(a), \, f^4(a), \, f^5(a).\]</div>
<p>We start with the equivalence classes <span class="math notranslate nohighlight">\(\{ a, f^3(a) \}\)</span> and <span class="math notranslate nohighlight">\(\{ a, f^5(a)\}\)</span>
as well as all the others subterms in singleton sets.
From <span class="math notranslate nohighlight">\(a = f^3(a)\)</span> we derive <span class="math notranslate nohighlight">\(f(a) = f^4(a)\)</span> by congruence, giving rise to the set
<span class="math notranslate nohighlight">\(\{ f(a), f^4(a) \}\)</span>. Applying congruence again gives rise to the set <span class="math notranslate nohighlight">\(\{ f^2(a), f^5(a) \}\)</span>,
which is merged with <span class="math notranslate nohighlight">\(\{ a, f^5(a)\}\)</span> to yield <span class="math notranslate nohighlight">\(\{ a, f^2(a), f^5(a) \}\)</span>.
Applying congruence again yields <span class="math notranslate nohighlight">\(\{ f(a), f^3(a) \}\)</span>. (We ignore the term <span class="math notranslate nohighlight">\(f^6(a)\)</span>.)
This is merged with the set <span class="math notranslate nohighlight">\(\{ a, f^3(a) \}\)</span> to yield <span class="math notranslate nohighlight">\(\{ a, f(a), f^3(a)\}\)</span>.
Applying congruence again yields <span class="math notranslate nohighlight">\(\{ f(a), f^2(a), f^4(a)\}\)</span>, which is merged with
<span class="math notranslate nohighlight">\(\{ a, f(a), f^3(a) \}\)</span> and <span class="math notranslate nohighlight">\(\{ f^2(a), f^5(a) \}\)</span> to yield
<span class="math notranslate nohighlight">\(\{ a, f(a), f^2(a), f^3(a), f^5(a) \}\)</span>.
At this point, we have derived <span class="math notranslate nohighlight">\(f(a) = a\)</span>, contradicting the disequality in the original set.
So the set is unsatisfiable.</p>
<p>Suppose we start instead with the set</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[f^2(a) = a, \, f^4(a) = a, \, f(a) \ne a, \, f(a) \ne b\]</div>
</div></blockquote>
<p>You can check that in this case, the algorithm terminates with the following three
equivalence classes:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\([a] = \{ a, f^2(a), f^4(a)\}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\([f(a)] = \{ f(a), f^3(a) \}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\([b] = \{ b \}\)</span>.</p></li>
</ul>
<p>We now construct a model <span class="math notranslate nohighlight">\(\mdl M\)</span> with these elements and an additional element <span class="math notranslate nohighlight">\(\star\)</span>, with</p>
<div class="math notranslate nohighlight">
\[\begin{split}f^{\mdl M}([a]) &amp; = [f(a)] \\
f^{\mdl M}([f(a)]) &amp; = [a] \\
f^{\mdl M}([b]) &amp; = \star \\
f^{\mdl M}(\star) &amp; = \star\end{split}\]</div>
<p>You can check that this satisfies the original set of equations and disequations. We don‚Äôt really need
to introduce the new element <span class="math notranslate nohighlight">\(\star\)</span>; you can check that everything works if we replace it by
any of the equivalence classes. We simply find it clearer to use <span class="math notranslate nohighlight">\(\star\)</span> as a catch-all for
everything that falls outside the scope of the finite set of terms we started with.</p>
<p>Our analysis establishes an interesting property of
first-order logic: it is possible to prove a disjunction <span class="math notranslate nohighlight">\(u_1 = v_1 \lor \cdots \lor u_m = v_m\)</span>
from a set of equation if and only if it is possible to prove <span class="math notranslate nohighlight">\(u_i = v_i\)</span> for some <span class="math notranslate nohighlight">\(i\)</span>.
This is a property known as <em>convexity</em>. It relies on the fact that we allow only positive
equations on the right-hand side. For example, <span class="math notranslate nohighlight">\(a = b \lor a \ne b\)</span> is provable in
first-order logic, but clearly neither disjunct is provable on its own.</p>
<p>We have described the algorithm as working on closed terms, that is, terms with no variables.
Of course, there is no harm if we allow variables in the terms and simply treat them as
constants. The point is that in this formulation of the problem, a hypothesis <span class="math notranslate nohighlight">\(f(x) = a\)</span>
is interpreted as a statement about one particular <span class="math notranslate nohighlight">\(x\)</span> that never changes in the
statement of a problem. It is an entirely different problem to consider hypotheses
like <span class="math notranslate nohighlight">\(\fa x f(x) = a\)</span> for which we are allowed to substitute any term for <span class="math notranslate nohighlight">\(x\)</span>.
For example, we might want to add axioms like <span class="math notranslate nohighlight">\(\fa {x, y, z} (x + y) + z\)</span> and
<span class="math notranslate nohighlight">\(\fa {x, y}. x + y = y + x\)</span> as axioms for the integers or real numbers. The problem of
determining whether a single equation follows from a set of universally
quantified equations is known as the <em>word problem</em>, and, in general it is undecidable.</p>
</section>
<section id="implementing-congruence-closure">
<h2><span class="section-number">12.2. </span>Implementing congruence closure<a class="headerlink" href="#implementing-congruence-closure" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Congruence closuure can be implemented efficiently (and <em>is</em> implemented efficiently in SMT
solvers) using <em>union-find</em> data structures.</p>
<p>[This section needs to be written. In the meanwhile, see the <a class="reference external" href="https://www.cs.cmu.edu/~mheule/15311-s24/slides/congruence-closure.pdf">slides</a> and the file <code class="docutils literal notranslate"><span class="pre">CongruenceClosure.lean</span></code>].</p>
</section>
<section id="deciding-universal-sentences">
<span id="id1"></span><h2><span class="section-number">12.3. </span>Deciding universal sentences<a class="headerlink" href="#deciding-universal-sentences" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Remember that the following problems are all intertranslatable:</p>
<ul class="simple">
<li><p>Given a universal sentence <span class="math notranslate nohighlight">\(A\)</span>, is <span class="math notranslate nohighlight">\(A\)</span> valid, that is, true in every model? (Equivalently:
if <span class="math notranslate nohighlight">\(A\)</span> provable?)</p></li>
<li><p>Given a quantifier-free formula <span class="math notranslate nohighlight">\(A\)</span>, does <span class="math notranslate nohighlight">\(\models_{\mdl{M}, \sigma} A\)</span> hold for every
model <span class="math notranslate nohighlight">\(\mdl M\)</span> and every variable assignment <span class="math notranslate nohighlight">\(\sigma\)</span>?</p></li>
<li><p>Given a quantifier-free formula <span class="math notranslate nohighlight">\(A\)</span>, does <span class="math notranslate nohighlight">\(\models_{\mdl{M}, \sigma} A\)</span> hold for <em>some</em>
model <span class="math notranslate nohighlight">\(\mdl M\)</span> and variable assignment <span class="math notranslate nohighlight">\(\sigma\)</span>?</p></li>
<li><p>Given an existential sentence <span class="math notranslate nohighlight">\(A\)</span>, is <span class="math notranslate nohighlight">\(A\)</span> satisfiable, that is, true in some model?</p></li>
</ul>
<p>In particular, a universal formula <span class="math notranslate nohighlight">\(\fa {\vec x} A\)</span> is valid if and only if <span class="math notranslate nohighlight">\(A\)</span> holds
for every model and every variable assignment, which happens if and only if <span class="math notranslate nohighlight">\(\lnot A\)</span> never holds for any model and variable assignment, which happens if and only if <span class="math notranslate nohighlight">\(\ex {\vec x} \lnot A\)</span> is
not satisfiable. Notice that in each case we are asking questions about <em>pure</em> first-order logic,
without any axioms <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<p>Remember that in first-order logic, the atomic formulas include equations <span class="math notranslate nohighlight">\(s = t\)</span> and formulas
<span class="math notranslate nohighlight">\(R(t_1, \ldots, t_n)\)</span>, where <span class="math notranslate nohighlight">\(R\)</span> is a relation symbol. The set of <em>literals</em> include the
negations of those as well. It is not hard to extend congruence closure to an algorithm to determine
the satisfiability of any finite set of literals. To start with, we add the following rule to our
equational proof system:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[
\begin{prooftree}
\AXC{$s_1 = t_1$}
\AXC{$\ldots$}
\AXC{$s_n = t_n$}
\AXC{$R(s_1, \ldots, s_n)$}
\QuaternaryInfC{$R(t_1, \ldots, t_n)$}
\end{prooftree}
\]</div></div></blockquote>
<p>Suppose <span class="math notranslate nohighlight">\(\Gamma\)</span> is a set of literals.
To test the satisfiability of <span class="math notranslate nohighlight">\(\Gamma\)</span>, we do not have to change much in the previous algorithm.
Using the congruence rule for relations, whenever we have derived <span class="math notranslate nohighlight">\(R(s_1, \ldots, s_n)\)</span>
and we have also derived equations <span class="math notranslate nohighlight">\(s_i = t_i\)</span> for every <span class="math notranslate nohighlight">\(i\)</span>,
we can conclude <span class="math notranslate nohighlight">\(R(t_1, \ldots, t_n)\)</span>.
The algorithm terminates when we contradict a disequality or another negated atomic formula.
If the algorithm terminates without a contradiction, we build a model as before,
where we simply declare that <span class="math notranslate nohighlight">\(R^{\mdl M}([t_1], \ldots, [t_n])\)</span> holds if and only if
we have determined that <span class="math notranslate nohighlight">\(R(t_1, \ldots, t_n)\)</span> in a consequence of the original set.
Another way to think about the algorithm is that we can replace each atomic formula
<span class="math notranslate nohighlight">\(R(t_1, \ldots, t_n)\)</span>
by an equation <span class="math notranslate nohighlight">\(f_R(t_1, \ldots, t_n) = \top\)</span> and each negated atomic formula
<span class="math notranslate nohighlight">\(\lnot R(t_1, \ldots, t_n)\)</span> by a disequation <span class="math notranslate nohighlight">\(f_R(t_1, \ldots, t_n) \ne \top\)</span> and
run the usual congruence closure algorithm on that.</p>
<p>Now suppose we are given an existential sentence <span class="math notranslate nohighlight">\(\ex {x_1, \ldots, x_n} A\)</span>
where <span class="math notranslate nohighlight">\(A\)</span> is quantifier-free, and suppose we want to determine whether it is satisfiable.
Write <span class="math notranslate nohighlight">\(A\)</span> in disjunctive normal form, that is, as a disjunction
<span class="math notranslate nohighlight">\(A_1 \lor \cdots \lor A_n\)</span> of conjunctions of literals.
Then <span class="math notranslate nohighlight">\(\ex {x_1, \ldots, x_n} A\)</span> is satisfiable if and only if one of the formulas
<span class="math notranslate nohighlight">\(A_1, \ldots, A_n\)</span> is satisfied by some model <span class="math notranslate nohighlight">\(\mdl M\)</span> and variable assignment
<span class="math notranslate nohighlight">\(\sigma\)</span>. That reduces the task to determining whether a conjunction of literals is satisfiable,
and we have just explained how to do that.</p>
<p>Since a sentence is valid if and only if its negation is satisfiable, and since the negation
of a universal sentence is an existential sentence, we have shown the following.</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>The validity of universal sentences in pure first-order logic is decidable.
Equivalently, the satisfiability of existential sentences is decidable.</p>
</div>
</section>
<section id="linear-arithmetic">
<h2><span class="section-number">12.4. </span>Linear arithmetic<a class="headerlink" href="#linear-arithmetic" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>We now turn from questions having to do with satisfiability and validity in arbitrary
models to questions about satisfiability in a particular model, namely, the real numbers.
A <em>linear expression</em> is one of the form <span class="math notranslate nohighlight">\(a_1 x_1 + a_2 x_2 + \cdots + a_n x_n + b\)</span>,
where each <span class="math notranslate nohighlight">\(a_i\)</span> is a rational number, <span class="math notranslate nohighlight">\(b\)</span> is a rational number,
and each <span class="math notranslate nohighlight">\(x_i\)</span> is a variable.
We think of the variables <span class="math notranslate nohighlight">\(x_i\)</span> as ranging over the real numbers.
A <em>linear constraint</em> is one of the form <span class="math notranslate nohighlight">\(s = t\)</span> or <span class="math notranslate nohighlight">\(s &lt; t\)</span>, where
<span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> are linear expressions. (In practice, we usually include constraints
of the form <span class="math notranslate nohighlight">\(s \le t\)</span> and sometimes <span class="math notranslate nohighlight">\(s \ne t\)</span> as well. But the first can be
written <span class="math notranslate nohighlight">\(s &lt; t\)</span> and the second can be written <span class="math notranslate nohighlight">\(s &lt; t \lor t &lt; s\)</span>, so questions about
those can be rexpressed in terms of <span class="math notranslate nohighlight">\(&lt;\)</span> and <span class="math notranslate nohighlight">\(=\)</span>, and focusing on those will simplify
the presentation below.)</p>
<p>Notice that any linear constraint is equivalent to one of the form <span class="math notranslate nohighlight">\(t = 0\)</span> or <span class="math notranslate nohighlight">\(t &gt; 0\)</span>,
since we can move all the terms to one side. For example, the constraint <span class="math notranslate nohighlight">\(3 x + 2 y &lt; 3y + 4z\)</span>
is equivalent to <span class="math notranslate nohighlight">\(-3x + y + 4z &gt; 0\)</span>.
An important observation that we will use below is that any linear constraint that involves
a variable <span class="math notranslate nohighlight">\(x\)</span> can be written as <span class="math notranslate nohighlight">\(x = t\)</span>, <span class="math notranslate nohighlight">\(x &lt; t\)</span>, or <span class="math notranslate nohighlight">\(t &lt; x\)</span>,
where <span class="math notranslate nohighlight">\(x\)</span> does not occur in <span class="math notranslate nohighlight">\(t\)</span>.
We do this by simply solving for <span class="math notranslate nohighlight">\(x\)</span>.
For example, the previous constraint can be expressed as <span class="math notranslate nohighlight">\(x &lt; (1/3)y + (4/3)z\)</span>.
Remember that dividing both sides of an inequality by a negative number reverses the direction.</p>
<p>In this section we say that a set <span class="math notranslate nohighlight">\(\Gamma\)</span> of linear constraints is <em>satisfiable</em> if and only
if there is an assignment of real
values to the variables that makes them all true. Our first goal is to prove the following.</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>The question as to whether a finite set of linear constraints is satisfiable is
decidable.</p>
</div>
<div class="admonition-proof admonition">
<p class="admonition-title">Proof</p>
<p>We use induction on the number of variables. If there are no variables at all,
<span class="math notranslate nohighlight">\(\Gamma\)</span> contains only expressions of the form <span class="math notranslate nohighlight">\(b_0 &lt; b_1\)</span> or <span class="math notranslate nohighlight">\(b_0 = b_1\)</span>
where <span class="math notranslate nohighlight">\(b_0\)</span> and <span class="math notranslate nohighlight">\(b_1\)</span> are constants, and we only need to perform
the comparisons to see whether they are true. Remember that if <span class="math notranslate nohighlight">\(\Gamma\)</span>
is the empty set, we take it to be trivially satisfied.</p>
<p>In the inductive step, <span class="math notranslate nohighlight">\(\Gamma\)</span> contains a variable.
If <span class="math notranslate nohighlight">\(\Gamma\)</span> contains any false constant equations, it is unsatisfiable,
and it it contains any true constant equations, we can remove them without
affecting satisfiability.
If <span class="math notranslate nohighlight">\(\Gamma\)</span> contains a nontrivial equation with a variable <span class="math notranslate nohighlight">\(x\)</span>,
we put
it in the form <span class="math notranslate nohighlight">\(x = t\)</span> and then substitute <span class="math notranslate nohighlight">\(t\)</span> for <span class="math notranslate nohighlight">\(x\)</span> everywhere.
The resulting set of constraints has one fewer variable, and clearly
it is equisatisfiable with the original one.
Given an assignment to the new set of constraints, we just assign <span class="math notranslate nohighlight">\(x\)</span>
the value of <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>So we can now assume that there are no equations in <span class="math notranslate nohighlight">\(\Gamma\)</span>.
We can divide the inequalities in <span class="math notranslate nohighlight">\(\Gamma\)</span> intro three kinds:</p>
<ul class="simple">
<li><p>those that don‚Äôt contain <span class="math notranslate nohighlight">\(x\)</span> at all</p></li>
<li><p>those that can be expressed in the form <span class="math notranslate nohighlight">\(s_i &lt; x\)</span></p></li>
<li><p>those that can be expressed in the form <span class="math notranslate nohighlight">\(x &lt; t_j\)</span></p></li>
</ul>
<p>Let <span class="math notranslate nohighlight">\(\Gamma'\)</span> be the set that results from removing the inequalities
in the last two categories
and replacing them with inequalities of the form <span class="math notranslate nohighlight">\(s_i &lt; t_j\)</span>.
We claim <span class="math notranslate nohighlight">\(\Gamma'\)</span> is equisatisfiable with <span class="math notranslate nohighlight">\(\Gamma\)</span>.
Clearly any assignment that satisfies <span class="math notranslate nohighlight">\(\Gamma\)</span> also satisfies <span class="math notranslate nohighlight">\(\Gamma'\)</span>.
Conversely, suppose <span class="math notranslate nohighlight">\(\sigma\)</span> is an assignment that satisfies <span class="math notranslate nohighlight">\(\Gamma'\)</span>.
Then, under that assignment, the value of each <span class="math notranslate nohighlight">\(s_i\)</span> is less than the value
of every <span class="math notranslate nohighlight">\(t_j\)</span>. We obtain an assignment satisfying <span class="math notranslate nohighlight">\(\Gamma\)</span>
by mapping <span class="math notranslate nohighlight">\(x\)</span> to any value between the largest <span class="math notranslate nohighlight">\(s_i\)</span> and the
smallest <span class="math notranslate nohighlight">\(t_j\)</span>. (If one of the last two categories is empty, we
remove the constraints in the other category entirely,
since they can be satisfied by taking <span class="math notranslate nohighlight">\(x\)</span> sufficiently large or sufficiently
small.)</p>
</div>
</section>
<section id="implementing-fourier-motzkin">
<h2><span class="section-number">12.5. </span>Implementing Fourier-Motzkin<a class="headerlink" href="#implementing-fourier-motzkin" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>The procedure implicit in this proof is known as the <em>Fourier-Motzkin</em> procedure.
The idea can be found in the work of Jean-Baptiste Joseph
Fourier in the early nineteenth century (the same Fourier who gave us Fourier
analysis), but it was rediscovered by multiple people in the nineteenth century, including Theo In the worst case, every elimination step divides the number of equations in half and
then squares it, resulting in doubly exponential behavior.
The procedure works well in practice, though, since in many applications each variable is
contained in only a few equations. (There are obvious heuristics, like choosing a variable
at each stage that minimizes the number of equations at the next stage.)
There is an implementation of the procedure in the file <cite>FourierMotzkin.lean</cite> in the <cite>Examples</cite>
folder,
modulo two components that we ask you to supply.
SMT solvers use much more efficient methods based on the simplex algorithm from linear programming.</p>
</section>
<section id="a-full-decision-procedure">
<h2><span class="section-number">12.6. </span>A full decision procedure<a class="headerlink" href="#a-full-decision-procedure" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>We can describe the Fourier-Motzkin procedure more explicitly as a decision procedure
for satisfiability of existential sentences in a langauge for the real numbers as follows.
Suppose we are given a problem in linear arithmetic where the variables are labeled
<span class="math notranslate nohighlight">\(x_1, x_2, \ldots, x_n\)</span> and the
constraints are labeled <span class="math notranslate nohighlight">\(c_1, c_2, \ldots, c_m\)</span>. Then what we are really asking as to whether
the formula <span class="math notranslate nohighlight">\(\ex {x_1, \ldots, x_n} c_1 \land c_2 \land \cdots \land c_m\)</span>
is true of the real numbers when the constraints are interpreted in the expected way.
To make this more precise, consider the structure <span class="math notranslate nohighlight">\((\mathbb R, 0, 1, +, &lt;)\)</span>
in a language with symbols <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(+\)</span>, and <span class="math notranslate nohighlight">\(&lt;\)</span>.
All the constraints can be expressed in this language, albeit in a clunky way. For example,
we can write <span class="math notranslate nohighlight">\(3 x\)</span> as <span class="math notranslate nohighlight">\(x + x + x\)</span>, and express a constraint like <span class="math notranslate nohighlight">\(x -(1/2)y + (4/3)z &lt; 0\)</span>
as <span class="math notranslate nohighlight">\(6x + 8z &lt; 3y\)</span>. Alternatively, we can add symbols for scalar multiplication to the language.</p>
<p>We now obtain a decision procedure for arbitrary existential formulas
<span class="math notranslate nohighlight">\(\ex {x_1, \ldots, x_n} A\)</span> as follows.
Given a formula <span class="math notranslate nohighlight">\(\ex x A\)</span>, put <span class="math notranslate nohighlight">\(A\)</span> into negation normal form, so that all the negations
are pushed down to atomic formulas.
Replace <span class="math notranslate nohighlight">\(\lnot (s &lt; t)\)</span> by <span class="math notranslate nohighlight">\(t &lt; s \lor s = t\)</span>, and we can replace
<span class="math notranslate nohighlight">\(s \ne t\)</span> by <span class="math notranslate nohighlight">\(s &lt; t \lor t &lt; s\)</span>.
(In practice, it is more efficient to include <span class="math notranslate nohighlight">\(\le\)</span> in the language as well, and use the
fact that <span class="math notranslate nohighlight">\(\lnot (s \le t)\)</span> is equivalent to <span class="math notranslate nohighlight">\(t &lt; s\)</span>.)
Putting the result into disjunctive normal form, we can assume that all the atomic
formulas are of the form <span class="math notranslate nohighlight">\(s &lt; t\)</span> or <span class="math notranslate nohighlight">\(s = t\)</span>.
We can move the existential quantifiers through the disjunction as we did in <a class="reference internal" href="#deciding-universal-sentences"><span class="std std-numref">Section 12.3</span></a> and then apply the Fourier-Motzkin procedure to
each disjunction.</p>
<p>In fact, a modification of the algorithm provides a decision procedure for the satisfiability
of <em>any</em> sentence in the language, not just the existential ones.</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>The question as to whether a sentence <span class="math notranslate nohighlight">\(A\)</span> is true in <span class="math notranslate nohighlight">\((\mathbb R, 0, 1, +, &lt;, \le)\)</span>
is decidable.</p>
</div>
<p>We will only sketch the details here.
The algorithm uses an important method known as ‚Äúelimination of quantifiers.‚Äù
The idea is to successively eliminate quantifiers, one by one, until we are left with a
quantifier-free sentence. We can determine the truth of that by simply calculating.</p>
<p>We will show that any formula <span class="math notranslate nohighlight">\(\ex x A\)</span>, where <span class="math notranslate nohighlight">\(A\)</span> is quantifier-free,
is equivalent to a quantifier-free formula <span class="math notranslate nohighlight">\(A'\)</span> that does not include <span class="math notranslate nohighlight">\(x\)</span>.
Repeating the process and using the fact that <span class="math notranslate nohighlight">\(\fa x A\)</span> is equivalent to
<span class="math notranslate nohighlight">\(\lnot \ex x \lnot A\)</span>, we can eliminate all the quantifiers. We are then
left with a quantifier-free sentence, that is, a boolean combination of equations and
inequalities between closed terms. We can decide the truth of that sentence by evaluating
the terms.</p>
<p>We have already seen all the ideas. The procedure above allows us to write
<span class="math notranslate nohighlight">\(\ex x A\)</span> as <span class="math notranslate nohighlight">\((\ex x A_1) \lor (\ex x A_2) \lor \cdots \lor (\ex x A_n)\)</span>
where each <span class="math notranslate nohighlight">\(A_i\)</span> is a conjunction of atomic formulas.
So we only need to show how to eliminate an existential quantifier from a conjunction
of constraints of the form <span class="math notranslate nohighlight">\(s &lt; t\)</span> or <span class="math notranslate nohighlight">\(s = t\)</span>.
But that is exactly what the pivot step in the Fourier-Motzkin procedure does, and we are done.</p>
<p>It is possible to write down axioms that justify every step of the transformation.
The resulting set of axioms is known as the theory of <em>linear arithmetic</em>.
The argument shows that the resulting set of axioms characterizes the structure exactly,
and that the question of provability from those axioms is decidable.</p>
<p>You should also notice that the justification of the procedure only used the fact basic
facts about arithmetic on the real numbers, as well as the fact we can find a real number
between any other two. So the procedure works just the same way, and returns the same answer,
for other structures that satisfy these properties, like the rationals.
In other words, the structure <span class="math notranslate nohighlight">\((\mathbb Q, 0, 1, +, &lt;, \le)\)</span> has exactly the same
theory as <span class="math notranslate nohighlight">\((\mathbb R, 0, 1, +, &lt;, \le)\)</span>.</p>
</section>
<section id="other-theories">
<h2><span class="section-number">12.7. </span>Other theories<a class="headerlink" href="#other-theories" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>What happens if we extend linear arithmetic by adding multiplication between
arbitrary terms? Formally, we are asking about the theory of the real numbers
<span class="math notranslate nohighlight">\((\mathbb{R}, 0, 1, +, \times, &lt;)\)</span> with zero, one, addition,
multiplication, and the less-than relation. It is equivalent to extending
linear arithmetic by allowing atomic formulas <span class="math notranslate nohighlight">\(p = 0\)</span> and <span class="math notranslate nohighlight">\(p &gt; 0\)</span> where <span class="math notranslate nohighlight">\(p\)</span> is
an arbitrary polynomial. The theory, known also as the theory of <em>Real closed
fields</em>, is still decidable. The theorem was proved by Alfred Tarski before World War II,
but it wasn‚Äôt published until 1948, after the war.</p>
<p>Returning to the language without multiplication, one can ask what happens if we replace
the real numbers by the integers.
In other words, we can ask whether the truth of sentences in the structure
<span class="math notranslate nohighlight">\((\mathbb Z, 0, 1, +, &lt;)\)</span> is decidable.
In contrast to the reals, the order on the integers is <em>discrete</em>, since
there is nothing between a value <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(x + 1\)</span>.
The problem is nonetheless decidable.
The result was first proved  in 1926 by Moj≈ºesz Presburger, a student of Tarski‚Äôs,
who later died in the Holocaust. The story has it that Tarski did not think
the result was enough for a dissertation, and made him do more work.
The resulting theory is known as <em>Presburger arithmetic</em> or <em>linear integer arithmetic</em>.</p>
<p>The decision procedure is more complicated than that for linear arithmetic,
and we will not discuss it here.
SMT solvers, however, use efficient implementations of the <em>existential fragment</em>
of the theory, which is to say, the satisfiability problem for quantifier-free formulas.</p>
<p>What happens if we add multiplication?
In contrast to the case with the real numbers, however, the theory of the integers
with addition and multiplication is undecidable.
In other words, there is no algorithm to decide truth in the model
<span class="math notranslate nohighlight">\((\mathbb Z, 0, 1, +, \times)\)</span>.
This follows from the methods that G√∂del used to prove the incompleteness theorems,
and it is also a consequence of <em>Tarski‚Äôs theorem</em> on the undefinability of truth.
The phenomena can be stated in very strong terms: no theory or structure in which one
can interpret a small amount of arithmetic with addition and multiplication is decidable.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="implementing_first_order_logic.html" class="btn btn-neutral float-left" title="11. Implementing First-Order Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="using_smt_solvers.html" class="btn btn-neutral float-right" title="13. Using SMT solvers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>