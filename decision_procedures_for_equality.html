<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>12. Decision Procedures for Equality &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=0731ccc3" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=2709fde1"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script>window.MathJax = {"loader": {"load": ["[tex]/bussproofs"]}, "tex": {"packages": {"[+]": ["bussproofs"]}, "macros": {"fn": ["\\mathit{#1}", 1], "fa": ["\\forall #1. \\,", 1], "ex": ["\\exists #1. \\,", 1], "bN": "{\\mathbb{N}}", "bZ": "{\\mathbb{Z}}", "bR": "{\\mathbb{R}}", "limplies": "\\to", "liff": "\\leftrightarrow", "proves": "\\vdash", "append": "\\mathbin{+\\mkern-10mu+}", "tval": ["[\\![#1]\\!]", 1], "fCenter": "\\proves", "mdl": ["\\mathfrak{#1}", 1]}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="13. Equality and Induction in Lean" href="equality_and_induction_in_lean.html" />
    <link rel="prev" title="11. Implementing First-Order Logic" href="implementing_first_order_logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Logic and Mechanized Reasoning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_propositional_logic.html">8. Proof Systems for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_proof_assistant.html">9. Using Lean as a Proof Assistant</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">11. Implementing First-Order Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">12. Decision Procedures for Equality</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#equality">12.1. Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementing-congruence-closure">12.2. Implementing congruence closure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#deciding-universal-sentences">12.3. Deciding universal sentences</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="equality_and_induction_in_lean.html">13. Equality and Induction in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_arithmetic.html">14. Decision Procedures for Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">15. Using SMT solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_systems_for_first_order_logic.html">16. Proof Systems for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">17. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="beyond_first_order_logic.html">18. Beyond First-Order Logic</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">12. </span>Decision Procedures for Equality</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/decision_procedures_for_equality.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="decision-procedures-for-equality">
<span id="chapter-decision-procedures-for-equality"></span><h1><span class="section-number">12. </span>Decision Procedures for Equality<a class="headerlink" href="#decision-procedures-for-equality" title="Link to this heading"></a></h1>
<p>In the terminology of logic and computer science, a <em>decision procedure</em> is an
algorithm that accepts a class of yes/no questions and answers them correctly.
Fix a set of first-order sentences, <span class="math notranslate nohighlight">\(\Gamma\)</span>, which we can think of as a set of axioms of as
a description of a possible state of affairs. Here are some questions we can ask:</p>
<ul class="simple">
<li><p>Given  a first-order sentence <span class="math notranslate nohighlight">\(A\)</span>,
does <span class="math notranslate nohighlight">\(\Gamma\)</span> prove <span class="math notranslate nohighlight">\(A\)</span>, that is, <span class="math notranslate nohighlight">\(\Gamma \proves A\)</span>?</p></li>
<li><p>Given  a first-order sentence <span class="math notranslate nohighlight">\(A\)</span>,
does <span class="math notranslate nohighlight">\(\Gamma\)</span> entail <span class="math notranslate nohighlight">\(A\)</span>, that is, <span class="math notranslate nohighlight">\(\Gamma \models A\)</span>?</p></li>
<li><p>Given  a first-order sentence <span class="math notranslate nohighlight">\(A\)</span>,
is <span class="math notranslate nohighlight">\(\Gamma \cup \{ A \}\)</span> is satisfiable, that is, is there a model
<span class="math notranslate nohighlight">\(\mdl M\)</span> of <span class="math notranslate nohighlight">\(\Gamma\)</span> in which <span class="math notranslate nohighlight">\(A\)</span> is true?</p></li>
</ul>
<p>The first two questions are equivalent. We
have not yet presented deductive systems for first-order logic, but we will do so in
<a class="reference internal" href="proof_systems_for_first_order_logic.html#chapter-proof-systems-for-first-order-logic"><span class="std std-numref">Chapter 16</span></a>, and by the soundness and
completeness theorems for those systems, we will have that a sentence <span class="math notranslate nohighlight">\(A\)</span> is provable from
a set of hypotheses <span class="math notranslate nohighlight">\(\Gamma\)</span> if and only if it is entailed by <span class="math notranslate nohighlight">\(\Gamma\)</span>.
The third question is equivalent to the first two by translation: as with propositional logic,
we have that <span class="math notranslate nohighlight">\(\Gamma \models A\)</span> if and only if <span class="math notranslate nohighlight">\(\Gamma \cup \{ \lnot A \}\)</span> is
unsatisfiable. So questions about entailment are equivalent to questions about satisfiability,
negating the formula in question.</p>
<p>Whether or not a problem of the form above is decidable depends on <span class="math notranslate nohighlight">\(\Gamma\)</span>. For example,
if <span class="math notranslate nohighlight">\(\Gamma\)</span> is empty, the first question boils down to the question as to whether a sentence
<span class="math notranslate nohighlight">\(A\)</span> is provable in first-order logic. If the language in question has a binary relation symbol
or two unary function symbols, the question is undecidable. In the special case where the language
has only unary predicate symbols and a single function symbol, the question is decidable.
Neither of these facts are easy to prove.</p>
<p>Interestingly, adding axioms to <span class="math notranslate nohighlight">\(\Gamma\)</span> can make provability decidable. One way to think
of this is that doing so constrains the types of models that have to be considered.
Given a set of axioms <span class="math notranslate nohighlight">\(\Gamma\)</span>, deciding whether or not provability is decidable
of often hard, and, for that reason, generally interesting. To show that the answer is “yes,”
one should describe an algorithm, and then there is the further question as to whether the
algorithm can be made to run efficiently on the specific questions we care about. A “no” answer
usually proceeds to showing that a solution would lead to a solution to the halting problem,
or another problem that has been shown to be reducible to it.</p>
<p>The second type question above asks about the truth of a sentence <span class="math notranslate nohighlight">\(A\)</span> in all models of
<span class="math notranslate nohighlight">\(\Gamma\)</span>, and the third type of question above asks about the truth of a sentence
<span class="math notranslate nohighlight">\(A\)</span> in <em>some</em> model of <span class="math notranslate nohighlight">\(\Gamma\)</span>. There are other types of decision procedures we
might consider. Fixing a model <span class="math notranslate nohighlight">\(\mdl M\)</span>, we can ask:</p>
<ul class="simple">
<li><p>Given a first-order formula <span class="math notranslate nohighlight">\(A\)</span>, possibly with free variables,
is there a variable assignment <span class="math notranslate nohighlight">\(\sigma\)</span> such that <span class="math notranslate nohighlight">\(A\)</span> is true in <span class="math notranslate nohighlight">\(\mdl M\)</span>
under <span class="math notranslate nohighlight">\(\sigma\)</span>, that is, <span class="math notranslate nohighlight">\(\models_{\mdl M, \sigma} A\)</span>?</p></li>
<li><p>Given a first-order formula <span class="math notranslate nohighlight">\(A\)</span>, possibly with free variables,
is <span class="math notranslate nohighlight">\(A\)</span> is true in <span class="math notranslate nohighlight">\(\mdl M\)</span> under every assignment <span class="math notranslate nohighlight">\(\sigma\)</span>?</p></li>
</ul>
<p>In the first case, <span class="math notranslate nohighlight">\(A\)</span> is said to be <em>satisfiable</em> in <span class="math notranslate nohighlight">\(\mdl M\)</span>, and in the second case,
it is said to be <span class="math notranslate nohighlight">\(A\)</span> <em>valid</em> in <span class="math notranslate nohighlight">\(\mdl M\)</span>. But be careful: the words are being used
in a slightly different sense than before, when satisfiable meant “true in some model” rather than
“true for some assignment” and valid meant “true in all models” rather than
“true for all assignments.”</p>
<p>Remember that a sentence is a formula without free variables.
If <span class="math notranslate nohighlight">\(A\)</span> is a sentence, both questions boil down to the question as to
whether <span class="math notranslate nohighlight">\(A\)</span> is true in <span class="math notranslate nohighlight">\(\mdl M\)</span>. Notice that if <span class="math notranslate nohighlight">\(A\)</span> has free variables
<span class="math notranslate nohighlight">\(x_1, x_2, \ldots, x_n\)</span>, then the following are all equivalent:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A\)</span> is satisfiable in <span class="math notranslate nohighlight">\(\mdl M\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\ex {x_1, x_2, \ldots, x_n} A\)</span> is true in <span class="math notranslate nohighlight">\(\mdl M\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x_1, x_2, \ldots, x_n} \lnot A\)</span> is false in <span class="math notranslate nohighlight">\(\mdl M\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot A\)</span> is not valid in <span class="math notranslate nohighlight">\(\mdl M\)</span>.</p></li>
</ul>
<p>It is confusing that there are so many ways to ask the same question! But you have to get used
to it: logicians and computer scientists slip back and forth between the different ways of
thinking about a problem, sometimes even in the same sentence.</p>
<p>The relationship between the first group of questions, having to do with entailment and
satisfiability, and the second group of questions, having to do with truth in models, is
subtle. Sometimes, for a given model <span class="math notranslate nohighlight">\(\mdl M\)</span>, there is a natural set of axioms <span class="math notranslate nohighlight">\(\Gamma\)</span>
such that a sentence is true in <span class="math notranslate nohighlight">\(\mdl M\)</span> if and only if it is provable from <span class="math notranslate nohighlight">\(\Gamma\)</span>.
Sometimes, instead, one can show that there is <em>no</em> computable set of axioms that has this property.
Life is complicated! The set of all true sentences of a model <span class="math notranslate nohighlight">\(\mdl M\)</span>
is called “the theory of <span class="math notranslate nohighlight">\(\mdl M\)</span>, so we can express the last property
by saying that the theory of <span class="math notranslate nohighlight">\(\mdl M\)</span> is not computable.</p>
<p>To muddy the waters even further, instead of asking questions about all first-order formulas,
we can consider restricted problems where we are only allowed to ask about formulas of a certain
kind. A formula is said to be <em>quantifier-free</em> if it has no quantifiers, <em>universal</em> if it consists
of any number of universal quantifiers <span class="math notranslate nohighlight">\(\forall\)</span> (possibly none) followed by a
quantifier-free formula, and <em>existential</em> if it consists of any number of existential quantifiers
followed by a quantifier-free formula. In some cases, So we can ask, for a decision procedure for
the provability of universal formulas from a set of axioms or for the satisfiability of an
existential formula in a model, and in some cases, we may have a positive answer even though
the full problem is undecidable.</p>
<p>In this chapter, we will describe, in detail,
a decision procedure for the validity universal formulas in pure first-order logic, that is,
first-order logic without any axioms.
The central component to this is a decision procedure for equality, and so we start with that.</p>
<section id="equality">
<span id="section-equality"></span><h2><span class="section-number">12.1. </span>Equality<a class="headerlink" href="#equality" title="Link to this heading"></a></h2>
<p>Fix a language, <span class="math notranslate nohighlight">\(L\)</span>. We will consider equations <span class="math notranslate nohighlight">\(s = t\)</span> and <em>disequations</em>
<span class="math notranslate nohighlight">\(u \ne v\)</span> between closed terms.
The fact that we are considering closed terms mean that there are no variables to substitute
for; computer scientists sometimes call these <em>ground</em> terms.
(As with unification, in some contexts we may want to treat some variables as constant.
What is important here is not whether we call them variables or constants, but, rather,
the fact that we are not considering substitutions.)</p>
<p>The problem we are addressing here is this: given a set of equations and disequations, is
it satisfiable? Notice that here we are asking about satisfiability in <em>any</em> model. In particular,
the set</p>
<div class="math notranslate nohighlight">
\[\{ s_1 = t_1, \ldots, s_n = t_n, u_1 \ne v_1, \ldots, u_m \ne v_m \}\]</div>
<p>is <em>unsatisfiable</em> if and only if we have</p>
<div class="math notranslate nohighlight">
\[s_1 = t_1, \ldots, s_n = t_n \proves u_1 = v_1 \lor \cdots \lor u_m = v_m\]</div>
<p>So we can think of the problem in either way.</p>
<p>For example, consider the following set of sentences:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(f(a, a) = b\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(g(c, a) = c\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(g(c, f(a, a)) = f(g(c, a), g(c, a))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(f(c, c) \ne g(c, b)\)</span></p></li>
</ol>
<p>Is it satisfiable?</p>
<p>Before we answer that, let’s make some general observations. A set that only has equations and
no disequations is easily satisfiable, namely, in a model with a single element, where every
expression is equal to every other one. Similarly, a set that only has disequations is easily
satisfiable, unless one of the disequations is of the form <span class="math notranslate nohighlight">\(t \ne t\)</span>.
For that purpose, we can use the term model, where every term is interpreted as itself.
The interesting cases fall in between these two extremes, where the equations and disequations
balance one another.</p>
<p>Coming back to the question, the following considerations show that the answer is “no.”
Each of the following is a consequence of the equations above:</p>
<ol class="arabic simple" start="5">
<li><p><span class="math notranslate nohighlight">\(g(c, f(a, a)) = g(c, b)\)</span> from 1</p></li>
<li><p><span class="math notranslate nohighlight">\(f(g(c, a), g(c, a)) = f(c, c)\)</span> from 2</p></li>
<li><p><span class="math notranslate nohighlight">\(f(c, c) = g(c, b)\)</span> from 3, 5, and 6.</p></li>
</ol>
<p>This contradicts the disequation 4 above. To understand what is going on, it is helpful
to think of <span class="math notranslate nohighlight">\(f\)</span> as addition, <span class="math notranslate nohighlight">\(g\)</span> as multiplication, <span class="math notranslate nohighlight">\(a\)</span> as the number 1,
and <span class="math notranslate nohighlight">\(b\)</span> as the number 2.
But the argument is fully abstract, and shows that the disequation cannot hold in any
model in which all the equations are satisfied.</p>
<p>These considerations encapsulate the main ideas behind the proof of the following theorem:</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>The question as to whether a finite set of ground equations and disequations is satisfiable
is decidable.</p>
</div>
<p>The idea behind the proof is to use a <em>saturation</em> argument: starting from the equations in
question, we derive new equations until no more equations are derivable.
If we manage to contradict one of the disequations, the original set is not satisfiable.
In the case where no contradiction is found, we will argue that the original set is satisfiable.</p>
<p>To make all this precise, we need a set of rules for deriving equations.</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$t = t$}
\end{prooftree}
\quad \quad
\begin{prooftree}
\AXC{$s = t$}
\UIC{$t = s$}
\end{prooftree}
\quad \quad
\begin{prooftree}
\AXC{$r = s$}
\AXC{$s = t$}
\BIC{$r = t$}
\end{prooftree}
\quad\quad
\begin{prooftree}
\AXC{$s_1 = t_1$}
\AXC{$\ldots$}
\AXC{$s_n = t_n$}
\TIC{$f(s_1, \ldots, s_n) = f(t_1, \ldots, t_n)$}
\end{prooftree}
\]</div></div></blockquote>
<p>The first three rules express the reflexivity, symmetry, and transitivity of equality,
respectively.
The last rule is called the <em>congruence</em> rule.
You should convince yourself that using these rules we can derive</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$r = s$}
\UIC{$t[r/x] = t[s/x]$}
\end{prooftree}
\]</div></div></blockquote>
<p>for any terms <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(s\)</span>, and <span class="math notranslate nohighlight">\(t\)</span> and variable <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>Returning to our proof plan, we want to show that if applying these rules successively
does not result in a contradiction, then there is a model in which the original equations
and disequations are all true.
But a problem arises: what if the original set contains an equation <span class="math notranslate nohighlight">\(a = f(a)\)</span>?
Then our algorithm falls into an infinite loop, deriving
<span class="math notranslate nohighlight">\(a = f(a) = f(f(a)) = f(f(f(a))) = \ldots\)</span>.
The solution is to restrict attention to <em>subterms</em> of terms appearing in the original
equations and disequations.
The theorem follows from the following lemma.</p>
<div class="admonition-lemma admonition">
<p class="admonition-title">Lemma</p>
<p>Let <span class="math notranslate nohighlight">\(\Gamma\)</span> consist of a set of equations and disequations.
Let <span class="math notranslate nohighlight">\(S\)</span> be the set of subterms of all the terms occurring in <span class="math notranslate nohighlight">\(\Gamma\)</span>.
Let <span class="math notranslate nohighlight">\(\Gamma'\)</span> be the set of all equations between elements of <span class="math notranslate nohighlight">\(S\)</span>
that can be derived from the equations in <span class="math notranslate nohighlight">\(\Gamma\)</span> using the rules above.
Then <span class="math notranslate nohighlight">\(\Gamma\)</span> is satisfiable if and only if no disequation in <span class="math notranslate nohighlight">\(\Gamma\)</span>
is the negation of an equation in <span class="math notranslate nohighlight">\(\Gamma'\)</span>.</p>
</div>
<p>The algorithm implicit in this lemma is called <em>congruence closure</em>.</p>
<div class="admonition-proof admonition">
<p class="admonition-title">Proof</p>
<p>One direction of the lemma is easy. Since the equational rules preserve truth in any
model, if we can derive a contradiction from the equations and disequations in <span class="math notranslate nohighlight">\(\Gamma\)</span>,
then <span class="math notranslate nohighlight">\(\Gamma\)</span> is unsatisfiable. The other direction is harder.
Since there are only finitely many pairs of terms in <span class="math notranslate nohighlight">\(S\)</span>, the algorithm necessarily
terminates.
We need to show that if it terminates without deriving a contradiction, then there is a model
that satisfies <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<p>Say two elements <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> are <em>equivalent</em>, written <span class="math notranslate nohighlight">\(s \equiv t\)</span>,
if they are proved equal from the
equations in <span class="math notranslate nohighlight">\(\Gamma\)</span>. The rules guarantee that this is an <em>equivalence relation</em>, which is
to say, it is reflexive, symmetric, and transitive. It is also a <em>congruence</em>, which means that
applying a function symbol to equivalent terms results in equivalent terms.</p>
<p>To each element <span class="math notranslate nohighlight">\(t\)</span>, we associate its <em>equivalence class</em> <span class="math notranslate nohighlight">\([t]\)</span>, defined by</p>
<div class="math notranslate nohighlight">
\[[t] = \{ s \in S \mid s \equiv t \}.\]</div>
<p>In words, <span class="math notranslate nohighlight">\([t]\)</span> is the set of terms equivalent to <span class="math notranslate nohighlight">\(t\)</span>.
Assuming the algorithm terminates without a contradiction, define a model <span class="math notranslate nohighlight">\(\mdl M\)</span>
whose universe consists of all the equivalence classes of elements of <span class="math notranslate nohighlight">\(S\)</span>
together with a new element, <span class="math notranslate nohighlight">\(\star\)</span>. For elements <span class="math notranslate nohighlight">\(t_1, \ldots t_n\)</span> in <span class="math notranslate nohighlight">\(S\)</span>,
interpret each <span class="math notranslate nohighlight">\(n\)</span>-ary function symbol <span class="math notranslate nohighlight">\(f\)</span> by the function</p>
<div class="math notranslate nohighlight">
\[\begin{split}f^{\mdl M}([t_1], \ldots, [t_n]) = \begin{cases}
  [f(t_1, \ldots, t_n)] &amp; \text{if $f(t_1, \ldots, t_n)$ is in $S$} \\
  \star &amp; \text{otherwise}
\end{cases}\end{split}\]</div>
<p>In other words, what <span class="math notranslate nohighlight">\(f^{\mdl M}\)</span> does to each equivalence class is determined by what
<span class="math notranslate nohighlight">\(f\)</span> does to each of the elements.
If any of the arguments to <span class="math notranslate nohighlight">\(f^{\mdl M}\)</span> is <span class="math notranslate nohighlight">\(\star\)</span>, then
<span class="math notranslate nohighlight">\(f^{\mdl M}\)</span> returns <span class="math notranslate nohighlight">\(\star\)</span>.
The fact that <span class="math notranslate nohighlight">\(\equiv\)</span> is a congruence ensures that this makes sense.
This is just a truncated version of the term model, in which provably equal terms
are all glued together.</p>
<p>It is not hard to show that for every term <span class="math notranslate nohighlight">\(t\)</span> in <span class="math notranslate nohighlight">\(S\)</span>,
<span class="math notranslate nohighlight">\(\tval{t}_{\mdl M}\)</span> is equal to  <span class="math notranslate nohighlight">\([t]\)</span>.
But this is what we need. For every equation <span class="math notranslate nohighlight">\(s = t\)</span> in <span class="math notranslate nohighlight">\(\Gamma\)</span>, <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> are in the
same equivalence class, so they are equal in the model.
And if <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> are not provably equal, then <span class="math notranslate nohighlight">\([s]\)</span> and <span class="math notranslate nohighlight">\([t]\)</span> are not the same, so
every disequation <span class="math notranslate nohighlight">\(s \ne t\)</span> in <span class="math notranslate nohighlight">\(\Gamma\)</span> is true in <span class="math notranslate nohighlight">\(\mdl M\)</span> as well.</p>
</div>
<p>In the construction of the counter-model, we don’t really need
to introduce a new element <span class="math notranslate nohighlight">\(\star\)</span>.
You can check that everything works if we pick an arbitrary equivalence class
<span class="math notranslate nohighlight">\([t]\)</span> and use that as the default instead.
We simply find it clearer to use <span class="math notranslate nohighlight">\(\star\)</span> as a catch-all for
everything that falls outside the scope of the finite set of terms we started with.</p>
<p>For examples of the algorithm in action, first let us show that the set</p>
<div class="math notranslate nohighlight">
\[f^3(a) = a, \, f^5(a) = a, \, f(a) \ne a\]</div>
<p>is unsatisfiable, where <span class="math notranslate nohighlight">\(f^n(a)\)</span> abbreviates <span class="math notranslate nohighlight">\(n\)</span>-fold application <span class="math notranslate nohighlight">\(f(f(\cdots f(a)))\)</span>.
The set of all subterms is</p>
<div class="math notranslate nohighlight">
\[a, \, f(a), \, f^2(a), \, f^3(a), \, f^4(a), \, f^5(a).\]</div>
<p>We start with the equivalence classes <span class="math notranslate nohighlight">\(\{ a, f^3(a) \}\)</span> and <span class="math notranslate nohighlight">\(\{ a, f^5(a)\}\)</span>
as well as all the others subterms in singleton sets.
From <span class="math notranslate nohighlight">\(a = f^3(a)\)</span> we derive <span class="math notranslate nohighlight">\(f(a) = f^4(a)\)</span> by congruence, giving rise to the set
<span class="math notranslate nohighlight">\(\{ f(a), f^4(a) \}\)</span>. Applying congruence again gives rise to the set <span class="math notranslate nohighlight">\(\{ f^2(a), f^5(a) \}\)</span>,
which is merged with <span class="math notranslate nohighlight">\(\{ a, f^5(a)\}\)</span> to yield <span class="math notranslate nohighlight">\(\{ a, f^2(a), f^5(a) \}\)</span>.
Applying congruence again yields <span class="math notranslate nohighlight">\(\{ f(a), f^3(a) \}\)</span>. (We ignore the term <span class="math notranslate nohighlight">\(f^6(a)\)</span>.)
This is merged with the set <span class="math notranslate nohighlight">\(\{ a, f^3(a) \}\)</span> to yield <span class="math notranslate nohighlight">\(\{ a, f(a), f^3(a)\}\)</span>.
Applying congruence again yields <span class="math notranslate nohighlight">\(\{ f(a), f^2(a), f^4(a)\}\)</span>, which is merged with
<span class="math notranslate nohighlight">\(\{ a, f(a), f^3(a) \}\)</span> and <span class="math notranslate nohighlight">\(\{ f^2(a), f^5(a) \}\)</span> to yield
<span class="math notranslate nohighlight">\(\{ a, f(a), f^2(a), f^3(a), f^5(a) \}\)</span>.
At this point, we have derived <span class="math notranslate nohighlight">\(f(a) = a\)</span>, contradicting the disequality in the original set.
So the set is unsatisfiable.</p>
<p>Suppose we start instead with the set</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[f^2(a) = a, \, f^4(a) = a, \, f(a) \ne a, \, f(a) \ne b\]</div>
</div></blockquote>
<p>You can check that in this case, the algorithm terminates with the following three
equivalence classes:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\([a] = \{ a, f^2(a), f^4(a)\}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\([f(a)] = \{ f(a), f^3(a) \}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\([b] = \{ b \}\)</span>.</p></li>
</ul>
<p>We now construct a model <span class="math notranslate nohighlight">\(\mdl M\)</span> with these elements and an additional element <span class="math notranslate nohighlight">\(\star\)</span>, with</p>
<div class="math notranslate nohighlight">
\[\begin{split}f^{\mdl M}([a]) &amp; = [f(a)] \\
f^{\mdl M}([f(a)]) &amp; = [a] \\
f^{\mdl M}([b]) &amp; = \star \\
f^{\mdl M}(\star) &amp; = \star\end{split}\]</div>
<p>You can check that this satisfies the original set of equations and disequations.</p>
<p>Our analysis establishes an interesting property of
first-order logic: it is possible to prove a disjunction <span class="math notranslate nohighlight">\(u_1 = v_1 \lor \cdots \lor u_m = v_m\)</span>
from a set of equation if and only if it is possible to prove <span class="math notranslate nohighlight">\(u_i = v_i\)</span> for some <span class="math notranslate nohighlight">\(i\)</span>.
This is a property known as <em>convexity</em>. It relies on the fact that we allow only positive
equations on the right-hand side. For example, <span class="math notranslate nohighlight">\(a = b \lor a \ne b\)</span> is provable in
first-order logic, but clearly neither disjunct is provable on its own.</p>
<p>We have described the algorithm as working on closed terms, that is, terms with no variables.
Of course, there is no harm if we allow variables in the terms and simply treat them as
constants. The point is that in this formulation of the problem, a hypothesis <span class="math notranslate nohighlight">\(f(x) = a\)</span>
is interpreted as a statement about one particular <span class="math notranslate nohighlight">\(x\)</span> that never changes in the
statement of a problem. It is an entirely different problem to consider hypotheses
like <span class="math notranslate nohighlight">\(\fa x f(x) = a\)</span> for which we are allowed to substitute any term for <span class="math notranslate nohighlight">\(x\)</span>.
For example, we might want to add axioms like <span class="math notranslate nohighlight">\(\fa {x, y, z} (x + y) + z\)</span> and
<span class="math notranslate nohighlight">\(\fa {x, y}. x + y = y + x\)</span> as axioms for the integers or real numbers. The problem of
determining whether a single equation follows from a set of universally
quantified equations is known as the <em>word problem</em>, and, in general it is undecidable.</p>
</section>
<section id="implementing-congruence-closure">
<h2><span class="section-number">12.2. </span>Implementing congruence closure<a class="headerlink" href="#implementing-congruence-closure" title="Link to this heading"></a></h2>
<p>A high-level overview of the congruence closure algorithm is as follows:</p>
<ul>
<li><p>Given a set of equations and disequations, collect the set of all subterms.</p></li>
<li><p>Start with each subterm in its own equivalence class.</p></li>
<li><p>For each equation in the original problem:</p>
<blockquote>
<div><ul class="simple">
<li><p>Merge the equivalence classes specified by the equation.</p></li>
<li><p>Keep merging classes according to the congruence rule, until it can no longer be applied.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>The resulting equivalence classes characterize all the equations that are implied by the
set of the equations in the original problem.
If they contradict one of the disequations, the original set is unsatisfiable, and
otherwise it is satisfiable.
Of course, one can stop the procedure early if a contradiction is found.</p>
<p>For example, given the set <span class="math notranslate nohighlight">\(\{ f(a,b) = a, f(f(a,b),b) \neq a \}\)</span>, the set of all subterms is <span class="math notranslate nohighlight">\(\{a,b,f(a,b),f(f(a,b),b)\}\)</span>. The algorithm proceeds as follows:</p>
<ul class="simple">
<li><p>Initially, the equivalence classes are <span class="math notranslate nohighlight">\(\{a\}, \{b\}, \{f(a,b)\}, \{f(f(a,b),b)\}`\)</span>.</p></li>
<li><p>Processing the equation <span class="math notranslate nohighlight">\(f(a,b) = a\)</span>, we merge the equivalence classes of <span class="math notranslate nohighlight">\(\{f(a, b)\}\)</span> and
<span class="math notranslate nohighlight">\(\{a\}\)</span> to get <span class="math notranslate nohighlight">\(\{a, f(a,b)\}, \{b\}, \{f(f(a,b),b)\}\)</span>.</p></li>
<li><p>Considering the terms <span class="math notranslate nohighlight">\(f(a, b)\)</span> and <span class="math notranslate nohighlight">\(f(f(a,b), b)\)</span>, we see that the first
immediate subterms of each, <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(f(a, b)\)</span>, and the second immediate subterms,
both <span class="math notranslate nohighlight">\(b\)</span>, are pairwise in the same equivalence classes.
This means we can merge the equivalence classes containing
<span class="math notranslate nohighlight">\(f(a, b)\)</span> and <span class="math notranslate nohighlight">\(f(f(a,b), b)\)</span> to get <span class="math notranslate nohighlight">\(\{a, f(a,b), f(f(a,b),b)\}, \{b\}\)</span>.</p></li>
<li><p>This contradicts <span class="math notranslate nohighlight">\(f(f(a,b), b) \neq a\)</span>, so the original set is unsatisfiable.</p></li>
</ul>
<p>Congruence closure can be implemented efficiently (and <em>is</em> implemented efficiently in SMT
solvers) using a <em>union-find</em> data structure, a generic means of
partitioning a set of nodes into equivalence classes. Each node has a
pointer to its parent, which is another element in the equivalence class.
Each class has a distinguished element, called the <em>representative</em>, with
the property that it is the parent of itself.
To initialize the algorithm with a set of elements, each in its own class,
we create a new node for each element and set its parent to itself.
The union-find structure supports two operations:</p>
<ul>
<li><p>The <em>find</em> operation returns the representative of the class of a given element
by following the parent pointers. In pseudocode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">parent</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
</pre></div>
</div>
<p>We can then determine whether two elements <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are equivalent by
checking whether <code class="docutils literal notranslate"><span class="pre">find(x)</span></code> and <code class="docutils literal notranslate"><span class="pre">find(y)</span></code> are the same.</p>
</li>
<li><p>The <em>merge</em> operation takes two nodes, <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> and ensures that
they are in the same class, by finding the representatives of each class,
and, if they are not the same, making one point to the other:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="n">xr</span> <span class="o">:=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">yr</span> <span class="o">:=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">xr</span> <span class="o">!=</span> <span class="n">yr</span><span class="p">:</span>
    <span class="n">yr</span><span class="o">.</span><span class="n">parent</span> <span class="o">:=</span> <span class="n">xr</span>
</pre></div>
</div>
</li>
</ul>
<p>In an efficient implementation, there are two important optimizations.
First, the find operation can be modified to update the parent pointers of all nodes on
the path to the representative, so that future finds are faster.
Second, the merge operation can be modified to make the smaller class a child of the larger class,
which ensures that the depth of the tree is logarithmic in the number of elements.</p>
<p>Using the union-find data structure, we can straightforwardly implement the congruence closure
algorithm outlined at the beginning of this section.
Because the set that is being partitioned into equivalence classes consists of the subterms
of the terms in the original problem, there are <em>two</em> structures that are relevant:</p>
<ul class="simple">
<li><p>We need to keep track of the term structure, for example, the fact that <span class="math notranslate nohighlight">\(f(a, b)\)</span> is
a subterm of <span class="math notranslate nohighlight">\(f(f(a, b), b)\)</span>.</p></li>
<li><p>We need to keep track of the equivalence classes at each stage of the algorithm.</p></li>
</ul>
<p>Every time a merge identifies the classes represented by <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> respectively, we should
consider each subterm <code class="docutils literal notranslate"><span class="pre">u</span></code> that has an immediate subterm equivalent to <code class="docutils literal notranslate"><span class="pre">s</span></code> and each
subterm <code class="docutils literal notranslate"><span class="pre">v</span></code> that has an immediate subterm equivalent to <code class="docutils literal notranslate"><span class="pre">t</span></code>, and ask whether <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code>
should be identified by the congruence rule; in other words, whether <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> have the
same function symbol and the arguments have, pairwise, been identified as equivalent.
In the example above, when we merge the equivalence classes of <span class="math notranslate nohighlight">\(f(a, b)\)</span> and <span class="math notranslate nohighlight">\(a\)</span>,
we need to check whether <span class="math notranslate nohighlight">\(f(f(a, b), b)\)</span> should be identified with <span class="math notranslate nohighlight">\(f(a, b)\)</span>, because
the first has <span class="math notranslate nohighlight">\(f(a, b)\)</span> as an immediate subterm and the second has
<span class="math notranslate nohighlight">\(a\)</span> as an immediate subterm.
One option is to iterate through <em>all</em> pairs of subterms in the original problem, but this
is inefficient.
Instead, we can maintain, for each class representative <code class="docutils literal notranslate"><span class="pre">s</span></code>, a list of all subterms that have
an immediate subterm in the same class as <code class="docutils literal notranslate"><span class="pre">s</span></code>. These are called the <em>predecessors</em> of <code class="docutils literal notranslate"><span class="pre">s</span></code>.
Whenever we merge classes with representatives <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>, we check each pair
consisting of a predecessor of <code class="docutils literal notranslate"><span class="pre">s</span></code> and a predecessor of <code class="docutils literal notranslate"><span class="pre">t</span></code> to see if they should be
merged, according to the congruence closure rule, and the predecessors of the
representative of the new class should be set to the union of the previous predecessors of
<code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<p>In the course repository for this textbook, there is an implementation of the union-find
data structure in <code class="docutils literal notranslate"><span class="pre">LAMR/Util/DisjointSet.lean</span></code>, and there is an implementation of the
congruence closure algorithm in the file <code class="docutils literal notranslate"><span class="pre">CongruenceClosure.lean</span></code> associated with
this chapter. The latter closely follows the implementation in Harrison’s book,
<em>Handbook of Practical Logic and Automated Reasoning</em>. Zohar and Manna’s book, <em>The Calculus of
Computation</em>, is another good reference.</p>
</section>
<section id="deciding-universal-sentences">
<span id="id1"></span><h2><span class="section-number">12.3. </span>Deciding universal sentences<a class="headerlink" href="#deciding-universal-sentences" title="Link to this heading"></a></h2>
<p>Remember that the following problems are all intertranslatable:</p>
<ul class="simple">
<li><p>Given a universal sentence <span class="math notranslate nohighlight">\(A\)</span>, is <span class="math notranslate nohighlight">\(A\)</span> valid, that is, true in every model? (Equivalently:
if <span class="math notranslate nohighlight">\(A\)</span> provable?)</p></li>
<li><p>Given a quantifier-free formula <span class="math notranslate nohighlight">\(A\)</span>, does <span class="math notranslate nohighlight">\(\models_{\mdl{M}, \sigma} A\)</span> hold for every
model <span class="math notranslate nohighlight">\(\mdl M\)</span> and every variable assignment <span class="math notranslate nohighlight">\(\sigma\)</span>?</p></li>
<li><p>Given a quantifier-free formula <span class="math notranslate nohighlight">\(A\)</span>, does <span class="math notranslate nohighlight">\(\models_{\mdl{M}, \sigma} A\)</span> hold for <em>some</em>
model <span class="math notranslate nohighlight">\(\mdl M\)</span> and variable assignment <span class="math notranslate nohighlight">\(\sigma\)</span>?</p></li>
<li><p>Given an existential sentence <span class="math notranslate nohighlight">\(A\)</span>, is <span class="math notranslate nohighlight">\(A\)</span> satisfiable, that is, true in some model?</p></li>
</ul>
<p>In particular, a universal formula <span class="math notranslate nohighlight">\(\fa {\vec x} A\)</span> is valid if and only if <span class="math notranslate nohighlight">\(A\)</span> holds
for every model and every variable assignment, which happens if and only if <span class="math notranslate nohighlight">\(\lnot A\)</span> never holds for any model and variable assignment, which happens if and only if <span class="math notranslate nohighlight">\(\ex {\vec x} \lnot A\)</span> is
not satisfiable. Notice that in each case we are asking questions about <em>pure</em> first-order logic,
without any axioms <span class="math notranslate nohighlight">\(\Gamma\)</span>.</p>
<p>Remember that in first-order logic, the atomic formulas include equations <span class="math notranslate nohighlight">\(s = t\)</span> and formulas
<span class="math notranslate nohighlight">\(R(t_1, \ldots, t_n)\)</span>, where <span class="math notranslate nohighlight">\(R\)</span> is a relation symbol. The set of <em>literals</em> include the
negations of those as well. It is not hard to extend congruence closure to an algorithm to determine
the satisfiability of any finite set of literals. To start with, we add the following rule to our
equational proof system:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[
\begin{prooftree}
\AXC{$s_1 = t_1$}
\AXC{$\ldots$}
\AXC{$s_n = t_n$}
\AXC{$R(s_1, \ldots, s_n)$}
\QuaternaryInfC{$R(t_1, \ldots, t_n)$}
\end{prooftree}
\]</div></div></blockquote>
<p>Suppose <span class="math notranslate nohighlight">\(\Gamma\)</span> is a set of literals.
To test the satisfiability of <span class="math notranslate nohighlight">\(\Gamma\)</span>, we do not have to change much in the previous algorithm.
Using the congruence rule for relations, whenever we have derived <span class="math notranslate nohighlight">\(R(s_1, \ldots, s_n)\)</span>
and we have also derived equations <span class="math notranslate nohighlight">\(s_i = t_i\)</span> for every <span class="math notranslate nohighlight">\(i\)</span>,
we can conclude <span class="math notranslate nohighlight">\(R(t_1, \ldots, t_n)\)</span>.
The algorithm terminates when we contradict a disequality or another negated atomic formula.
If the algorithm terminates without a contradiction, we build a model as before,
where we simply declare that <span class="math notranslate nohighlight">\(R^{\mdl M}([t_1], \ldots, [t_n])\)</span> holds if and only if
we have determined that <span class="math notranslate nohighlight">\(R(t_1, \ldots, t_n)\)</span> in a consequence of the original set.
Another way to think about the algorithm is that we can replace each atomic formula
<span class="math notranslate nohighlight">\(R(t_1, \ldots, t_n)\)</span>
by an equation <span class="math notranslate nohighlight">\(f_R(t_1, \ldots, t_n) = \top\)</span> and each negated atomic formula
<span class="math notranslate nohighlight">\(\lnot R(t_1, \ldots, t_n)\)</span> by a disequation <span class="math notranslate nohighlight">\(f_R(t_1, \ldots, t_n) \ne \top\)</span> and
run the usual congruence closure algorithm on that.</p>
<p>Now suppose we are given an existential sentence <span class="math notranslate nohighlight">\(\ex {x_1, \ldots, x_n} A\)</span>
where <span class="math notranslate nohighlight">\(A\)</span> is quantifier-free, and suppose we want to determine whether it is satisfiable.
Write <span class="math notranslate nohighlight">\(A\)</span> in disjunctive normal form, that is, as a disjunction
<span class="math notranslate nohighlight">\(A_1 \lor \cdots \lor A_n\)</span> of conjunctions of literals.
Then <span class="math notranslate nohighlight">\(\ex {x_1, \ldots, x_n} A\)</span> is satisfiable if and only if one of the formulas
<span class="math notranslate nohighlight">\(A_1, \ldots, A_n\)</span> is satisfied by some model <span class="math notranslate nohighlight">\(\mdl M\)</span> and variable assignment
<span class="math notranslate nohighlight">\(\sigma\)</span>. That reduces the task to determining whether a conjunction of literals is satisfiable,
and we have just explained how to do that.</p>
<p>Since a sentence is valid if and only if its negation is satisfiable, and since the negation
of a universal sentence is an existential sentence, we have shown the following.</p>
<div class="admonition-theorem admonition">
<p class="admonition-title">Theorem</p>
<p>The validity of universal sentences in pure first-order logic is decidable.
Equivalently, the satisfiability of existential sentences is decidable.</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="implementing_first_order_logic.html" class="btn btn-neutral float-left" title="11. Implementing First-Order Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="equality_and_induction_in_lean.html" class="btn btn-neutral float-right" title="13. Equality and Induction in Lean" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>