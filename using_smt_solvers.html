

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>13. Using SMT solvers &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>window.MathJax = {"loader": {"load": ["[tex]/bussproofs"]}, "tex": {"packages": {"[+]": ["bussproofs"]}, "macros": {"fn": ["\\mathit{#1}", 1], "fa": ["\\forall #1. \\,", 1], "ex": ["\\exists #1. \\,", 1], "bN": "{\\mathbb{N}}", "bZ": "{\\mathbb{Z}}", "bR": "{\\mathbb{R}}", "limplies": "\\to", "liff": "\\leftrightarrow", "proves": "\\vdash", "append": "\\mathbin{+\\mkern-10mu+}", "tval": ["[\\![#1]\\!]", 1], "fCenter": "\\proves", "mdl": ["\\mathfrak{#1}", 1]}}}</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="14. Deduction for First-Order Logic" href="deduction_for_first_order_logic.html" />
    <link rel="prev" title="12. Decision Procedures for First-Order Logic" href="decision_procedures_for_first_order_logic.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Logic and Mechanized Reasoning
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="deduction_for_propositional_logic.html">8. Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">9. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">11. Implementing First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_first_order_logic.html">12. Decision Procedures for First-Order Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">13. Using SMT solvers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#smt-lib-format">13.1. SMT-LIB Format</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-magic-squares">13.2. Example: Magic squares</a></li>
<li class="toctree-l2"><a class="reference internal" href="#calling-smt-solvers-from-lean">13.3. Calling SMT solvers from Lean</a></li>
<li class="toctree-l2"><a class="reference internal" href="#application-verification">13.4. Application: Verification</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercise-almost-squares">13.5. Exercise: Almost squares</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="deduction_for_first_order_logic.html">14. Deduction for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">15. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">16. First-Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="simple_type_theory.html">17. Simple Type Theory</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">13. </span>Using SMT solvers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/using_smt_solvers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="using-smt-solvers">
<span id="chapter-using-smt-solvers"></span><h1><span class="section-number">13. </span>Using SMT solvers<a class="headerlink" href="#using-smt-solvers" title="Permalink to this headline">¶</a></h1>
<p>Satisfiability Modulo Theories (SMT) solvers determine whether a quantifier-free first-order formula can be satisfied with respect to some background theories. In many application areas, problem instances can be transformed into SMT formulas and the SMT solver determines whether there exists a satisfying assignment. The effectiveness of an SMT solver depends on the selection of background theories for a given problem instance. Several strong SMT solvers have been developed, including Z3, CVC4, and Boolector. SMT solvers are frequently used in industry and academia.</p>
<div class="section" id="smt-lib-format">
<h2><span class="section-number">13.1. </span>SMT-LIB Format<a class="headerlink" href="#smt-lib-format" title="Permalink to this headline">¶</a></h2>
<p>The input format for SMT solvers is called SMT-LIB. SMT-LIB is much more readable than the DIMACS format for SAT solvers. For example, in SMT-LIB, variable names are strings, while DIMACS uses numbers. Also, whereas SAT solvers require the input to be in conjunctive normal form, this is not the case in SMT-LIB.</p>
<p>Most SMT-LIB input files consist of five blocks:</p>
<ul class="simple">
<li><p>Selecting the theory. Examples of theories are QF_UF (uninterpreted functions) and QF_LIA (linear integer arithmetic).</p></li>
<li><p>Declaring variables, functions, and types (called sorts). To declare a variable, one uses a line of the form <code class="docutils literal notranslate"><span class="pre">(declare-const</span> <span class="pre">name</span> <span class="pre">type)</span></code>, where <code class="docutils literal notranslate"><span class="pre">name</span></code> is the variable name and <code class="docutils literal notranslate"><span class="pre">type</span></code> is the variable type. Functions can be declared/defined using <code class="docutils literal notranslate"><span class="pre">(declare-fun</span> <span class="pre">name</span> <span class="pre">(inputTypes)</span> <span class="pre">outputType)</span></code> for uninterpreted functions and using <code class="docutils literal notranslate"><span class="pre">(define-fun</span> <span class="pre">name</span> <span class="pre">(inputTypes)</span> <span class="pre">outputType</span> <span class="pre">(body))</span></code>, otherwise. In both cases <code class="docutils literal notranslate"><span class="pre">name</span></code> is the function name, <code class="docutils literal notranslate"><span class="pre">(inputTypes)</span></code> the input types,  and <code class="docutils literal notranslate"><span class="pre">outputType</span></code> the output type. The <code class="docutils literal notranslate"><span class="pre">(body)</span></code> part defines the function.  In a similar way, one can define types, but we won’t use this functionality in this chapter. Several predefined types are supported depending on the selected theory. For example QF_UF supports Bool (propositional variables), while QF_LIA supports Int (integers).</p></li>
<li><p>A list of constraints. Constraints in SMT-LIB are of the form <code class="docutils literal notranslate"><span class="pre">(assert</span> <span class="pre">...)</span></code> with <code class="docutils literal notranslate"><span class="pre">...</span></code> describing the constraint.</p></li>
<li><p>The command <code class="docutils literal notranslate"><span class="pre">(check-sat)</span></code> solves the formula encoded above it. Depending on the result, one can then use <code class="docutils literal notranslate"><span class="pre">(get-model)</span></code> to obtain a model when the formula is satisfiable or <code class="docutils literal notranslate"><span class="pre">(get-unsat-core)</span></code> to extract an unsatisfiable core (a subset of the constraints that is also unsatisfiable) when the formula is unsatisfiable.</p></li>
<li><p>Finally, the command <code class="docutils literal notranslate"><span class="pre">(exit)</span></code> terminates the solver.</p></li>
</ul>
<p>The example formula shown below uses the theory QF_UF and asks whether the formula <span class="math notranslate nohighlight">\(p \land \lnot p\)</span> can be satisfied. For each blocked described above, only a single line appears in the formula.</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">set-logic</span> <span class="nv">QF_UF</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">p</span> <span class="nv">Bool</span><span class="p">)</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">p</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">p</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">check-sat</span><span class="p">)</span>
<span class="p">(</span><span class="nv">exit</span><span class="p">)</span>
</pre></div>
</div>
<p>Another small example is shown below. It uses the theory QF_LIA and asks whether there exists an integer <code class="docutils literal notranslate"><span class="pre">x</span></code> that is larger than an integer <code class="docutils literal notranslate"><span class="pre">y</span></code> without further constraining these variables. This formula is satisfiable, so we can ask the SMT solver to provide us an example <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> which makes the formula true using <code class="docutils literal notranslate"><span class="pre">(get-model)</span></code>. For example, the solver can return that <code class="docutils literal notranslate"><span class="pre">x</span></code> is 5 and <code class="docutils literal notranslate"><span class="pre">y</span></code> is 2.</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">set-logic</span> <span class="nv">QF_LIA</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">x</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">y</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nv">check-sat</span><span class="p">)</span>
<span class="p">(</span><span class="nv">get-model</span><span class="p">)</span>
<span class="p">(</span><span class="nv">exit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="example-magic-squares">
<h2><span class="section-number">13.2. </span>Example: Magic squares<a class="headerlink" href="#example-magic-squares" title="Permalink to this headline">¶</a></h2>
<p>A magic square of order <span class="math notranslate nohighlight">\(n\)</span> is a <span class="math notranslate nohighlight">\(n \times n\)</span> grid with the numbers 1 to <span class="math notranslate nohighlight">\(n^2\)</span> occurring exactly once such that the sum for each row, column, and the two main diagonals is the same. Two magic squares are shown below, one of order 3 and one of order 8.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>4</p></td>
<td><p>9</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>5</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>1</p></td>
<td><p>6</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>61</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>64</p></td>
<td><p>57</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>60</p></td>
</tr>
<tr class="row-even"><td><p>12</p></td>
<td><p>54</p></td>
<td><p>55</p></td>
<td><p>9</p></td>
<td><p>16</p></td>
<td><p>50</p></td>
<td><p>51</p></td>
<td><p>13</p></td>
</tr>
<tr class="row-odd"><td><p>20</p></td>
<td><p>46</p></td>
<td><p>47</p></td>
<td><p>17</p></td>
<td><p>24</p></td>
<td><p>42</p></td>
<td><p>43</p></td>
<td><p>21</p></td>
</tr>
<tr class="row-even"><td><p>37</p></td>
<td><p>27</p></td>
<td><p>26</p></td>
<td><p>40</p></td>
<td><p>33</p></td>
<td><p>31</p></td>
<td><p>30</p></td>
<td><p>36</p></td>
</tr>
<tr class="row-odd"><td><p>29</p></td>
<td><p>35</p></td>
<td><p>34</p></td>
<td><p>32</p></td>
<td><p>25</p></td>
<td><p>39</p></td>
<td><p>38</p></td>
<td><p>28</p></td>
</tr>
<tr class="row-even"><td><p>44</p></td>
<td><p>22</p></td>
<td><p>23</p></td>
<td><p>41</p></td>
<td><p>48</p></td>
<td><p>18</p></td>
<td><p>19</p></td>
<td><p>45</p></td>
</tr>
<tr class="row-odd"><td><p>52</p></td>
<td><p>14</p></td>
<td><p>15</p></td>
<td><p>49</p></td>
<td><p>56</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
<td><p>53</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>59</p></td>
<td><p>58</p></td>
<td><p>8</p></td>
<td><p>1</p></td>
<td><p>63</p></td>
<td><p>62</p></td>
<td><p>4</p></td>
</tr>
</tbody>
</table>
<p>It is relatively straightforward to encode the existence of a magic square as an SMT formula.
After stating the theory, the encoding consists of four parts: 1) declaring a variable for each cell in the grid; 2) enforcing that each cell has a value from 1 to <span class="math notranslate nohighlight">\(n^2\)</span>; 3) enforcing that all each cell has a unique value; and 4) enforcing that the sum of each row, column, and main diagonals is equal to <span class="math notranslate nohighlight">\((n^3 + n)/2\)</span>.</p>
<p>The formula shown below uses the quantifier-free theory of linear integer arithmetic (QF_LIA). The variable for the cell in row <code class="docutils literal notranslate"><span class="pre">i</span></code> and column <code class="docutils literal notranslate"><span class="pre">j</span></code> is called <code class="docutils literal notranslate"><span class="pre">m_i_j</span></code>. The variable is declared using <code class="docutils literal notranslate"><span class="pre">(declare-const</span> <span class="pre">m_i_j</span> <span class="pre">Int)</span></code>, while the lines
with <code class="docutils literal notranslate"><span class="pre">assert</span></code> constrain the variables.</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">set-logic</span> <span class="nv">QF_LIA</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_0_0</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_0_1</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_0_2</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_1_0</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_1_1</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_1_2</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_2_0</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_2_1</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_2_2</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">m_0_0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">m_0_0</span> <span class="mi">9</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">m_0_1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">m_0_1</span> <span class="mi">9</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">m_0_2</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">m_0_2</span> <span class="mi">9</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">m_1_0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">m_1_0</span> <span class="mi">9</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">m_1_1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">m_1_1</span> <span class="mi">9</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">m_1_2</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">m_1_2</span> <span class="mi">9</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">m_2_0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">m_2_0</span> <span class="mi">9</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">m_2_1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">m_2_1</span> <span class="mi">9</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">m_2_2</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">m_2_2</span> <span class="mi">9</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nv">distinct</span> <span class="nv">m_0_0</span> <span class="nv">m_0_1</span> <span class="nv">m_0_2</span> <span class="nv">m_1_0</span> <span class="nv">m_1_1</span> <span class="nv">m_1_2</span> <span class="nv">m_2_0</span> <span class="nv">m_2_1</span> <span class="nv">m_2_2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">15</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">m_0_0</span> <span class="nv">m_0_1</span> <span class="nv">m_0_2</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">15</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">m_1_0</span> <span class="nv">m_1_1</span> <span class="nv">m_1_2</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">15</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">m_2_0</span> <span class="nv">m_2_1</span> <span class="nv">m_2_2</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">15</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">m_0_0</span> <span class="nv">m_1_0</span> <span class="nv">m_2_0</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">15</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">m_0_1</span> <span class="nv">m_1_1</span> <span class="nv">m_2_1</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">15</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">m_0_2</span> <span class="nv">m_1_2</span> <span class="nv">m_2_2</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">15</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">m_0_2</span> <span class="nv">m_1_1</span> <span class="nv">m_2_0</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">15</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">m_2_0</span> <span class="nv">m_1_1</span> <span class="nv">m_0_2</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">check-sat</span><span class="p">)</span>
<span class="p">(</span><span class="nv">get-model</span><span class="p">)</span>
<span class="p">(</span><span class="nv">exit</span><span class="p">)</span>
</pre></div>
</div>
<p>The encoding in the quantifier-free theory of bitvectors (QF_BV) is very similar and shown below. When using bitvectors, one needs to declare the number of bits. In this example, we use 16 bits, which is large enough to compute magic squares of reasonable size. Note that QF_BV uses the bitvector variants of +, -, &gt;, &gt;=, &lt;, and &lt;=, which are <code class="docutils literal notranslate"><span class="pre">bvadd</span></code>, <code class="docutils literal notranslate"><span class="pre">bvsub</span></code>, <code class="docutils literal notranslate"><span class="pre">bvugt</span></code>, <code class="docutils literal notranslate"><span class="pre">bvuge</span></code>, <code class="docutils literal notranslate"><span class="pre">bvult</span></code>, and <code class="docutils literal notranslate"><span class="pre">bvule</span></code>, respectively. Also, constants are expressed differently in QF_BV: they are written as <code class="docutils literal notranslate"><span class="pre">#x</span></code> followed by the bitvector in hexadecimal notation.</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">set-logic</span> <span class="nv">QF_BV</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_0_0</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_0_1</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_0_2</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_1_0</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_1_1</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_1_2</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_2_0</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_2_1</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">m_2_2</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">bvugt</span> <span class="nv">m_0_0</span> <span class="mh">#x0000</span><span class="p">)</span> <span class="p">(</span><span class="nv">bvule</span> <span class="nv">m_0_0</span> <span class="mh">#x0009</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">bvugt</span> <span class="nv">m_0_1</span> <span class="mh">#x0000</span><span class="p">)</span> <span class="p">(</span><span class="nv">bvule</span> <span class="nv">m_0_1</span> <span class="mh">#x0009</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">bvugt</span> <span class="nv">m_0_2</span> <span class="mh">#x0000</span><span class="p">)</span> <span class="p">(</span><span class="nv">bvule</span> <span class="nv">m_0_2</span> <span class="mh">#x0009</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">bvugt</span> <span class="nv">m_1_0</span> <span class="mh">#x0000</span><span class="p">)</span> <span class="p">(</span><span class="nv">bvule</span> <span class="nv">m_1_0</span> <span class="mh">#x0009</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">bvugt</span> <span class="nv">m_1_1</span> <span class="mh">#x0000</span><span class="p">)</span> <span class="p">(</span><span class="nv">bvule</span> <span class="nv">m_1_1</span> <span class="mh">#x0009</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">bvugt</span> <span class="nv">m_1_2</span> <span class="mh">#x0000</span><span class="p">)</span> <span class="p">(</span><span class="nv">bvule</span> <span class="nv">m_1_2</span> <span class="mh">#x0009</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">bvugt</span> <span class="nv">m_2_0</span> <span class="mh">#x0000</span><span class="p">)</span> <span class="p">(</span><span class="nv">bvule</span> <span class="nv">m_2_0</span> <span class="mh">#x0009</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">bvugt</span> <span class="nv">m_2_1</span> <span class="mh">#x0000</span><span class="p">)</span> <span class="p">(</span><span class="nv">bvule</span> <span class="nv">m_2_1</span> <span class="mh">#x0009</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">bvugt</span> <span class="nv">m_2_2</span> <span class="mh">#x0000</span><span class="p">)</span> <span class="p">(</span><span class="nv">bvule</span> <span class="nv">m_2_2</span> <span class="mh">#x0009</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nv">distinct</span> <span class="nv">m_0_0</span> <span class="nv">m_0_1</span> <span class="nv">m_0_2</span> <span class="nv">m_1_0</span> <span class="nv">m_1_1</span> <span class="nv">m_1_2</span> <span class="nv">m_2_0</span> <span class="nv">m_2_1</span> <span class="nv">m_2_2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mh">#x000f</span> <span class="p">(</span><span class="nv">bvadd</span> <span class="nv">m_0_0</span> <span class="nv">m_0_1</span> <span class="nv">m_0_2</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mh">#x000f</span> <span class="p">(</span><span class="nv">bvadd</span> <span class="nv">m_1_0</span> <span class="nv">m_1_1</span> <span class="nv">m_1_2</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mh">#x000f</span> <span class="p">(</span><span class="nv">bvadd</span> <span class="nv">m_2_0</span> <span class="nv">m_2_1</span> <span class="nv">m_2_2</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mh">#x000f</span> <span class="p">(</span><span class="nv">bvadd</span> <span class="nv">m_0_0</span> <span class="nv">m_1_0</span> <span class="nv">m_2_0</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mh">#x000f</span> <span class="p">(</span><span class="nv">bvadd</span> <span class="nv">m_0_1</span> <span class="nv">m_1_1</span> <span class="nv">m_2_1</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mh">#x000f</span> <span class="p">(</span><span class="nv">bvadd</span> <span class="nv">m_0_2</span> <span class="nv">m_1_2</span> <span class="nv">m_2_2</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mh">#x000f</span> <span class="p">(</span><span class="nv">bvadd</span> <span class="nv">m_0_2</span> <span class="nv">m_1_1</span> <span class="nv">m_2_0</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="mh">#x000f</span> <span class="p">(</span><span class="nv">bvadd</span> <span class="nv">m_2_0</span> <span class="nv">m_1_1</span> <span class="nv">m_0_2</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">check-sat</span><span class="p">)</span>
<span class="p">(</span><span class="nv">get-model</span><span class="p">)</span>
<span class="p">(</span><span class="nv">exit</span><span class="p">)</span>
</pre></div>
</div>
<p>Although the encodings of magic squares in QF_LIA and QF_BV look very similar, the performance of SMT solvers on these encodings differs a lot. For example, computing a magic square of order 5 is difficult for SMT solvers using the QF_LIA encoding, while it is easy when using the QF_BV encoding. In fact, it is even easy to solve the QF_BV encoding expressing the existence of a magic square of order 10. The main difference between these two theories is that the solver applies linear arithmetic when using QF_LIA, while it applies what is known as <em>bit blasting</em> when using QF_BV. Bit blasting transforms the formula into propositional logic by introducing a propositional variable for each bit in the problem. For some problems, such as magic squares, bit blasting can be very effective. For other problems, bit blasting can result in formulas that are hard to solve.</p>
</div>
<div class="section" id="calling-smt-solvers-from-lean">
<h2><span class="section-number">13.3. </span>Calling SMT solvers from Lean<a class="headerlink" href="#calling-smt-solvers-from-lean" title="Permalink to this headline">¶</a></h2>
<p>To use an SMT solver, you can simply create an SMT-LIB file and run the solver on it.
We also provide a convenient interface for calling any of the three popular solvers
Z3, CVC4, and CVC5 from Lean. There is an example in the file <code class="docutils literal notranslate"><span class="pre">magicSquares.lean</span></code>
in <code class="docutils literal notranslate"><span class="pre">Examples/using_smt_solvers</span></code>.</p>
<p>To start with, we provide syntax with brackets <code class="docutils literal notranslate"><span class="pre">sexp!{</span></code> and <code class="docutils literal notranslate"><span class="pre">}</span></code> for writing s-expressions,
and you can use the notation <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">t</span> <span class="pre">}</span></code> inside an s-expression
to fill in the value of a Lean expression <code class="docutils literal notranslate"><span class="pre">t</span></code>.
For example the following declares constants <code class="docutils literal notranslate"><span class="pre">m_{i}_{j}</span></code> as <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> range over
values less than <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span>  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[:</span><span class="n">n</span><span class="o">]</span> <span class="k">do</span>
    <span class="n">for</span> <span class="n">j</span> <span class="k">in</span> <span class="o">[:</span><span class="n">n</span><span class="o">]</span> <span class="k">do</span>
      <span class="n">consts</span> <span class="o">:=</span> <span class="n">consts.push</span> <span class="n">sexp</span><span class="bp">!</span><span class="o">{(</span><span class="n">declare</span><span class="bp">-</span><span class="n">const</span> <span class="o">{</span><span class="n">s</span><span class="bp">!</span><span class="s2">&quot;m_{i}_{j}&quot;</span><span class="o">}</span> <span class="o">(</span><span class="n">_</span> <span class="n">BitVec</span> <span class="mi">32</span><span class="o">))}</span>
</pre></div>
</div>
<p>The following declares that each cell is nonzero:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span>  <span class="n">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">[:</span><span class="n">n</span><span class="o">]</span> <span class="k">do</span>
    <span class="n">for</span> <span class="n">j</span> <span class="k">in</span> <span class="o">[:</span><span class="n">n</span><span class="o">]</span> <span class="k">do</span>
      <span class="n">asserts</span> <span class="o">:=</span> <span class="n">asserts.push</span> <span class="n">sexp</span><span class="bp">!</span><span class="o">{(</span><span class="n">bvugt</span> <span class="o">{</span><span class="n">s</span><span class="bp">!</span><span class="s2">&quot;m_{i}_{j}&quot;</span><span class="o">}</span> <span class="o">{</span><span class="n">toBVConst</span> <span class="mi">32</span> <span class="mi">0</span><span class="o">})}</span>
</pre></div>
</div>
<p>You can use the syntax <code class="docutils literal notranslate"><span class="pre">...{</span> <span class="pre">}</span></code> to splice a list of s-expressions into an s-expression.
For example. <code class="docutils literal notranslate"><span class="pre">(foo</span> <span class="pre">...{List.range</span> <span class="pre">3</span> <span class="pre">|&gt;.map</span> <span class="pre">(toString</span> <span class="pre">·)})</span></code> becomes <code class="docutils literal notranslate"><span class="pre">(foo</span> <span class="pre">0</span> <span class="pre">1</span> <span class="pre">2)</span></code>.</p>
<p>The following wraps all the statements into an assert, and packages them into SMT-LIB format.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span>  <span class="n">asserts</span> <span class="o">:=</span> <span class="n">asserts.map</span> <span class="k">fun</span> <span class="n">c</span> <span class="bp">=&gt;</span> <span class="n">sexp</span><span class="bp">!</span><span class="o">{(</span><span class="n">assert</span> <span class="o">{</span><span class="n">c</span><span class="o">})}</span>

  <span class="c1">-- Use the theory of quantifier-free bitvector expressions, and find a model if SAT</span>
  <span class="n">sexps</span><span class="bp">!</span><span class="o">{</span>
    <span class="o">(</span><span class="n">set</span><span class="bp">-</span><span class="n">logic</span> <span class="n">QF_BV</span><span class="o">)</span>
    <span class="o">(</span><span class="n">set</span><span class="bp">-</span><span class="n">option</span> <span class="o">:</span><span class="n">produce</span><span class="bp">-</span><span class="n">models</span> <span class="n">true</span><span class="o">)</span>
    <span class="bp">...</span><span class="o">{(</span><span class="n">consts</span> <span class="bp">++</span> <span class="n">asserts</span><span class="o">)</span><span class="bp">.</span><span class="n">toList</span><span class="o">}</span>
    <span class="o">(</span><span class="n">check</span><span class="bp">-</span><span class="n">sat</span><span class="o">)</span>
    <span class="o">(</span><span class="n">get</span><span class="bp">-</span><span class="n">model</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div>
</div>
<p>The preceding snippets are all part of a function <code class="docutils literal notranslate"><span class="pre">magicSquareToBvSmt</span></code> that,
for each value of <span class="math notranslate nohighlight">\(n\)</span>, assembles the constraints into a list of SMT-LIB commands
that ask for a model of an <span class="math notranslate nohighlight">\(n \times n\)</span> magic square.
The following calls the SMT solver CVC5 on the resulting formula:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="o">(</span><span class="k">do</span>
  <span class="k">let</span> <span class="n">cmds</span> <span class="o">:=</span> <span class="n">magicSquareToBvSmt</span> <span class="mi">3</span>
  <span class="c1">-- Set `verbose := false` to hide SMT-LIB communications</span>
  <span class="k">let</span> <span class="n">out</span> <span class="bp">←</span> <span class="n">callCvc5</span> <span class="n">cmds</span> <span class="o">(</span><span class="n">verbose</span> <span class="o">:=</span> <span class="n">true</span><span class="o">)</span>
  <span class="k">match</span> <span class="n">out</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">Sexp.atom</span> <span class="s2">&quot;sat&quot;</span> <span class="o">::</span> <span class="n">m</span> <span class="o">::</span> <span class="n">_</span> <span class="bp">=&gt;</span>
    <span class="n">IO.println</span> <span class="s2">&quot;SAT with assignment:&quot;</span>
    <span class="n">for</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">in</span> <span class="n">decodeModelConsts</span> <span class="n">m</span> <span class="k">do</span>
      <span class="n">IO.println</span> <span class="n">s</span><span class="bp">!</span><span class="s2">&quot;{x} ↦ {evalNumConst b |&gt;.get!}&quot;</span>
    <span class="n">IO.println</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Square:&quot;</span>
    <span class="n">printMagicSquare</span> <span class="mi">3</span> <span class="n">m</span>
  <span class="bp">|</span> <span class="n">ss</span> <span class="bp">=&gt;</span>
    <span class="n">IO.println</span> <span class="s2">&quot;Not SAT. Solver output:&quot;</span>
    <span class="n">IO.println</span> <span class="n">ss</span>

  <span class="o">:</span> <span class="n">IO</span> <span class="n">Unit</span><span class="o">)</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">printMagicSquare</span></code> shows the result.
You can change <code class="docutils literal notranslate"><span class="pre">Cvc5</span></code> to <code class="docutils literal notranslate"><span class="pre">Cvc4</span></code> or <code class="docutils literal notranslate"><span class="pre">Z3</span></code>, as long as the relevant solver is in <code class="docutils literal notranslate"><span class="pre">LAMR/bin</span></code>.</p>
</div>
<div class="section" id="application-verification">
<h2><span class="section-number">13.4. </span>Application: Verification<a class="headerlink" href="#application-verification" title="Permalink to this headline">¶</a></h2>
<p>SMT solvers are frequently used for verification tasks. In software verification, SMT solvers can be used to validate whether some optimized code is functionally equivalent to some straightforward code (the specification). For example, consider the C code below, which efficiently computes the number of bits that are set to true in an unsigned integer (32-bit). This code is significantly more efficient compared to looping over the bits to perform the counting.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">popCount32</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x55555555</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x33333333</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x33333333</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xf0f0f0f</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x1010101</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Validating the correctness of the above procedure can be done efficiently using the small SMT-LIB file shown below. After selecting the theory QF_BV, the file starts with declaring a single 32-bit bitvector <code class="docutils literal notranslate"><span class="pre">x</span></code>.  For each line in the C code, a function is defined with 32-bit bitvectors as input and as output. Additionally, the specification function is declared as well. Each line in that function extracts a single bit from the bitvector and checks whether it is set to true (<code class="docutils literal notranslate"><span class="pre">#b1</span></code>). In that case it increases the count by 1 (shown as a 32-bit bitvector).</p>
<p>At the end of the SMT-LIB file, there is a single constraint. To check whether the two implementations are equivalent, it asks whether there exists an <code class="docutils literal notranslate"><span class="pre">x</span></code> such that the implementations produce a different result. If that formula is satisfiable, then we found a counterexample to the equivalence. If the formula is unsatisfiable, then the implementations are equivalent.</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">set-logic</span> <span class="nv">QF_BV</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">32</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define-fun</span> <span class="nv">pcLine1</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">32</span><span class="p">)))</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">32</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">bvsub</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">bvand</span> <span class="p">(</span><span class="nv">bvlshr</span> <span class="nv">x</span> <span class="mh">#x00000001</span><span class="p">)</span> <span class="mh">#x55555555</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">define-fun</span> <span class="nv">pcLine2</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">32</span><span class="p">)))</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">32</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">bvadd</span> <span class="p">(</span><span class="nv">bvand</span> <span class="nv">x</span> <span class="mh">#x33333333</span><span class="p">)</span> <span class="p">(</span><span class="nv">bvand</span> <span class="p">(</span><span class="nv">bvlshr</span> <span class="nv">x</span> <span class="mh">#x00000002</span><span class="p">)</span> <span class="mh">#x33333333</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">define-fun</span> <span class="nv">pcLine3</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">32</span><span class="p">)))</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">32</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">bvlshr</span> <span class="p">(</span><span class="nv">bvmul</span> <span class="p">(</span><span class="nv">bvand</span> <span class="p">(</span><span class="nv">bvadd</span> <span class="p">(</span><span class="nv">bvlshr</span> <span class="nv">x</span> <span class="mh">#x00000004</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="mh">#x0f0f0f0f</span><span class="p">)</span> <span class="mh">#x01010101</span><span class="p">)</span>
                    <span class="mh">#x00000018</span><span class="p">))</span>

<span class="p">(</span><span class="nv">define-fun</span> <span class="nv">popCount32</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">32</span><span class="p">)))</span> <span class="p">(</span><span class="nv">_</span> <span class="nv">BitVec</span> <span class="mi">32</span><span class="p">)</span>
     <span class="p">(</span><span class="nv">bvadd</span> <span class="p">(</span><span class="nv">ite</span> <span class="p">(</span><span class="nb">=</span> <span class="mb">#b1</span> <span class="p">((</span><span class="nv">_</span> <span class="nv">extract</span>  <span class="mi">0</span>  <span class="mi">0</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span> <span class="mh">#x00000001</span> <span class="mh">#x00000000</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">ite</span> <span class="p">(</span><span class="nb">=</span> <span class="mb">#b1</span> <span class="p">((</span><span class="nv">_</span> <span class="nv">extract</span>  <span class="mi">1</span>  <span class="mi">1</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span> <span class="mh">#x00000001</span> <span class="mh">#x00000000</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">ite</span> <span class="p">(</span><span class="nb">=</span> <span class="mb">#b1</span> <span class="p">((</span><span class="nv">_</span> <span class="nv">extract</span>  <span class="mi">2</span>  <span class="mi">2</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span> <span class="mh">#x00000001</span> <span class="mh">#x00000000</span><span class="p">)</span>
            <span class="o">...</span>
            <span class="p">(</span><span class="nv">ite</span> <span class="p">(</span><span class="nb">=</span> <span class="mb">#b1</span> <span class="p">((</span><span class="nv">_</span> <span class="nv">extract</span> <span class="mi">30</span> <span class="mi">30</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span> <span class="mh">#x00000001</span> <span class="mh">#x00000000</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">ite</span> <span class="p">(</span><span class="nb">=</span> <span class="mb">#b1</span> <span class="p">((</span><span class="nv">_</span> <span class="nv">extract</span> <span class="mi">31</span> <span class="mi">31</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span> <span class="mh">#x00000001</span> <span class="mh">#x00000000</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nv">pcLine3</span> <span class="p">(</span><span class="nv">pcLine2</span> <span class="p">(</span><span class="nv">pcLine1</span> <span class="nv">x</span><span class="p">)))</span> <span class="p">(</span><span class="nv">popCount32</span> <span class="nv">x</span><span class="p">))))</span>
<span class="p">(</span><span class="nv">check-sat</span><span class="p">)</span>
<span class="p">(</span><span class="nv">exit</span><span class="p">)</span>
</pre></div>
</div>
<p>This formula can be solved in about a second.
You can find the example implemented in the file <code class="docutils literal notranslate"><span class="pre">popCount.lean</span></code>.
Note that this approach is significantly faster than any implementation that explores the entire search space of <span class="math notranslate nohighlight">\(2^{32}\)</span> possible inputs.</p>
</div>
<div class="section" id="exercise-almost-squares">
<h2><span class="section-number">13.5. </span>Exercise: Almost squares<a class="headerlink" href="#exercise-almost-squares" title="Permalink to this headline">¶</a></h2>
<p>The almost square of order <span class="math notranslate nohighlight">\(n\)</span> is a rectangle of size <span class="math notranslate nohighlight">\(n \times (n + 1)\)</span>. The almost squares of orders 1 to 3 can fully cover the almost square of order 4. A solution is shown below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
</tr>
</tbody>
</table>
<p>In this exercise, we are going to encode whether the almost squares of order 1 to <span class="math notranslate nohighlight">\(n\)</span> can fully cover the almost of order <span class="math notranslate nohighlight">\(m\)</span>. The encoding uses the QF_LIA theory. The encoding uses <span class="math notranslate nohighlight">\(4n\)</span> variables: for the almost square of order <code class="docutils literal notranslate"><span class="pre">i</span></code>, we use variables <code class="docutils literal notranslate"><span class="pre">xmin_i</span></code>, <code class="docutils literal notranslate"><span class="pre">xmax_i</span></code>, <code class="docutils literal notranslate"><span class="pre">ymin_i</span></code>, and <code class="docutils literal notranslate"><span class="pre">ymax_i</span></code>. The variable <code class="docutils literal notranslate"><span class="pre">xmin_i</span></code> (<code class="docutils literal notranslate"><span class="pre">xmax_i</span></code>) denotes the first (last, respectively) row in which the almost square of order <code class="docutils literal notranslate"><span class="pre">i</span></code> is placed. Similarly, the variable <code class="docutils literal notranslate"><span class="pre">ymin_i</span></code> (<code class="docutils literal notranslate"><span class="pre">ymax_i</span></code>) denotes the first (last, respectively) column in which the almost square of order <code class="docutils literal notranslate"><span class="pre">i</span></code> is placed.</p>
<p>The covering of the almost square of order 4 shown above can be expressed using the following assignment to these variables:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xmin_1</span> <span class="pre">=</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">xmax_1</span> <span class="pre">=</span> <span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">ymin_1</span> <span class="pre">=</span> <span class="pre">4</span></code>, <code class="docutils literal notranslate"><span class="pre">ymax_1</span> <span class="pre">=</span> <span class="pre">4</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xmin_2</span> <span class="pre">=</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">xmax_2</span> <span class="pre">=</span> <span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">ymin_2</span> <span class="pre">=</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">ymax_2</span> <span class="pre">=</span> <span class="pre">3</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xmin_3</span> <span class="pre">=</span> <span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">xmax_3</span> <span class="pre">=</span> <span class="pre">5</span></code>, <code class="docutils literal notranslate"><span class="pre">ymin_3</span> <span class="pre">=</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">ymax_3</span> <span class="pre">=</span> <span class="pre">4</span></code></p></li>
</ul>
<p>The code fragment below shows the first part of the encoding used to compute the covering. It shows the declaration of the first variables and the first constraints on those variables.</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">set-logic</span> <span class="nv">QF_LIA</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">xmin_1</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">xmax_1</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">ymin_1</span> <span class="nv">Int</span><span class="p">)</span>
<span class="p">(</span><span class="nv">declare-const</span> <span class="nv">ymax_1</span> <span class="nv">Int</span><span class="p">)</span>
<span class="o">...</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;=</span> <span class="nv">xmin_1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">xmax_1</span> <span class="mi">5</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;=</span> <span class="nv">ymin_1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">ymax_1</span> <span class="mi">4</span><span class="p">)))</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Finish the encoding use the following steps:</p>
<p>Step 1) Express as the constraints that ensure that the almost square of order <code class="docutils literal notranslate"><span class="pre">i</span></code> covers exactly a subgrid of
<span class="math notranslate nohighlight">\(n \times (n + 1)\)</span> or <span class="math notranslate nohighlight">\((n + 1) \times n\)</span>. The only variables that you can use are <code class="docutils literal notranslate"><span class="pre">xmin_i</span></code>, <code class="docutils literal notranslate"><span class="pre">xmax_i</span></code>, <code class="docutils literal notranslate"><span class="pre">ymin_i</span></code>, and <code class="docutils literal notranslate"><span class="pre">ymax_i</span></code>. Hint: Split the constraint into three parts with one part that enforces the relation between <code class="docutils literal notranslate"><span class="pre">xmin_i</span></code> and <code class="docutils literal notranslate"><span class="pre">xmax_i</span></code>, one part that enforces the relation between <code class="docutils literal notranslate"><span class="pre">ymin_i</span></code> and <code class="docutils literal notranslate"><span class="pre">ymax_i</span></code>, and one part that enforces the relation between all four variables.</p>
<p>Step 2) For each pair of almost squares, express the constraint that they cannot overlap each other, i.e., there is no cell that is covered by multiple almost squares.</p>
<p>Step 3) Determine a grid assignment showing that the almost squares of orders 1 to 8 can fully cover the almost square of order 15. SMT solvers should be able to quickly solve the intended encoding. The same encoding can also be used to cover the almost square of order 55 with the almost squares of order 1 to 20. Solving this formula can take minutes.</p>
<p>Step 4) Encode the same problem using the theory QF_BV and compare the runtimes between the two theories.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="deduction_for_first_order_logic.html" class="btn btn-neutral float-right" title="14. Deduction for First-Order Logic" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="decision_procedures_for_first_order_logic.html" class="btn btn-neutral float-left" title="12. Decision Procedures for First-Order Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>