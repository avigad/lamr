<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>14. Deduction for First-Order Logic &mdash; Logic and Mechanized Reasoning 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script>window.MathJax = {"loader": {"load": ["[tex]/bussproofs"]}, "tex": {"packages": {"[+]": ["bussproofs"]}, "macros": {"fn": ["\\mathit{#1}", 1], "fa": ["\\forall #1. \\,", 1], "ex": ["\\exists #1. \\,", 1], "bN": "{\\mathbb{N}}", "bZ": "{\\mathbb{Z}}", "bR": "{\\mathbb{R}}", "limplies": "\\to", "liff": "\\leftrightarrow", "proves": "\\vdash", "append": "\\mathbin{+\\mkern-10mu+}", "tval": ["[\\![#1]\\!]", 1], "fCenter": "\\proves", "mdl": ["\\mathfrak{#1}", 1]}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="15. Using First-Order Theorem Provers" href="using_first_order_theorem_provers.html" />
    <link rel="prev" title="13. Using SMT solvers" href="using_smt_solvers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Logic and Mechanized Reasoning
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mathematical_background.html">2. Mathematical Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_lean_as_a_programming_language.html">3. Lean as a Programming Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">4. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_propositional_logic.html">5. Implementing Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_propositional_logic.html">6. Decision Procedures for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_sat_solvers.html">7. Using SAT Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="deduction_for_propositional_logic.html">8. Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">9. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">10. First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_first_order_logic.html">11. Implementing First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="decision_procedures_for_first_order_logic.html">12. Decision Procedures for First-Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_smt_solvers.html">13. Using SMT solvers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">14. Deduction for First-Order Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#axiomatic-systems">14.1. Axiomatic systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-sequent-calculus">14.2. A sequent calculus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#resolution">14.3. Resolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#natural-deduction">14.4. Natural deduction</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="using_first_order_theorem_provers.html">15. Using First-Order Theorem Provers</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">16. First-Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="beyond_first_order_logic.html">17. Beyond First-Order Logic</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Logic and Mechanized Reasoning</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><span class="section-number">14. </span>Deduction for First-Order Logic</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/deduction_for_first_order_logic.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="deduction-for-first-order-logic">
<span id="chapter-deduction-for-first-order-logic"></span><h1><span class="section-number">14. </span>Deduction for First-Order Logic<a class="headerlink" href="#deduction-for-first-order-logic" title="Permalink to this heading"></a></h1>
<p>The fundamental difference between propositional logic and first-order logic
is that in first-order logic there are variables and terms
that stand for objects, and we can form atomic propositions that depend on those objects.
Within the framework, the two key ingredients are equality and the quantifiers.
Deduction systems for first-order logic have to extend those for propositional logic
by providing rules for these.</p>
<p>As was the case for propositional logic, all the deductive systems we describe in this
section are sound and complete for first-order logic,
though we do not provide detailed proofs here.</p>
<section id="axiomatic-systems">
<h2><span class="section-number">14.1. </span>Axiomatic systems<a class="headerlink" href="#axiomatic-systems" title="Permalink to this heading"></a></h2>
<p>We have already discussed equational reasoning in <a class="reference internal" href="decision_procedures_for_first_order_logic.html#section-equality"><span class="std std-numref">Section 12.3</span></a>.
We have seen that the natural rules for equality are given by reflexivity, symmetry,
transitivity, and congruence with respect to functions and relations.
These can be expressed as rules, but also as first-order axioms:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\fa x x = x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x, y} x = y \limplies y = x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x, y, z} x = y \land y = z \limplies x = z\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x_1, \ldots, x_n, y_1, \ldots, y_n} x_1 = y_1 \land \cdots x_n = y_n \limplies f(x_1, \ldots, x_n) = f(y_1, \ldots, y_n)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x_1, \ldots, x_n, y_1, \ldots, y_n} x_1 = y_1 \land \cdots x_n = y_n \land R(x_1, \ldots, x_n) \limplies R(y_1, \ldots, y_n)\)</span>.</p></li>
</ul>
<p>From these, we can derive substitution for terms and formulas:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\fa {x, y} x = y \limplies t(x) = t(y)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x, y} x = y \land A(x) \limplies A(y)\)</span></p></li>
</ul>
<p>Sometimes these are taken as axioms instead of congruence.
Remember that we are adopting the convention what when we use notation like <span class="math notranslate nohighlight">\(t(x)\)</span>,
we have in mind a certain variable <span class="math notranslate nohighlight">\(z\)</span> that <span class="math notranslate nohighlight">\(t\)</span> might depend on and we take
<span class="math notranslate nohighlight">\(t(x)\)</span> to stand for <span class="math notranslate nohighlight">\(t[x/z]\)</span> and <span class="math notranslate nohighlight">\(t(y)\)</span> to stand for <span class="math notranslate nohighlight">\(t[y/z]\)</span>.
Similar conventions hold for formula <span class="math notranslate nohighlight">\(A(x)\)</span>.</p>
<p>The axioms for the quantifiers follow naturally from their meanings:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((\fa x A) \limplies A[t/x]\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A[t/x] \limplies \ex x A\)</span>.</p></li>
</ul>
<p>The first says that if <span class="math notranslate nohighlight">\(A\)</span> holds of everything, then it holds of any particular thing,
and the second says that if <span class="math notranslate nohighlight">\(A\)</span> holds of any particular thing, then it holds of something.</p>
<p>These axioms are only half the story, though. The first axiom tells us how to <em>use</em> a statement
that starts with a universal quantifier but not how to <em>prove</em> it, and the second one tells us
how to prove a statement with an existential quantifier but not how to use it. How do we
prove <span class="math notranslate nohighlight">\(\fa x A\)</span>? Establishing <span class="math notranslate nohighlight">\(\fa x A\)</span> involves showing that <span class="math notranslate nohighlight">\(A\)</span> holds of
an arbitrary value of <span class="math notranslate nohighlight">\(x\)</span>. To do that, we let <span class="math notranslate nohighlight">\(x\)</span> be arbitrary, and prove <span class="math notranslate nohighlight">\(A\)</span>.
This suggests the following rule of generalization:</p>
<blockquote>
<div><p>From <span class="math notranslate nohighlight">\(A\)</span>, conclude <span class="math notranslate nohighlight">\(\fa x A\)</span>.</p>
</div></blockquote>
<p>The actual rule we use is a generalization of this: if we have shown that <span class="math notranslate nohighlight">\(A\)</span> follows
from <span class="math notranslate nohighlight">\(B\)</span>, and <span class="math notranslate nohighlight">\(B\)</span> doesn’t say anything about <span class="math notranslate nohighlight">\(x\)</span>, then we have shown that
<span class="math notranslate nohighlight">\(B\)</span> implies that <span class="math notranslate nohighlight">\(A\)</span> holds for any <span class="math notranslate nohighlight">\(x\)</span> at all.</p>
<ul class="simple">
<li><p>From <span class="math notranslate nohighlight">\(B \limplies A\)</span> conclude <span class="math notranslate nohighlight">\(B \limplies \fa x A\)</span>, assuming <span class="math notranslate nohighlight">\(x\)</span> is not free in <span class="math notranslate nohighlight">\(B\)</span>.</p></li>
</ul>
<p>The dual rule for the existential quantifier says that if <span class="math notranslate nohighlight">\(B\)</span> follows from the assumption
that <span class="math notranslate nohighlight">\(A\)</span> holds of some <span class="math notranslate nohighlight">\(x\)</span>, then <span class="math notranslate nohighlight">\(B\)</span> follows from the assumption
that there exists an <span class="math notranslate nohighlight">\(x\)</span> satisfying <span class="math notranslate nohighlight">\(B\)</span>.</p>
<ul class="simple">
<li><p>From <span class="math notranslate nohighlight">\(A \limplies B\)</span> conclude <span class="math notranslate nohighlight">\((\ex x A) \limplies B\)</span>, assuming <span class="math notranslate nohighlight">\(x\)</span> is not free in <span class="math notranslate nohighlight">\(B\)</span>.</p></li>
</ul>
</section>
<section id="a-sequent-calculus">
<h2><span class="section-number">14.2. </span>A sequent calculus<a class="headerlink" href="#a-sequent-calculus" title="Permalink to this heading"></a></h2>
<p>We can also extend the cut-free sequent calculus described in <a class="reference internal" href="deduction_for_propositional_logic.html#section-propositional-sequent-calculus"><span class="std std-numref">Section 8.2</span></a> to first-order logic.
Remember that the system derives sets of formulas <span class="math notranslate nohighlight">\(\Gamma\)</span> in negation-normal form.
We interpret a proof as telling us that in any model, and with any assignment to the free
variables, at least one of the formula in <span class="math notranslate nohighlight">\(\Gamma\)</span> is true.
In the case of propositional logic, we took the axioms to be finite sets <span class="math notranslate nohighlight">\(\Gamma\)</span>
that contain a complementary pair of atoms <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(\lnot P\)</span>.
In the presence of equality, we now take the axioms to be sets <span class="math notranslate nohighlight">\(\Gamma\)</span> such that
the set of negations of those formulas can be refuted using equational reasoning.
For example, <span class="math notranslate nohighlight">\(\lnot P(a), a \ne b, P(b)\)</span> is an axiom, because equational reasoning
refutes the set <span class="math notranslate nohighlight">\(P(a), a = b, \lnot P(b)\)</span>.
We can determine whether a finite set of formulas is an axiom using congruence closure.</p>
<p>The other rules of the system are as follows:</p>
<blockquote>
<div>\[\begin{prooftree}
\AXC{$\Gamma, A$}
\AXC{$\Gamma, B$}
\BIC{$\Gamma, A \land B$}
\end{prooftree} \quad\quad
\begin{prooftree}
\AXC{$\Gamma, A, B$}
\UIC{$\Gamma, A \lor B$}
\end{prooftree}
\]

\[\begin{prooftree}
\AXC{$\Gamma, A$}
\UIC{$\Gamma, \fa x A$}
\end{prooftree}
\quad\quad
\begin{prooftree}
\AXC{$\Gamma, A[t/x]$}
\UIC{$\Gamma, \ex x A$}
\end{prooftree}
\]</div></blockquote>
<p>In the rule for the universal quantifier, we require that <span class="math notranslate nohighlight">\(x\)</span> is not free in any formula
in <span class="math notranslate nohighlight">\(\Gamma\)</span>. This is analogous to the requirement in the previous section that <span class="math notranslate nohighlight">\(x\)</span>
is not free in the formula <span class="math notranslate nohighlight">\(B\)</span> in the generalization rule.
You can think of it as saying that <span class="math notranslate nohighlight">\(x\)</span> is really arbitrary.</p>
<p>As in <a class="reference internal" href="deduction_for_propositional_logic.html#section-propositional-sequent-calculus"><span class="std std-numref">Section 8.2</span></a>, we can add the cut rule, which represents
a form of modus ponens. In class, we will sketch a proof that this system is complete even
without the cut rule.</p>
</section>
<section id="resolution">
<h2><span class="section-number">14.3. </span>Resolution<a class="headerlink" href="#resolution" title="Permalink to this heading"></a></h2>
<p>We now explain how to extend propositional resolution to the first-order setting.
As with propositional resolution, first-order resolution is a refutational proof system:
to prove <span class="math notranslate nohighlight">\(A\)</span>, we assume <span class="math notranslate nohighlight">\(\lnot A\)</span> and derive a contradiction.
Remember that propositional resolution required us to put formulas in conjunctive
normal form.
Having quantifiers complicates things.
One option is to put <span class="math notranslate nohighlight">\(\lnot A\)</span> in prenex form, with all the quantifiers in front,
and then put the quantifier-free part of the formula in CNF.
This is a step in the right direction,
but the presence of existential quantifiers makes automated reasoning more difficult,
so we introduce a method, <em>Skolemization</em>, to get rid of them.</p>
<p>Here is the idea. Suppose we are trying to refute a formula of the form
<span class="math notranslate nohighlight">\(\fa x \ex y A(x, y)\)</span>.
From a semantic point of view, we are trying to show that this formula is unsatisfiable.
Let <span class="math notranslate nohighlight">\(f(x)\)</span> be a new function symbol.
We claim that <span class="math notranslate nohighlight">\(\fa x \ex y A(x, y)\)</span> is equisatisfiable with
<span class="math notranslate nohighlight">\(\fa x A(x, f(x))\)</span>.
As a result, we can refute <span class="math notranslate nohighlight">\(\fa x \ex y A(x, y)\)</span> by refuting <span class="math notranslate nohighlight">\(\fa x A(x, f(x))\)</span>.
One direction of the claim is easy: any model of <span class="math notranslate nohighlight">\(\fa x A(x, f(x))\)</span> is a model of
<span class="math notranslate nohighlight">\(\fa x \ex y A(x, y)\)</span>. To see this, notice that
if <span class="math notranslate nohighlight">\(\mdl M\)</span> satisfies <span class="math notranslate nohighlight">\(\fa x A(x, f(x))\)</span>,
then it also satisfies <span class="math notranslate nohighlight">\(\fa x \ex y A(x, y)\)</span>: given any value <span class="math notranslate nohighlight">\(a\)</span> in the universe
of <span class="math notranslate nohighlight">\(\mdl M\)</span>, if we set <span class="math notranslate nohighlight">\(b\)</span> equal to <span class="math notranslate nohighlight">\(f^{\mdl M}(a)\)</span>, then <span class="math notranslate nohighlight">\(A\)</span> holds
of <span class="math notranslate nohighlight">\(a\)</span> and <cite>b</cite> in <span class="math notranslate nohighlight">\(\mdl M\)</span>.
For the other direction, suppose <span class="math notranslate nohighlight">\(\mdl M\)</span> is a model of <span class="math notranslate nohighlight">\(\fa x \ex y A(x, y)\)</span>.
That means that for every value <span class="math notranslate nohighlight">\(a\)</span> in the universe
of <span class="math notranslate nohighlight">\(\mdl M\)</span>, there is a value <span class="math notranslate nohighlight">\(b\)</span> such that <span class="math notranslate nohighlight">\(A\)</span> holds
of <span class="math notranslate nohighlight">\(a\)</span> and <cite>b</cite>. We can then interpret <span class="math notranslate nohighlight">\(f\)</span> as any function
that, for any <span class="math notranslate nohighlight">\(a\)</span>, returns such a value <span class="math notranslate nohighlight">\(b\)</span>.</p>
<p>More generally, given any formula <span class="math notranslate nohighlight">\(A(x, y)\)</span> and a new function symbol <span class="math notranslate nohighlight">\(f(x)\)</span>,
we can expand any model for the language of <span class="math notranslate nohighlight">\(A\)</span> with an interpretation of <span class="math notranslate nohighlight">\(f(x)\)</span>
satisfying <span class="math notranslate nohighlight">\(\fa x (\ex y A(x, y)) \liff A(x, f(x))\)</span>.
We simply interpret <span class="math notranslate nohighlight">\(f(x)\)</span> as a function that, whenever there is a <span class="math notranslate nohighlight">\(y\)</span> in the model
satisfying <span class="math notranslate nohighlight">\(A(x, y)\)</span>, returns such a <span class="math notranslate nohighlight">\(y\)</span>.
Such a function is known as a <em>Skolem function</em> for <span class="math notranslate nohighlight">\(\ex y A(x, y)\)</span>,
and the process of replacing <span class="math notranslate nohighlight">\(\fa x \ex y A(x, y)\)</span> by <span class="math notranslate nohighlight">\(\fa x A(x, f(x))\)</span>
is known as <em>Skolemization</em>. The equivalence <span class="math notranslate nohighlight">\(\fa x (\ex y A(x, y)) \liff A(x, f(x))\)</span>
is known as the corresponding <em>Skolem axiom</em>.
Because we can always choose <span class="math notranslate nohighlight">\(f\)</span> to satisfy the Skolem axiom, we can replace
<span class="math notranslate nohighlight">\(\ex y A(x, y)\)</span> with <span class="math notranslate nohighlight">\(A(x, f(x))\)</span> in a set of hypotheses and preserve satisfiability.
In general, a formula <span class="math notranslate nohighlight">\(\ex y A(y)\)</span> may have more than one free variable, in which case they should
all be arguments to <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>Iteratively eliminating all the existential quantifiers in this way results in a formula in <em>Skolem
normal form</em>. It helps to put the sentence in negation-normal form first, because existential
quantifiers under negations or on the left side of an implication act like universal quantifiers
and vice versa. For example, suppose we are given the sentence</p>
<div class="math notranslate nohighlight">
\[\fa {u, x} \ex y (\fa v Q(x, y, u, v)) \to \fa z \ex w R(x, y, z, w)\]</div>
<p>where <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(R\)</span> are relation symbols.
First, we rewrite the sentence as</p>
<div class="math notranslate nohighlight">
\[\fa {u, x} \ex y (\ex v \lnot Q(x, y, u, v)) \lor \fa z \ex w R(x, y, z, w).\]</div>
<p>First, we replace <span class="math notranslate nohighlight">\(y\)</span> by a Skolem function that depends on <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(x\)</span>:</p>
<div class="math notranslate nohighlight">
\[\fa {u, x} (\ex v \lnot Q(x, f(u, x), u, v)) \lor \fa z \ex w R(x, f(u, x), z, w).\]</div>
<p>Then we replace <span class="math notranslate nohighlight">\(v\)</span>:</p>
<div class="math notranslate nohighlight">
\[\fa {u, x} \lnot Q(x, f(u, x), u, g(u, x)) \lor \fa z \ex w R(x, f(u, x), z, w).\]</div>
<p>Finally, we replace <span class="math notranslate nohighlight">\(w\)</span>:</p>
<div class="math notranslate nohighlight">
\[\fa {u, x} \lnot Q(x, f(u, x), u, g(u, x)) \lor \fa z R(x, f(u, x), z, h(u, x, z)).\]</div>
<p>We are now left with only universal quantifiers.</p>
<p>In this example, if we bring <span class="math notranslate nohighlight">\(z\)</span> to the front, we get a universally quantified clause:</p>
<div class="math notranslate nohighlight">
\[\fa {u, x, z} \lnot Q(x, f(u, x), u, g(u, x)) \lor R(x, f(u, x), z, h(u, x, z)).\]</div>
<p>More generally, we can always bring the
universal quantifiers to the front and put the rest of the formula in conjunctive normal form.
Using the identity <span class="math notranslate nohighlight">\((\fa x A \land B) \liff (\fa x A) \land (\fa x B)\)</span>,
we can then reduce the original sentence to a conjunction of universally quantified clauses.</p>
<p>A <em>resolution proof</em> is designed to refute a set of universally quantified clauses.
The <em>resolution rule</em> from first-order logic is now generalized as follows:
given two universally quantified clauses, instantiate the universal quantifiers to
obtain a complementary literal, resolve, and then generalize.
For example, given</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\fa {x, y} A(f(x),y)\)</span> and</p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {w, z} \lnot A(w, g(z)) \lor B(w, z)\)</span>,</p></li>
</ul>
<p>we can do the following:</p>
<ul class="simple">
<li><p>instantiate <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(y\)</span> to <span class="math notranslate nohighlight">\(g(v)\)</span> in the
first to get <span class="math notranslate nohighlight">\(A(f(u),g(v))\)</span>,</p></li>
<li><p>instantiate <span class="math notranslate nohighlight">\(w\)</span> to <span class="math notranslate nohighlight">\(f(u)\)</span> and <span class="math notranslate nohighlight">\(z\)</span> to <span class="math notranslate nohighlight">\(v\)</span> in the
second to get <span class="math notranslate nohighlight">\(\lnot A(f(u), g(v)) \lor B(f(u), v)\)</span>,</p></li>
<li><p>resolve, to get <span class="math notranslate nohighlight">\(B(f(u), v)\)</span>, and then</p></li>
<li><p>generalize, to get <span class="math notranslate nohighlight">\(\fa {u, v} B(f(u), v)\)</span>.</p></li>
</ul>
<p>We then say that <span class="math notranslate nohighlight">\(\fa {u, v} B(f(u), v)\)</span> has been obtained by resolution from
the two hypotheses.</p>
<p>As with propositional logic, a first-order resolution refutation is a proof of the empty clause
using the resolution rule. For example, suppose we have the following hypotheses:</p>
<ul class="simple">
<li><p>Every smart and motivated student likes logic.</p></li>
<li><p>Every student at Carnegie Mellon is smart.</p></li>
<li><p>At least one student at Carnegie Mellon is motivated.</p></li>
</ul>
<p>Let us show that someone likes logic.
We introduce predicates <span class="math notranslate nohighlight">\(S(x)\)</span>, <span class="math notranslate nohighlight">\(M(x)\)</span>, <span class="math notranslate nohighlight">\(L(x)\)</span>, and <span class="math notranslate nohighlight">\(C(x)\)</span> for
“smart,” “motivated,” “likes logic”, and “is at Carnegie Mellon.”
Negating the conclusion and expressing
the statements as universally quantified clauses, we get:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\fa x \lnot S(x) \lor \lnot M(x) \lor L(x)\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\fa x \lnot C(x) \lor S(x)\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(C(a)\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(M(a)\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\fa x \lnot L(x)\)</span>.</p></li>
</ol>
<p>Notice that the existential quantifier in the third hypothesis has been Skolemized to produce
the constant <span class="math notranslate nohighlight">\(a\)</span>,
and that we split the resulting conjunction into two singleton clauses.
We now refute the hypotheses as follows:</p>
<ol class="arabic simple" start="6">
<li><p><span class="math notranslate nohighlight">\(\fa x \lnot C(x) \lor \lnot M(x) \lor L(x)\)</span>, from 1 and 2.</p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot M(a) \lor L(a)\)</span>, from 6 and 3.</p></li>
<li><p><span class="math notranslate nohighlight">\(L(a)\)</span>, from 7 and 4.</p></li>
<li><p><span class="math notranslate nohighlight">\(\bot\)</span> from 8 and 5.</p></li>
</ol>
<p>Another example (stolen from John Harrison’s book) is the barber paradox.
Suppose we are told that in a given town there is a male barber who shaves all and only
those men who don’t shave themselves.
We obtain a contradiction by asking who shaves the barber.
Formally, this amounts to a refutation of the sentence
<span class="math notranslate nohighlight">\(\ex x \fa y S(x, y) \liff \lnot S(y, y)\)</span>.
Skolemizing and expressing this as a conjunction of clauses, we get:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\fa y \lnot S(a, y) \lor \lnot S(y,y)\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\fa y S(y, y) \lor S(a, y)\)</span>.</p></li>
</ul>
<p>Instantiating <span class="math notranslate nohighlight">\(y\)</span> to <span class="math notranslate nohighlight">\(a\)</span> in both cases and resolving yields the empty clause.</p>
<p>As you might have guessed,
this is where <em>unification</em>, discussed in <a class="reference internal" href="implementing_first_order_logic.html#section-unification"><span class="std std-numref">Section 11.4</span></a>, comes in handy.
When looking for resolvents, though, it’s not always sufficient to look for most general unifiers
of a literal from each clause; sometimes a resolution step has to unify two or more literals
in the same clause as well.
The example of the barber paradox illustrates this. You can check that in this
case we are not forced to instantiate both instances of <span class="math notranslate nohighlight">\(y\)</span> to <span class="math notranslate nohighlight">\(a\)</span> unless
we consider more than two literals,
and anything short of that fails to produce a new clause.</p>
<p>The proof system we have just described is sound and complete for first-order logic without
equality. The general method of proof search is implicit in the presentation:
systematically searching for substitutions that yield complementary literals and resolving
on them is guaranteed to find a refutation if one exists.
In general, if there is no refutation, the search may continue forever.
We can prove that the calculus is complete, as usual,
by arguing that if the search fails to terminate,
the failure points the way to the existence of a countermodel.</p>
<p>To handle equality, one option is simply to add equality axioms to the hypotheses.
This is inefficient, however. Modern first-order provers use techniques based on
<em>paramodulation</em> and <em>superposition</em>.</p>
<p>It is worth mentioning that Skolemization can also be used for search in the cut-free sequent
calculus described in the previous section, or, more or less equivalently, in a tableau search.
In an ordinary proof system (rather than a refutation system), rather than an equisatisfiable
formula, we want one that is <em>equivalid</em>.
This requires replacing the universally quantified variables rather than the existentially
quantified variables, resulting in <em>Herbrand normal form</em> instead of
<em>Skolem normal form</em>. Tableau systems are usually presented, instead, as refutation calculi,
in which case Skolem normal form is appropriate.</p>
<p>We close this section with one more example. Consider the following hypotheses:</p>
<ol class="arabic simple">
<li><p>Every students owns either an iphone or a laptop.</p></li>
<li><p>Every student who owns a laptop also owns a pair of bluetooth headphones.</p></li>
<li><p>Every iphone is buggy.</p></li>
<li><p>Every pair of bluetooth headphones is buggy.</p></li>
<li><p>Every student who owns something buggy is sad.</p></li>
</ol>
<p>From these we should be able to conclude that every student is sad.
We can formalize the hypotheses as follows:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\fa x \fn{Student}(x) \to \ex y \fn{Owns}(x, y) \land (\fn{Iphone}(y) \lor \fn{Laptop}(y))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x, y} \fn{Student}(x) \land \fn{Owns}(x,y) \land \fn{Laptop}(y) \to \ex z \fn{Owns}(x, z) \land \fn{Headphones}(z)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa y \fn{Iphone}(y) \to \fn{Buggy}(y)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa y \fn{Headphones}(y) \to \fn{Buggy}(y)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x, y} \fn{Student}(x) \land \fn{Owns}(x, y) \land \fn{Buggy}(y) \to \fn{Sad}(x)\)</span></p></li>
</ol>
<p>The desired conclusion is <span class="math notranslate nohighlight">\(\fa x \fn{Student}(x) \to \fn{Sad}(x)\)</span>.
You can check that if we negate the conclusion, Skolemize, put the results in CNF,
and move universal quantifiers through the hypotheses, we get the following:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\fa x \lnot \fn{Student}(x) \lor \fn{Owns}(x, f(x))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa x \lnot \fn{Student}(x) \lor \fn{Iphone}(f(x)) \lor \fn{Laptop}(f(x))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x, y} \lnot \fn{Student}(x) \lor \lnot \fn{Owns}(x, y) \lor \lnot \fn{Laptop}(y) \lor \fn{Headphones}(g(x,y))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x, y} \lnot \fn{Student}(x) \lor \lnot \fn{Owns}(x, y) \lor \lnot \fn{Laptop}(y) \lor \fn{Owns}(x,g(x,y))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa y \lnot \fn{Iphone}(y) \lor \fn{Buggy}(y)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa y \lnot \fn{Headphones}(y) \lor \fn{Buggy}(y)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fa {x, y} \lnot \fn{Student}(x) \lor \lnot \fn{Owns}(x, y) \lor \lnot \fn{Buggy}(y) \lor \fn{Sad}(x)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\fn{Student}(a)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\lnot \fn{Sad}(a)\)</span></p></li>
</ol>
<p>We leave it to you to construct a resolution proof of the empty clause from these.</p>
</section>
<section id="natural-deduction">
<h2><span class="section-number">14.4. </span>Natural deduction<a class="headerlink" href="#natural-deduction" title="Permalink to this heading"></a></h2>
<p>Finally, we can extend the system of natural deduction of <a class="reference internal" href="deduction_for_propositional_logic.html#section-natural-deduction"><span class="std std-numref">Section 8.4</span></a>.
The quantifier rules are as follows:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{prooftree}
\AXC{$\Gamma, A[t/x] \fCenter B$}
\UIC{$\Gamma, \fa x A \fCenter B$}
\end{prooftree}
\quad \quad
\begin{prooftree}
\AXC{$\Gamma \fCenter A$}
\UIC{$\Gamma \fCenter \fa x A$}
\end{prooftree}
\]
\[\begin{prooftree}
\AXC{$\Gamma, A \fCenter B$}
\UIC{$\Gamma, \ex x A \fCenter B$}
\end{prooftree}
\quad \quad
\begin{prooftree}
\AXC{$\Gamma \fCenter A[t/x]$}
\UIC{$\Gamma \fCenter \ex x A$}
\end{prooftree}
\]</div></div></blockquote>
<p>In the right rule for <span class="math notranslate nohighlight">\(\forall\)</span> and the left rule for <span class="math notranslate nohighlight">\(\exists\)</span>, the eigenvariable
condition amounts to the requirement that <span class="math notranslate nohighlight">\(x\)</span> is not free in any formula other than
<span class="math notranslate nohighlight">\(A\)</span>. The rules for equality are the same as in <a class="reference internal" href="decision_procedures_for_first_order_logic.html#section-equality"><span class="std std-numref">Section 12.3</span></a>,
except that in all the rules, we allow a set <span class="math notranslate nohighlight">\(\Gamma\)</span> of formulas on the left side
of the sequent.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="using_smt_solvers.html" class="btn btn-neutral float-left" title="13. Using SMT solvers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="using_first_order_theorem_provers.html" class="btn btn-neutral float-right" title="15. Using First-Order Theorem Provers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jeremy Avigad, Marijn J. H. Heule, and Wojciech Nawrocki.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>